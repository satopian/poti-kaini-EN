// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (
  modules,
  entry,
  mainEntry,
  parcelRequireName,
  externals,
  distDir,
  publicUrl,
  devServer
) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var importMap = previousRequire.i || {};
  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        if (externals[name]) {
          return externals[name];
        }
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        globalObject
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.require = nodeRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.distDir = distDir;
  newRequire.publicUrl = publicUrl;
  newRequire.devServer = devServer;
  newRequire.i = importMap;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  // Only insert newRequire.load when it is actually used.
  // The code in this file is linted against ES5, so dynamic import is not allowed.
  // INSERT_LOAD_HERE

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });
    }
  }
})({"eiwKx":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SERVER_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "439701173a9199ea";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "d578fb09dd9a59b3";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_SERVER_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_SERVER_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , disposedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ , bundleNotFound = false;
function getHostname() {
    return HMR_HOST || (typeof location !== 'undefined' && location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || (typeof location !== 'undefined' ? location.port : HMR_SERVER_PORT);
}
// eslint-disable-next-line no-redeclare
let WebSocket = globalThis.WebSocket;
if (!WebSocket && typeof module.bundle.root === 'function') try {
    // eslint-disable-next-line no-global-assign
    WebSocket = module.bundle.root('ws');
} catch  {
// ignore.
}
var hostname = getHostname();
var port = getPort();
var protocol = HMR_SECURE || typeof location !== 'undefined' && location.protocol === 'https:' && ![
    'localhost',
    '127.0.0.1',
    '0.0.0.0'
].includes(hostname) ? 'wss' : 'ws';
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if (!parent || !parent.isParcelRequire) {
    // Web extension context
    var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes('test.js');
    }
    var ws;
    if (HMR_USE_SSE) ws = new EventSource('/__parcel_hmr');
    else try {
        // If we're running in the dev server's node runner, listen for messages on the parent port.
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) {
            parentPort.on('message', async (message)=>{
                try {
                    await handleMessage(message);
                    parentPort.postMessage('updated');
                } catch  {
                    parentPort.postMessage('restart');
                }
            });
            // After the bundle has finished running, notify the dev server that the HMR update is complete.
            queueMicrotask(()=>parentPort.postMessage('ready'));
        }
    } catch  {
        if (typeof WebSocket !== 'undefined') try {
            ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
        } catch (err) {
            // Ignore cloudflare workers error.
            if (err.message && !err.message.includes('Disallowed operation called within global scope')) console.error(err.message);
        }
    }
    if (ws) {
        // $FlowFixMe
        ws.onmessage = async function(event /*: {data: string, ...} */ ) {
            var data /*: HMRMessage */  = JSON.parse(event.data);
            await handleMessage(data);
        };
        if (ws instanceof WebSocket) {
            ws.onerror = function(e) {
                if (e.message) console.error(e.message);
            };
            ws.onclose = function() {
                console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
            };
        }
    }
}
async function handleMessage(data /*: HMRMessage */ ) {
    checkedAssets = {} /*: {|[string]: boolean|} */ ;
    disposedAssets = {} /*: {|[string]: boolean|} */ ;
    assetsToAccept = [];
    assetsToDispose = [];
    bundleNotFound = false;
    if (data.type === 'reload') fullReload();
    else if (data.type === 'update') {
        // Remove error overlay if there is one
        if (typeof document !== 'undefined') removeErrorOverlay();
        let assets = data.assets;
        // Handle HMR Update
        let handled = assets.every((asset)=>{
            return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        });
        // Dispatch a custom event in case a bundle was not found. This might mean
        // an asset on the server changed and we should reload the page. This event
        // gives the client an opportunity to refresh without losing state
        // (e.g. via React Server Components). If e.preventDefault() is not called,
        // we will trigger a full page reload.
        if (handled && bundleNotFound && assets.some((a)=>a.envHash !== HMR_ENV_HASH) && typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') handled = !window.dispatchEvent(new CustomEvent('parcelhmrreload', {
            cancelable: true
        }));
        if (handled) {
            console.clear();
            // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
            if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') window.dispatchEvent(new CustomEvent('parcelhmraccept'));
            await hmrApplyUpdates(assets);
            hmrDisposeQueue();
            // Run accept callbacks. This will also re-execute other disposed assets in topological order.
            let processedAssets = {};
            for(let i = 0; i < assetsToAccept.length; i++){
                let id = assetsToAccept[i][1];
                if (!processedAssets[id]) {
                    hmrAccept(assetsToAccept[i][0], id);
                    processedAssets[id] = true;
                }
            }
        } else fullReload();
    }
    if (data.type === 'error') {
        // Log parcel errors to console
        for (let ansiDiagnostic of data.diagnostics.ansi){
            let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
            console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
        }
        if (typeof document !== 'undefined') {
            // Render the fancy html overlay
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html);
            // $FlowFixMe
            document.body.appendChild(overlay);
        }
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="${protocol === 'wss' ? 'https' : 'http'}://${hostname}:${port}/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, '') : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + '</div>').join('')}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ''}
      </div>
    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if (typeof location !== 'undefined' && 'reload' in location) location.reload();
    else if (typeof extCtx !== 'undefined' && extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
    else try {
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) parentPort.postMessage('restart');
    } catch (err) {
        console.error("[parcel] \u26A0\uFE0F An HMR update was not accepted. Please restart the process.");
    }
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute('href');
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    href.split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout || typeof document === 'undefined') return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === 'js') {
        if (typeof document !== 'undefined') {
            let script = document.createElement('script');
            script.src = asset.url + '?t=' + Date.now();
            if (asset.outputFormat === 'esmodule') script.type = 'module';
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === 'function') {
            // Worker scripts
            if (asset.outputFormat === 'esmodule') return import(asset.url + '?t=' + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + '?t=' + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        }
        // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.
        // This is required in case modules are duplicated. We need to ensure all instances have the updated code.
        if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    checkedAssets = {};
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else if (a !== null) {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) {
            bundleNotFound = true;
            return true;
        }
        return hmrAcceptCheckOne(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return null;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    if (!cached) return true;
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
    return false;
}
function hmrDisposeQueue() {
    // Dispose all old assets.
    for(let i = 0; i < assetsToDispose.length; i++){
        let id = assetsToDispose[i][1];
        if (!disposedAssets[id]) {
            hmrDispose(assetsToDispose[i][0], id);
            disposedAssets[id] = true;
        }
    }
    assetsToDispose = [];
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        let assetsToAlsoAccept = [];
        cached.hot._acceptCallbacks.forEach(function(cb) {
            let additionalAssets = cb(function() {
                return getParents(module.bundle.root, id);
            });
            if (Array.isArray(additionalAssets) && additionalAssets.length) assetsToAlsoAccept.push(...additionalAssets);
        });
        if (assetsToAlsoAccept.length) {
            let handled = assetsToAlsoAccept.every(function(a) {
                return hmrAcceptCheck(a[0], a[1]);
            });
            if (!handled) return fullReload();
            hmrDisposeQueue();
        }
    }
}

},{}],"3lJkm":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint Be
    https://github.com/satopian/ChickenPaint_Be
    by satopian
    Customized from ChickenPaint by Nicholas Sherlock.
    GNU GENERAL PUBLIC LICENSE
    Version 3, 29 June 2007
    <http://www.gnu.org/licenses/>
*/ /*
    ChickenPaint

    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.

    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ChickenPaint);
var _cpbrushInfoJs = require("./engine/CPBrushInfo.js");
var _cpbrushInfoJsDefault = parcelHelpers.interopDefault(_cpbrushInfoJs);
var _cpartworkJs = require("./engine/CPArtwork.js");
var _cpartworkJsDefault = parcelHelpers.interopDefault(_cpartworkJs);
var _cpresourceLoaderJs = require("./engine/CPResourceLoader.js");
var _cpresourceLoaderJsDefault = parcelHelpers.interopDefault(_cpresourceLoaderJs);
var _cpresourceSaverJs = require("./engine/CPResourceSaver.js");
var _cpresourceSaverJsDefault = parcelHelpers.interopDefault(_cpresourceSaverJs);
var _cpsplashScreenJs = require("./gui/CPSplashScreen.js");
var _cpsplashScreenJsDefault = parcelHelpers.interopDefault(_cpsplashScreenJs);
var _cpmainGUIJs = require("./gui/CPMainGUI.js");
var _cpmainGUIJsDefault = parcelHelpers.interopDefault(_cpmainGUIJs);
var _cpaboutDialogJs = require("./gui/CPAboutDialog.js");
var _cpaboutDialogJsDefault = parcelHelpers.interopDefault(_cpaboutDialogJs);
var _cpconfirmTransformDialogJs = require("./gui/CPConfirmTransformDialog.js");
var _cpconfirmTransformDialogJsDefault = parcelHelpers.interopDefault(_cpconfirmTransformDialogJs);
var _cpshortcutsDialogJs = require("./gui/CPShortcutsDialog.js");
var _cpshortcutsDialogJsDefault = parcelHelpers.interopDefault(_cpshortcutsDialogJs);
var _cpboxBlurDialogJs = require("./gui/CPBoxBlurDialog.js");
var _cpboxBlurDialogJsDefault = parcelHelpers.interopDefault(_cpboxBlurDialogJs);
var _cptabletDialogJs = require("./gui/CPTabletDialog.js");
var _cptabletDialogJsDefault = parcelHelpers.interopDefault(_cptabletDialogJs);
var _cpgridDialogJs = require("./gui/CPGridDialog.js");
var _cpgridDialogJsDefault = parcelHelpers.interopDefault(_cpgridDialogJs);
var _cpsendDialogJs = require("./gui/CPSendDialog.js");
var _cpsendDialogJsDefault = parcelHelpers.interopDefault(_cpsendDialogJs);
var _cppolyfillJs = require("./util/CPPolyfill.js");
var _cpcolorJs = require("./util/CPColor.js");
var _cpcolorJsDefault = parcelHelpers.interopDefault(_cpcolorJs);
var _cprectJs = require("./util/CPRect.js");
var _cprectJsDefault = parcelHelpers.interopDefault(_cprectJs);
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
var _langJs = require("./languages/lang.js");
var _cpuserPreferencesJs = require("./gui/CPUserPreferences.js");
var _cpuserPreferencesJsDefault = parcelHelpers.interopDefault(_cpuserPreferencesJs);
function isSmallScreen() {
    return Boolean(typeof navigator.maxTouchPoints === "number" && navigator.maxTouchPoints > 2 && (window.screen.width <= 820 || window.screen.height <= 820));
}
function createDrawingTools() {
    let tools = new Array(ChickenPaint.T_MAX);
    tools[ChickenPaint.T_PENCIL] = new (0, _cpbrushInfoJsDefault.default)({
        toolNb: ChickenPaint.T_PENCIL,
        size: 16,
        alpha: 255,
        isAA: true,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: true,
        tip: (0, _cpbrushInfoJsDefault.default).TIP_ROUND_AA,
        brushMode: (0, _cpbrushInfoJsDefault.default).BRUSH_MODE_PAINT,
        paintMode: (0, _cpbrushInfoJsDefault.default).PAINT_MODE_OPACITY
    });
    tools[ChickenPaint.T_ERASER] = new (0, _cpbrushInfoJsDefault.default)({
        toolNb: ChickenPaint.T_ERASER,
        size: 16,
        alpha: 255,
        isAA: true,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: false,
        texture: 0,
        tip: (0, _cpbrushInfoJsDefault.default).TIP_ROUND_AA,
        brushMode: (0, _cpbrushInfoJsDefault.default).BRUSH_MODE_ERASE,
        paintMode: (0, _cpbrushInfoJsDefault.default).PAINT_MODE_OPACITY
    });
    tools[ChickenPaint.T_PEN] = new (0, _cpbrushInfoJsDefault.default)({
        toolNb: ChickenPaint.T_PEN,
        size: 2,
        alpha: 128,
        isAA: true,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: true,
        pressureAlpha: false,
        tip: (0, _cpbrushInfoJsDefault.default).TIP_ROUND_AA,
        brushMode: (0, _cpbrushInfoJsDefault.default).BRUSH_MODE_PAINT,
        paintMode: (0, _cpbrushInfoJsDefault.default).PAINT_MODE_FLOW,
        alphaScale: 0.5
    });
    tools[ChickenPaint.T_SOFTERASER] = new (0, _cpbrushInfoJsDefault.default)({
        toolNb: ChickenPaint.T_SOFTERASER,
        size: 16,
        alpha: 64,
        isAA: false,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: true,
        texture: 1,
        tip: (0, _cpbrushInfoJsDefault.default).TIP_ROUND_AIRBRUSH,
        brushMode: (0, _cpbrushInfoJsDefault.default).BRUSH_MODE_ERASE,
        paintMode: (0, _cpbrushInfoJsDefault.default).PAINT_MODE_FLOW,
        alphaScale: 1 / 8
    });
    tools[ChickenPaint.T_AIRBRUSH] = new (0, _cpbrushInfoJsDefault.default)({
        toolNb: ChickenPaint.T_AIRBRUSH,
        size: 50,
        alpha: 32,
        isAA: false,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: true,
        tip: (0, _cpbrushInfoJsDefault.default).TIP_ROUND_AIRBRUSH,
        brushMode: (0, _cpbrushInfoJsDefault.default).BRUSH_MODE_PAINT,
        paintMode: (0, _cpbrushInfoJsDefault.default).PAINT_MODE_FLOW,
        alphaScale: 1 / 8
    });
    tools[ChickenPaint.T_DODGE] = new (0, _cpbrushInfoJsDefault.default)({
        toolNb: ChickenPaint.T_DODGE,
        size: 30,
        alpha: 32,
        isAA: false,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: true,
        tip: (0, _cpbrushInfoJsDefault.default).TIP_ROUND_AIRBRUSH,
        brushMode: (0, _cpbrushInfoJsDefault.default).BRUSH_MODE_DODGE,
        paintMode: (0, _cpbrushInfoJsDefault.default).PAINT_MODE_FLOW,
        alphaScale: 1 / 8
    });
    tools[ChickenPaint.T_BURN] = new (0, _cpbrushInfoJsDefault.default)({
        toolNb: ChickenPaint.T_BURN,
        size: 30,
        alpha: 32,
        isAA: false,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: true,
        tip: (0, _cpbrushInfoJsDefault.default).TIP_ROUND_AIRBRUSH,
        brushMode: (0, _cpbrushInfoJsDefault.default).BRUSH_MODE_BURN,
        paintMode: (0, _cpbrushInfoJsDefault.default).PAINT_MODE_FLOW,
        alphaScale: 1 / 8
    });
    tools[ChickenPaint.T_WATER] = new (0, _cpbrushInfoJsDefault.default)({
        toolNb: ChickenPaint.T_WATER,
        size: 30,
        alpha: 70,
        isAA: false,
        minSpacing: 0.5,
        spacing: 0.02,
        pressureSize: false,
        pressureAlpha: true,
        tip: (0, _cpbrushInfoJsDefault.default).TIP_ROUND_AA,
        brushMode: (0, _cpbrushInfoJsDefault.default).BRUSH_MODE_WATER,
        paintMode: (0, _cpbrushInfoJsDefault.default).PAINT_MODE_FLOW,
        alphaScale: 1 / 8,
        resat: 0.3,
        bleed: 0.6
    });
    tools[ChickenPaint.T_BLUR] = new (0, _cpbrushInfoJsDefault.default)({
        toolNb: ChickenPaint.T_BLUR,
        size: 20,
        alpha: 255,
        isAA: false,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: true,
        tip: (0, _cpbrushInfoJsDefault.default).TIP_ROUND_PIXEL,
        brushMode: (0, _cpbrushInfoJsDefault.default).BRUSH_MODE_BLUR,
        paintMode: (0, _cpbrushInfoJsDefault.default).PAINT_MODE_FLOW,
        alphaScale: 1 / 8
    });
    tools[ChickenPaint.T_SMUDGE] = new (0, _cpbrushInfoJsDefault.default)({
        toolNb: ChickenPaint.T_SMUDGE,
        size: 20,
        alpha: 128,
        isAA: false,
        minSpacing: 0.5,
        spacing: 0.01,
        pressureSize: false,
        pressureAlpha: true,
        tip: (0, _cpbrushInfoJsDefault.default).TIP_ROUND_AIRBRUSH,
        brushMode: (0, _cpbrushInfoJsDefault.default).BRUSH_MODE_SMUDGE,
        paintMode: (0, _cpbrushInfoJsDefault.default).PAINT_MODE_FLOW,
        alphaScale: 1 / 8,
        resat: 0.0,
        bleed: 1.0
    });
    tools[ChickenPaint.T_BLENDER] = new (0, _cpbrushInfoJsDefault.default)({
        toolNb: ChickenPaint.T_BLENDER,
        size: 20,
        alpha: 60,
        isAA: false,
        minSpacing: 0.5,
        spacing: 0.1,
        pressureSize: false,
        pressureAlpha: true,
        tip: (0, _cpbrushInfoJsDefault.default).TIP_ROUND_AIRBRUSH,
        brushMode: (0, _cpbrushInfoJsDefault.default).BRUSH_MODE_OIL,
        paintMode: (0, _cpbrushInfoJsDefault.default).PAINT_MODE_FLOW,
        alphaScale: 1 / 8,
        resat: 0.0,
        bleed: 0.07
    });
    return tools;
}
function ChickenPaint(options) {
    (0, _langJs.guessLanguage)();
    if (options.language) (0, _langJs.setLanguage)(options.language);
    const uiElem = options.uiElem;
    //ブラウザデフォルトのキー操作をキャンセル
    document.addEventListener("keydown", (e)=>{
        const keys = [
            "+",
            ";",
            "=",
            "-",
            "s",
            "h",
            "r",
            "o"
        ];
        if ((e.ctrlKey || e.metaKey) && keys.includes(e.key.toLowerCase()) || e.key === "Enter") // console.log("e.key",e.key);
        e.preventDefault();
    });
    //長押しでコンテキストメニューを開かない
    uiElem.addEventListener("contextmenu", (e)=>{
        e.preventDefault();
        e.stopPropagation();
    }, {
        passive: false
    });
    let that = this, /**
         * @type {CPCanvas}
         */ canvas, /**
         * @type {CPMainGUI}
         */ mainGUI, /**
         *
         * @type {CPColor}
         */ curColor = new (0, _cpcolorJsDefault.default)(0), curMaskColor = 0xff, colorMode = ChickenPaint.COLOR_MODE_RGB, curBrush = ChickenPaint.T_PENCIL, curMode = ChickenPaint.M_DRAW, preTransformMode = curMode, curGradient = [
        0xff000000,
        0xffffffff
    ], smallScreenMode = false, isFullScreen = false, tools = createDrawingTools(), preferences = new (0, _cpuserPreferencesJsDefault.default)(), boxBlurDialog, gridDialog, actions = {
        // GUI actions
        CPFullScreen: {
            action: function() {
                that.setFullScreen(!isFullScreen);
            },
            isSupported: function() {
                return !(options.fullScreenMode === "disable" || options.fullScreenMode === "force" || options.allowFullScreen === false);
            },
            modifies: {
                gui: true
            }
        },
        CPZoomIn: {
            action: function() {
                canvas.zoomIn();
            },
            modifies: {
                gui: true
            }
        },
        CPZoomOut: {
            action: function() {
                canvas.zoomOut();
            },
            modifies: {
                gui: true
            }
        },
        CPZoom100: {
            action: function() {
                canvas.zoom100();
            },
            modifies: {
                gui: true
            }
        },
        CPResetZoomAndRotation: {
            action: function() {
                canvas.resetZoomAndRotation();
                const paletteManager = mainGUI.getPaletteManager();
                const flipButton = paletteManager.palettes.misc.flipButton;
                const mainMenu = mainGUI.getMainMenu();
                const menuElement = mainMenu.getElement();
                const flipMenuItem = menuElement.querySelector('[data-action="CPViewHFlip"]');
                if (flipButton) flipButton.classList.remove("flipped");
                //表示の左右反転時には、メニュー→表示→表示の左右反転にチェックマークを外す
                if (flipMenuItem) flipMenuItem.classList.remove("selected");
            },
            modifies: {
                gui: true
            }
        },
        CPViewHFlip: {
            action: function() {
                const flipped = canvas.toggleViewFlip();
                const paletteManager = mainGUI.getPaletteManager();
                const flipButton = paletteManager.palettes.misc.flipButton;
                const mainMenu = mainGUI.getMainMenu();
                const menuElement = mainMenu.getElement();
                // console.log("mainMenu", mainMenu);
                // console.log("menuElement", menuElement);
                const flipMenuItem = menuElement.querySelector('[data-action="CPViewHFlip"]');
                if (flipButton) {
                    //表示の左右反転時には、左右反転アイコンに赤枠を付ける
                    if (flipped) flipButton.classList.add("flipped");
                    else flipButton.classList.remove("flipped");
                }
                //表示の左右反転時には、メニュー→表示→表示の左右反転にチェックマークを付ける
                if (flipMenuItem) {
                    if (flipped) flipMenuItem.classList.add("selected");
                    else flipMenuItem.classList.remove("selected");
                }
            },
            modifies: {
                gui: true
            }
        },
        // 古いアイコンは使わない。
        // CPToolbarStyle: {
        //     action: function() {
        //         that.setToolbarStyle(preferences.toolbarStyle === "new" ? "old" : "new");
        //     },
        //     modifies: {gui: true}
        // },
        // History actions
        CPUndo: {
            action: function() {
                that.artwork.undo();
            },
            modifies: {
                document: true
            },
            allowed: "isUndoAllowed"
        },
        CPRedo: {
            action: function() {
                that.artwork.redo();
            },
            modifies: {
                document: true
            },
            allowed: "isRedoAllowed"
        },
        CPClearHistory: {
            action: function() {
                if (confirm((0, _langJs._)("You're about to clear the current Undo/Redo history.\nThis operation cannot be undone, are you sure you want to do that?"))) that.artwork.clearHistory();
            },
            modifies: {
                document: true
            }
        },
        // Drawing tools
        CPPencil: new ToolChangeAction(ChickenPaint.T_PENCIL),
        CPPen: new ToolChangeAction(ChickenPaint.T_PEN),
        CPEraser: new ToolChangeAction(ChickenPaint.T_ERASER),
        CPSoftEraser: new ToolChangeAction(ChickenPaint.T_SOFTERASER),
        CPAirbrush: new ToolChangeAction(ChickenPaint.T_AIRBRUSH),
        CPDodge: new ToolChangeAction(ChickenPaint.T_DODGE),
        CPBurn: new ToolChangeAction(ChickenPaint.T_BURN),
        CPWater: new ToolChangeAction(ChickenPaint.T_WATER),
        CPBlur: new ToolChangeAction(ChickenPaint.T_BLUR),
        CPSmudge: new ToolChangeAction(ChickenPaint.T_SMUDGE),
        CPBlender: new ToolChangeAction(ChickenPaint.T_BLENDER),
        // Modes
        CPFloodFill: new ModeChangeAction(ChickenPaint.M_FLOODFILL),
        CPGradientFill: new ModeChangeAction(ChickenPaint.M_GRADIENTFILL),
        CPRectSelection: new ModeChangeAction(ChickenPaint.M_RECT_SELECTION),
        CPMoveTool: new ModeChangeAction(ChickenPaint.M_MOVE_TOOL),
        CPRotateCanvas: new ModeChangeAction(ChickenPaint.M_ROTATE_CANVAS),
        CPPanCanvas: new ModeChangeAction(ChickenPaint.M_PAN_CANVAS),
        CPColorPicker: new ModeChangeAction(ChickenPaint.M_COLOR_PICKER),
        // Layer transform
        CPTransform: {
            action: function() {
                const layer = that.artwork.getActiveLayer();
                if (that.artwork.transformAffineBegin() == null) that.showLayerNotification(layer, (0, _langJs._)("Whoops! All of the selected pixels are transparent!"), "layer");
                else setMode(ChickenPaint.M_TRANSFORM);
            },
            modifies: {
                mode: true
            },
            allowed: function() {
                const layer = that.artwork.getActiveLayer();
                if (!layer.visible) //非表示レイヤーを変形しようとした時にエラーメッセージを出す
                that.showLayerNotification(layer, (0, _langJs._)("Whoops! This layer is currently hidden"), "layer");
                else if (layer.alpha == 0) that.showLayerNotification(layer, (0, _langJs._)("Whoops! This layer's opacity is currently 0%"), "opacity");
                else if (that.artwork.transformAffineBegin() == null) that.showLayerNotification(layer, (0, _langJs._)("Whoops! All of the selected pixels are transparent!"), "layer");
                else return layer.getEffectiveAlpha() != 0;
            }
        },
        CPTransformAccept: {
            action: function() {
                if (curMode == ChickenPaint.M_TRANSFORM) {
                    that.artwork.transformAffineFinish();
                    setMode(preTransformMode);
                }
            },
            modifies: {
                mode: true
            }
        },
        CPTransformReject: {
            action: function() {
                if (curMode == ChickenPaint.M_TRANSFORM) {
                    that.artwork.transformAffineAbort();
                    setMode(preTransformMode);
                }
            },
            modifies: {
                document: true,
                mode: true
            }
        },
        // Stroke modes
        CPFreeHand: {
            action: function() {
                tools[curBrush].strokeMode = (0, _cpbrushInfoJsDefault.default).STROKE_MODE_FREEHAND;
                callToolListeners();
            },
            modifies: {
                tool: true
            }
        },
        CPLine: {
            action: function() {
                tools[curBrush].strokeMode = (0, _cpbrushInfoJsDefault.default).STROKE_MODE_LINE;
                callToolListeners();
            },
            modifies: {
                tool: true
            }
        },
        CPBezier: {
            action: function() {
                tools[curBrush].strokeMode = (0, _cpbrushInfoJsDefault.default).STROKE_MODE_BEZIER;
                callToolListeners();
            },
            modifies: {
                tool: true
            }
        },
        // Help dialogs
        CPAbout: {
            action: function() {
                new (0, _cpaboutDialogJsDefault.default)(uiElem).show();
            },
            modifies: {}
        },
        CPShortcuts: {
            action: function() {
                new (0, _cpshortcutsDialogJsDefault.default)(uiElem).show();
            },
            modifies: {}
        },
        CPTabletSupport: {
            action: function() {
                new (0, _cptabletDialogJsDefault.default)(uiElem).show();
            },
            modifies: {}
        },
        // Layer actions
        CPLayerDuplicate: {
            action: function() {
                that.artwork.duplicateLayer();
            },
            modifies: {
                document: true
            }
        },
        CPLayerMergeDown: {
            action: function() {
                that.artwork.mergeDown();
            },
            modifies: {
                document: true
            },
            allowed: "isMergeDownAllowed"
        },
        CPGroupMerge: {
            action: function() {
                that.artwork.mergeGroup();
            },
            modifies: {
                document: true
            },
            allowed: "isMergeGroupAllowed"
        },
        CPLayerMergeAll: {
            action: function() {
                that.artwork.mergeAllLayers();
            },
            modifies: {
                document: true
            },
            allowed: "isMergeAllLayersAllowed"
        },
        CPAddMergedLayer: {
            action: function() {
                that.artwork.mergeAllLayers(true);
            },
            modifies: {
                document: true
            },
            allowed: "isMergeAllLayersAllowed"
        },
        CPExpandLayerGroup: {
            action: function(e) {
                that.artwork.expandLayerGroup(e.group, e.expand);
            },
            modifies: {
                document: true
            }
        },
        CPFill: {
            action: function() {
                that.artwork.fill(that.getCurColor().getRgb() | 0xff000000);
            },
            modifies: {
                document: true
            },
            requiresDrawable: true
        },
        CPClear: {
            action: function() {
                that.artwork.clear();
            },
            modifies: {
                document: true
            },
            requiresDrawable: true
        },
        CPSelectAll: {
            action: function() {
                that.artwork.rectangleSelection(that.artwork.getBounds());
                canvas.repaintAll();
            },
            modifies: {
                document: true
            }
        },
        CPDeselectAll: {
            action: function() {
                that.artwork.rectangleSelection(new (0, _cprectJsDefault.default)(0, 0, 0, 0));
                canvas.repaintAll();
            },
            modifies: {
                document: true
            }
        },
        CPHFlip: {
            action: function() {
                that.artwork.hFlip();
            },
            modifies: {
                document: true
            },
            requiresDrawable: true
        },
        CPVFlip: {
            action: function() {
                that.artwork.vFlip();
            },
            modifies: {
                document: true
            },
            requiresDrawable: true
        },
        CPMNoise: {
            action: function() {
                that.artwork.monochromaticNoise();
            },
            modifies: {
                document: true
            },
            requiresDrawable: true
        },
        CPCNoise: {
            action: function() {
                that.artwork.colorNoise();
            },
            modifies: {
                document: true
            },
            allowed: "isColorNoiseAllowed"
        },
        CPFXBoxBlur: {
            action: function() {
                showBoxBlurDialog();
            },
            modifies: {
                document: true
            },
            requiresDrawable: true
        },
        CPFXInvert: {
            action: function() {
                that.artwork.invert();
            },
            modifies: {
                document: true
            },
            requiresDrawable: true
        },
        CPBrightnessToOpacity: {
            action: function() {
                that.artwork.brightnessToOpacity();
            },
            modifies: {
                document: true
            },
            requiresDrawable: true
        },
        CPCut: {
            action: function() {
                that.artwork.cutSelection();
            },
            modifies: {
                document: true
            },
            requiresDrawable: true,
            allowed: "isCutSelectionAllowed"
        },
        CPCopy: {
            action: function() {
                that.artwork.copySelection();
            },
            modifies: {
                document: true
            },
            requiresDrawable: true,
            allowed: "isCopySelectionAllowed"
        },
        CPCopyMerged: {
            action: function() {
                that.artwork.copySelectionMerged();
            },
            modifies: {
                document: true
            },
            allowed: "isCopySelectionMergedAllowed"
        },
        CPPaste: {
            action: function() {
                that.artwork.pasteClipboard();
            },
            modifies: {
                document: true
            },
            allowed: "isPasteClipboardAllowed"
        },
        CPToggleGrid: {
            action: function(e) {
                canvas.showGrid(e.selected);
            },
            modifies: {
                gui: true
            }
        },
        CPGridOptions: {
            action: function() {
                showGridOptionsDialog();
            },
            modifies: {
                gui: true
            }
        },
        CPLinearInterpolation: {
            action: function(e) {
                canvas.setInterpolation(e.selected);
            },
            modifies: {
                gui: true
            },
            isSupported: function() {
                return (0, _cppolyfillJs.isCanvasInterpolationSupported)();
            }
        },
        CPResetCanvasRotation: {
            action: function() {
                canvas.resetRotation();
            },
            modifies: {
                gui: true
            }
        },
        // Layer palette
        CPAddLayer: {
            action: function() {
                that.artwork.addLayer("layer");
            },
            modifies: {
                document: true
            }
        },
        CPAddGroup: {
            action: function() {
                that.artwork.addLayer("group");
            },
            modifies: {
                document: true
            }
        },
        CPAddLayerMask: {
            action: function() {
                that.artwork.addLayerMask();
            },
            modifies: {
                document: true
            },
            allowed: "isAddLayerMaskAllowed"
        },
        CPApplyLayerMask: {
            action: function() {
                that.artwork.applyLayerMask(true);
            },
            modifies: {
                document: true
            },
            allowed: "isApplyLayerMaskAllowed"
        },
        CPRemoveLayerMask: {
            action: function() {
                that.artwork.removeLayerMask();
            },
            modifies: {
                document: true
            },
            allowed: "isRemoveLayerMaskAllowed"
        },
        CPRemoveLayer: {
            action: function() {
                if (!that.artwork.removeLayer()) alert((0, _langJs._)("Sorry, you can't remove the last remaining layer in the drawing."));
            },
            modifies: {
                document: true
            },
            allowed: "isRemoveLayerAllowed"
        },
        CPCreateClippingMask: {
            action: function() {
                that.artwork.createClippingMask();
            },
            modifies: {
                document: true
            },
            allowed: "isCreateClippingMaskAllowed"
        },
        CPReleaseClippingMask: {
            action: function() {
                that.artwork.releaseClippingMask();
            },
            modifies: {
                document: true
            },
            allowed: "isReleaseClippingMaskAllowed"
        },
        CPRelocateLayer: {
            action: function(e) {
                that.artwork.relocateLayer(e.layer, e.toGroup, e.toIndex);
            },
            modifies: {
                document: true
            }
        },
        CPSetActiveLayer: {
            action: function(e) {
                // Enable disabled layer masks when clicked on
                if (e.mask && e.layer.mask && !e.layer.maskVisible) that.artwork.setLayerMaskVisible(e.layer, true);
                that.artwork.setActiveLayer(e.layer, e.mask);
                // Since this is a slow GUI operation, this is a good chance to get the canvas ready for drawing
                that.artwork.performIdleTasks();
            },
            modifies: {
                document: true
            }
        },
        CPToggleMaskView: {
            action: function() {
                let newView = that.artwork.toggleMaskView();
                if (newView) that.emitEvent("maskViewOpened", [
                    newView
                ]);
            },
            modifies: {
                gui: true
            }
        },
        CPSetMaskVisible: {
            action: function(e) {
                that.artwork.setLayerMaskVisible(e.layer, e.visible);
            },
            modifies: {
                layerProp: true
            }
        },
        CPSetLayerVisibility: {
            action: function(e) {
                that.artwork.setLayerVisibility(e.layer, e.visible);
            },
            modifies: {
                layerProp: true
            }
        },
        CPSetLayerName: {
            action: function(e) {
                that.artwork.setLayerName(e.layer, e.name);
            },
            modifies: {
                layerProp: true
            }
        },
        CPSetLayerBlendMode: {
            action: function(e) {
                that.artwork.setLayerBlendMode(e.blendMode);
            },
            modifies: {
                layerProp: true
            }
        },
        CPSetLayerAlpha: {
            action: function(e) {
                that.artwork.setLayerAlpha(e.alpha);
            },
            modifies: {
                layerProp: true
            }
        },
        CPSetLayerLockAlpha: {
            action: function(e) {
                that.artwork.setLayerLockAlpha(e.lock);
            },
            modifies: {
                layerProp: true
            }
        },
        // Palettes
        CPPalColor: new PaletteToggleAction("color"),
        CPPalBrush: new PaletteToggleAction("brush"),
        CPPalLayers: new PaletteToggleAction("layers"),
        CPPalStroke: new PaletteToggleAction("stroke"),
        CPPalSwatches: new PaletteToggleAction("swatches"),
        CPPalTool: new PaletteToggleAction("tool"),
        CPPalMisc: new PaletteToggleAction("misc"),
        CPPalTextures: new PaletteToggleAction("textures"),
        CPTogglePalettes: {
            action: function() {
                mainGUI.togglePalettes();
            },
            modifies: {
                gui: true
            }
        },
        CPArrangePalettes: {
            action: function() {
                mainGUI.arrangePalettes();
            },
            modifies: {
                gui: true
            }
        },
        // Saving
        CPSave: {
            action: function() {
                saveDrawing();
            },
            isSupported: function() {
                return options.allowDownload !== false;
            },
            modifies: {
                document: true
            }
        },
        CPSend: {
            action: function() {
                sendDrawing();
            },
            isSupported: function() {
                return !!options.saveUrl;
            },
            modifies: {
                document: true
            }
        },
        CPPost: {
            action: function() {
                //画面移動の関数が定義されている時はユーザーが定義した関数で画面移動
                if (typeof handleExit === "function") return handleExit();
                window.location = options.postUrl;
            },
            isSupported: function() {
                return !!(options.postUrl || typeof handleExit === "function");
            },
            modifies: {
                document: true
            }
        },
        CPContinue: {
            action: function() {},
            isSupported: function() {
                return !!options.allowMultipleSends;
            }
        },
        CPExit: {
            action: function() {
                // Exit the drawing session without posting the drawing to the forum
                window.location = options.exitUrl;
            },
            isSupported: function() {
                return !!options.exitUrl;
            },
            modifies: {}
        }
    };
    function PaletteToggleAction(palName) {
        this.palName = palName;
    }
    PaletteToggleAction.prototype.action = function(e) {
        mainGUI.showPalette(this.palName, e.selected);
    };
    PaletteToggleAction.prototype.modifies = {
        gui: true
    };
    function ToolChangeAction(toolNum) {
        this.toolNum = toolNum;
    }
    ToolChangeAction.prototype.action = function() {
        setTool(this.toolNum);
    };
    ToolChangeAction.prototype.modifies = {
        mode: true,
        tool: true
    };
    ToolChangeAction.prototype.requiresDrawable = true;
    function ModeChangeAction(modeNum) {
        this.modeNum = modeNum;
    }
    ModeChangeAction.prototype.action = function() {
        setMode(this.modeNum);
    };
    ModeChangeAction.prototype.modifies = {
        mode: true
    };
    function onEditModeChanged(newMode) {
        colorMode = newMode == (0, _cpartworkJsDefault.default).EDITING_MODE_IMAGE ? ChickenPaint.COLOR_MODE_RGB : ChickenPaint.COLOR_MODE_GREYSCALE;
        that.emitEvent("colorModeChange", [
            newMode == (0, _cpartworkJsDefault.default).EDITING_MODE_IMAGE ? "rgb" : "greyscale"
        ]);
        let newColor;
        switch(colorMode){
            case ChickenPaint.COLOR_MODE_RGB:
                newColor = curColor.clone();
                break;
            case ChickenPaint.COLOR_MODE_GREYSCALE:
                newColor = new (0, _cpcolorJsDefault.default)((0, _cpcolorJsDefault.default).greyToRGB(curMaskColor));
                break;
        }
        that.artwork.setForegroundColor(newColor.getRgb());
        that.emitEvent("colorChange", [
            newColor
        ]);
    }
    function showBoxBlurDialog() {
        if (!boxBlurDialog) boxBlurDialog = new (0, _cpboxBlurDialogJsDefault.default)(uiElem, that);
        boxBlurDialog.show();
    }
    function showGridOptionsDialog() {
        if (!gridDialog) gridDialog = new (0, _cpgridDialogJsDefault.default)(uiElem, canvas);
        gridDialog.show();
    }
    function callToolListeners() {
        that.emitEvent("toolChange", [
            curBrush,
            tools[curBrush]
        ]);
    }
    // TODO make me private
    this.callToolListeners = function() {
        callToolListeners();
    };
    function callModeListeners() {
        that.emitEvent("modeChange", [
            curMode
        ]);
    }
    /**
     * @returns {CPArtwork}
     */ this.getArtwork = function() {
        return this.artwork;
    };
    this.setCanvas = function(_canvas) {
        canvas = _canvas;
    };
    /**
     * Change the interpolation mode used by Free Transform operations
     *
     * @param {string} interpolation - Either "sharp" or "smooth"
     */ this.setTransformInterpolation = function(interpolation) {
        this.artwork.setTransformInterpolation(interpolation);
    };
    /**
     *
     * @param {CPColor} color
     */ this.setCurColor = function(color) {
        switch(colorMode){
            case ChickenPaint.COLOR_MODE_RGB:
                if (!curColor.isEqual(color)) {
                    curColor.copyFrom(color);
                    this.artwork.setForegroundColor(color.getRgb());
                    this.emitEvent("colorChange", [
                        color
                    ]);
                }
                break;
            case ChickenPaint.COLOR_MODE_GREYSCALE:
                let grey = color.getValue();
                if (curMaskColor != grey) {
                    let greyRGB = (0, _cpcolorJsDefault.default).greyToRGB(grey);
                    this.artwork.setForegroundColor(greyRGB);
                    curMaskColor = grey;
                    this.emitEvent("colorChange", [
                        new (0, _cpcolorJsDefault.default)(greyRGB)
                    ]);
                }
                break;
        }
    };
    /**
     * @returns {CPColor}
     */ this.getCurColor = function() {
        switch(colorMode){
            case ChickenPaint.COLOR_MODE_RGB:
                return curColor.clone();
            case ChickenPaint.COLOR_MODE_GREYSCALE:
                return new (0, _cpcolorJsDefault.default)((0, _cpcolorJsDefault.default).greyToRGB(curMaskColor));
        }
    };
    this.setCurGradient = function(gradient) {
        curGradient = gradient.slice(0); // Clone
        this.emitEvent("gradientChange", [
            curGradient
        ]);
    };
    this.getCurGradient = function() {
        return curGradient.slice(0); // Clone
    };
    this.setBrushSize = function(size) {
        tools[curBrush].size = Math.max(1, Math.min(200, size));
        callToolListeners();
    };
    this.getBrushSize = function() {
        return tools[curBrush].size;
    };
    this.setAlpha = function(alpha) {
        tools[curBrush].alpha = alpha;
        callToolListeners();
    };
    this.getAlpha = function() {
        return tools[curBrush].alpha;
    };
    this.getCurMode = function() {
        return curMode;
    };
    /**
     * キャンバスの中心を基準にズームします。
     * @param {number} zoom ズーム倍率
     * @param {boolean} [snap=false] true の場合、1倍/2倍/0.5倍に丸めます
     */ this.zoomOnCenter = function(zoom, snap = false) {
        canvas.zoomOnCenter(zoom, snap);
    };
    /**
     * 現在のキャンバスのズーム倍率を取得します。
     * @returns {number} 現在のズーム倍率
     */ this.getZoom = function() {
        return canvas.getZoom();
    };
    /**
     * キャンバスの回転角度を度単位で取得します。
     * - 返される値は [-180, +180] の範囲に正規化されています。
     * @returns {number} 現在の回転角度（度）
     */ this.getRotationDegrees = function() {
        return canvas.getRotationDegrees();
    };
    /**
     * キャンバスの回転角度を度単位で設定します。
     * - 内部ではラジアンに変換されてセットされます。
     * - 指定値は [-180, +180] の範囲でなくても自動的に正規化されます。
     * @param {number} degrees 設定する角度（度）
     */ this.setRotationDegrees = function(degrees) {
        canvas.setRotationDegrees(degrees);
    };
    this.isPanOrRotateMode = function() {
        return canvas.isPanOrRotateMode();
    };
    function setMode(newMode) {
        if (curMode != newMode) {
            if (newMode == ChickenPaint.M_TRANSFORM) preTransformMode = curMode;
            curMode = newMode;
            callModeListeners();
        }
    }
    this.getCurTool = function() {
        return curBrush;
    };
    function setTool(tool) {
        setMode(ChickenPaint.M_DRAW);
        curBrush = tool;
        that.artwork.setBrush(tools[tool]);
        callToolListeners();
    }
    this.getBrushInfo = function() {
        return tools[curBrush];
    };
    function saveDrawing() {
        let saver = new (0, _cpresourceSaverJsDefault.default)({
            artwork: that.getArtwork(),
            rotation: canvas.getRotation90(),
            swatches: mainGUI.getSwatches()
        });
        saver.on("savingComplete", function() {
            that.artwork.setHasUnsavedChanges(false);
        });
        saver.on("savingFailure", function() {
            alert((0, _langJs._)("Sorry, your drawing could not be saved, Please see the error message."));
        });
        saver.save();
    }
    function sendDrawing() {
        if (!that.isActionSupported("CPContinue") && !confirm((0, _langJs._)("Are you sure you want to send your drawing to the server and finish drawing now?"))) return;
        let saver = new (0, _cpresourceSaverJsDefault.default)({
            artwork: that.getArtwork(),
            rotation: canvas.getRotation90(),
            swatches: mainGUI.getSwatches(),
            url: options.saveUrl,
            post_max_size: options.post_max_size
        }), sendDialog = new (0, _cpsendDialogJsDefault.default)(that, uiElem, saver);
        saver.on("savingComplete", function() {
            that.artwork.setHasUnsavedChanges(false);
            // If we're not allowed to keep editing, we can only go straight to viewing the new post
            if (!that.isActionSupported("CPContinue") && that.isActionSupported("CPPost")) that.actionPerformed({
                action: "CPPost"
            });
        });
        saver.on("savingFailure", function() {
            alert((0, _langJs._)("Sorry, your drawing could not be saved, Please see the error message."));
        });
        // Allow the dialog to show before we begin serialization
        sendDialog.on("shown", function() {
            saver.save();
        });
        sendDialog.show();
    }
    /**
     * Not all saving actions will be supported (depending on what options we're configured with). Use this function
     * to check for support for a given action.
     *
     * @param {string} actionName
     * @returns {boolean}
     */ this.isActionSupported = function(actionName) {
        if (actions[actionName]) {
            let supportedType = typeof actions[actionName].isSupported;
            if (supportedType == "function") return actions[actionName].isSupported();
            else if (supportedType == "undefined") // If not otherwise specified, an action defaults to supported
            return true;
            else return actions[actionName].isSupported;
        }
        return false;
    };
    /**
     * Check if a given action is allowed at the moment (e.g. in the current mode and with the current layer selected).
     *
     * @param actionName
     */ this.isActionAllowed = function(actionName) {
        let action = actions[actionName];
        if (!action) return false;
        else if (typeof action.allowed == "function") return action.allowed();
        else if (typeof action.allowed == "string") return this.artwork[action.allowed]();
        else return !action.requiresDrawable || this.artwork.isActiveLayerDrawable();
    };
    this.showLayerNotification = function(layer, message, where) {
        this.emitEvent("layerNotification", [
            layer,
            message,
            where
        ]);
    };
    this.actionPerformed = function(e) {
        if (this.artwork == null || canvas == null) return; // this shouldn't happen, but just in case
        let action = actions[e.action];
        if (action) {
            if (curMode == ChickenPaint.M_TRANSFORM && (action.modifies.document || action.modifies.mode) && [
                "CPTransformAccept",
                "CPTransformReject"
            ].indexOf(e.action) == -1) {
                if (e.action == "CPUndo") actions.CPTransformReject.action();
                else if (e.action == "CPTransform") ;
                else {
                    // Prompt the user to finish their transform before starting something else
                    let dialog = new (0, _cpconfirmTransformDialogJsDefault.default)(uiElem, this);
                    /* If they decide to finish up with the transform, we can apply the original action they
                     * attempted afterwards.
                     */ // dialog.on("accept", this.actionPerformed.bind(this, e));
                    // dialog.on("reject", this.actionPerformed.bind(this, e));
                    dialog.on("accept", ()=>{
                        this.actionPerformed(e); // 元アクション
                        dialog.hide(); // モーダルを閉じる
                    });
                    dialog.on("reject", ()=>{
                        this.actionPerformed(e);
                        dialog.hide();
                    });
                    dialog.show();
                }
            } else action.action(e);
        }
    // callCPEventListeners(); TODO
    };
    this.setSmallScreenMode = function(small) {
        if (smallScreenMode !== small) {
            smallScreenMode = small;
            uiElem.classList.toggle("chickenpaint-small-screen", smallScreenMode);
            that.emitEvent("smallScreen", [
                smallScreenMode
            ]);
        }
    };
    this.getSmallScreenMode = function() {
        return smallScreenMode;
    };
    this.setFullScreen = function(newVal) {
        if (isFullScreen !== newVal) {
            isFullScreen = newVal;
            document.body.classList.toggle("chickenpaint-full-screen", isFullScreen);
            uiElem.classList.toggle("chickenpaint-full-screen", isFullScreen);
            const viewportMetaTags = document.querySelectorAll('head meta[name="viewport"]');
            const count = viewportMetaTags.length;
            if (isFullScreen && count === 0) {
                // Reset page zoom to zero if the host page didn't already set a viewport
                const metaTag = document.createElement("meta");
                metaTag.name = "viewport";
                metaTag.content = "width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,,user-scalable=no";
                document.head.appendChild(metaTag);
                // Give the browser time to adjust the viewport before we adapt to the new size
                setTimeout(()=>that.emitEvent("fullScreen", [
                        isFullScreen
                    ]), 200);
            } else that.emitEvent("fullScreen", [
                isFullScreen
            ]);
        }
    };
    this.isFullScreen = function() {
        return isFullScreen;
    };
    this.setToolbarStyle = function(styleName) {
        preferences.set("toolbarStyle", styleName);
        preferences.save(); // Eager save, so we don't lose it upon a crash
    };
    this.getToolbarStyle = function() {
        return preferences.get("toolbarStyle");
    };
    function installUnsavedWarning() {
        window.addEventListener("beforeunload", function(e) {
            if (that.artwork.getHasUnsavedChanges()) e.preventDefault();
        });
    }
    function startMainGUI(swatches, initialRotation90) {
        if (!uiElem) return;
        // Prevent double-click iOS page zoom events
        uiElem.addEventListener("dblclick", function(e) {
            e.preventDefault();
            e.stopPropagation();
        });
        that.artwork.on("editModeChanged", onEditModeChanged);
        mainGUI = new (0, _cpmainGUIJsDefault.default)(that, uiElem);
        that.emitEvent("fullScreen", [
            isFullScreen
        ]);
        that.emitEvent("smallScreen", [
            smallScreenMode
        ]);
        preferences.load();
        setTool(ChickenPaint.T_PEN);
        mainGUI.arrangePalettes();
        if (swatches) mainGUI.setSwatches(swatches);
        if (initialRotation90) mainGUI.setRotation90(initialRotation90);
        installUnsavedWarning();
        that.artwork.on("unsavedChanges", (unsavedChanges)=>{
            // Only bug users to save if they can actually save multiple times per session.
            // Otherwise they'll save when they're done with their drawing and not before:
            if (options.allowMultipleSends) that.emitEvent("unsavedChanges", [
                unsavedChanges
            ]);
        });
    }
    this.getResourcesRoot = function() {
        return options.resourcesRoot;
    };
    if (uiElem) uiElem.className += " chickenpaint chickenpaint-lang-" + (0, _langJs.currentLanguage)();
    options.resourcesRoot = options.resourcesRoot || "chickenpaint/";
    this.setSmallScreenMode(isSmallScreen());
    switch(options.fullScreenMode){
        case "force":
            this.setFullScreen(true);
            break;
        case "auto":
            this.setFullScreen(smallScreenMode);
            break;
    }
    preferences.on("toolbarStyle", (newStyle)=>this.emitEvent("toolbarStyleChange", [
            newStyle
        ]));
    if (options.loadImageUrl || options.loadChibiFileUrl) {
        let loader = new (0, _cpresourceLoaderJsDefault.default)(options);
        new (0, _cpsplashScreenJsDefault.default)(uiElem, loader, options.resourcesRoot);
        loader.on("loadingComplete", function(resources) {
            that.artwork = resources.layers || resources.flat;
            startMainGUI(resources.swatches, options.rotation);
            if (options.onLoaded) options.onLoaded(this);
        });
        loader.load();
    } else {
        if (options.artwork) this.artwork = options.artwork;
        else {
            this.artwork = new (0, _cpartworkJsDefault.default)(options.canvasWidth || 800, options.canvasHeight || 600);
            this.artwork.addBackgroundLayer();
            //起動時に透明なレイヤーを1枚追加
            this.artwork.addDefaultLayer();
        }
        startMainGUI();
        if (options.onLoaded) options.onLoaded(this);
    }
}
ChickenPaint.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
ChickenPaint.prototype.constructor = ChickenPaint;
ChickenPaint.UnsupportedBrowserException = function(message) {
    this.message = message;
};
ChickenPaint.UnsupportedBrowserException.prototype.toString = function() {
    let msg = "Sorry, your web browser does not support ChickenPaint.";
    if (this.message) msg += " " + this.message;
    else msg += " Please try a modern browser like Chrome, Safari, Firefox, or Edge.";
    return msg;
};
//
// Definition of all the modes available
//
ChickenPaint.M_DRAW = 0;
ChickenPaint.M_FLOODFILL = 1;
ChickenPaint.M_RECT_SELECTION = 2;
ChickenPaint.M_MOVE_TOOL = 3;
ChickenPaint.M_ROTATE_CANVAS = 4;
ChickenPaint.M_COLOR_PICKER = 5;
ChickenPaint.M_GRADIENTFILL = 6;
ChickenPaint.M_TRANSFORM = 7;
ChickenPaint.M_PAN_CANVAS = 8;
//
// Definition of all the standard tools available
//
ChickenPaint.T_PENCIL = 0;
ChickenPaint.T_ERASER = 1;
ChickenPaint.T_PEN = 2;
ChickenPaint.T_SOFTERASER = 3;
ChickenPaint.T_AIRBRUSH = 4;
ChickenPaint.T_DODGE = 5;
ChickenPaint.T_BURN = 6;
ChickenPaint.T_WATER = 7;
ChickenPaint.T_BLUR = 8;
ChickenPaint.T_SMUDGE = 9;
ChickenPaint.T_BLENDER = 10;
ChickenPaint.T_MAX = 11;
ChickenPaint.COLOR_MODE_RGB = 0;
ChickenPaint.COLOR_MODE_GREYSCALE = 1;
//ChickenPaintをGlobalに設定
window.ChickenPaint = ChickenPaint;

},{"./engine/CPBrushInfo.js":"b7K5Z","./engine/CPArtwork.js":"3AbfY","./engine/CPResourceLoader.js":"gCU6E","./engine/CPResourceSaver.js":"aVkzv","./gui/CPSplashScreen.js":"lo0db","./gui/CPMainGUI.js":"6MxAQ","./gui/CPAboutDialog.js":"io6EO","./gui/CPConfirmTransformDialog.js":"huRMT","./gui/CPShortcutsDialog.js":"72Eiq","./gui/CPBoxBlurDialog.js":"ikDCS","./gui/CPTabletDialog.js":"imtpp","./gui/CPGridDialog.js":"h1ox6","./gui/CPSendDialog.js":"ejkL5","./util/CPPolyfill.js":"89GR9","./util/CPColor.js":"ioCeM","./util/CPRect.js":"aDqvw","wolfy87-eventemitter":"gPUo0","./languages/lang.js":"9myCU","./gui/CPUserPreferences.js":"ba3Da","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b7K5Z":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ /**
 * @param {Object} properties - Non-default properties to set on the brush
 *
 * @property {int} alpha - The user-chosen alpha of this brush
 * @property {float} alphaScale - A scale factor applied to curAlpha before drawing
 * @property {int} curAlpha - The current alpha after pen pressure etc. has been applied
 *
 * @property {int} spacing
 * @property {int} minSpacing
 * 
 * @property {int} size - The user-chosen size of this brush
 * @property {int} curSize - The current size of the brush after pen pressure has been applied
 *
 * @property {int} brushMode - Selects the CPBrushTool that will be used to render the brush (CPBrushInfo.BRUSH_MODE_*)
 * @property {int} paintMode - Controls how paint builds up on the canvas during painting (for brush modes that don't
 * override the default paintDab() function). (CPBrushInfo.PAINT_MODE_*)
 * @property {int} strokeMode - How stroke points will be connected during drawing (CPBrushInfo.STROKE_MODE_*)
 * @property {int} tip - Kind of brush tip to be used (CPBrushInfo.TIP_*)
 *
 * @property {number} scattering
 * @property {number} curScattering
 * @property {number} angle
 * @property {number} resat - 0-1.0, controls how much of the user's selected paint color is mixed into the brush while painting.
 * @property {number} bleed - 0-1.0, controls how much of the color from the canvas is picked up by the brush.
 *
 * @property {boolean} isAA
 *
 * @constructor
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPBrushInfo);
function CPBrushInfo(properties) {
    var propName;
    // Set brush setting fields with default values, then apply the supplied 'properties' on top
    for(propName in CPBrushInfo.DEFAULTS)if (CPBrushInfo.DEFAULTS.hasOwnProperty(propName)) this[propName] = CPBrushInfo.DEFAULTS[propName];
    for(propName in properties)if (properties.hasOwnProperty(propName)) this[propName] = properties[propName];
}
// Stroke modes
CPBrushInfo.STROKE_MODE_FREEHAND = 0;
CPBrushInfo.STROKE_MODE_LINE = 1;
CPBrushInfo.STROKE_MODE_BEZIER = 2;
// Brush dab types
CPBrushInfo.TIP_ROUND_PIXEL = 0;
CPBrushInfo.TIP_ROUND_AA = 1;
CPBrushInfo.TIP_ROUND_AIRBRUSH = 2;
CPBrushInfo.TIP_SQUARE_PIXEL = 3;
CPBrushInfo.TIP_SQUARE_AA = 4;
CPBrushInfo.BRUSH_MODE_PAINT = 0;
CPBrushInfo.BRUSH_MODE_ERASE = 1;
CPBrushInfo.BRUSH_MODE_DODGE = 2;
CPBrushInfo.BRUSH_MODE_BURN = 3;
CPBrushInfo.BRUSH_MODE_WATER = 4;
CPBrushInfo.BRUSH_MODE_BLUR = 5;
CPBrushInfo.BRUSH_MODE_SMUDGE = 6;
CPBrushInfo.BRUSH_MODE_OIL = 7;
CPBrushInfo.PAINT_MODE_OPACITY = 0;
CPBrushInfo.PAINT_MODE_FLOW = 1;
CPBrushInfo.DEFAULTS = {
    isAA: false,
    minSpacing: 0,
    spacing: 0,
    pressureSize: true,
    pressureAlpha: false,
    pressureScattering: false,
    alphaScale: 1.0,
    tip: CPBrushInfo.TIP_ROUND_PIXEL,
    brushMode: CPBrushInfo.BRUSH_MODE_PAINT,
    paintMode: CPBrushInfo.PAINT_MODE_OPACITY,
    strokeMode: CPBrushInfo.STROKE_MODE_FREEHAND,
    resat: 1.0,
    bleed: 0.0,
    texture: 1.0,
    // "cur" values are current brush settings (once tablet pressure and stuff is applied)
    size: 0,
    curSize: 0,
    alpha: 0,
    curAlpha: 0,
    scattering: 0.0,
    curScattering: 0,
    squeeze: 0.0,
    curSqueeze: 0,
    angle: Math.PI,
    curAngle: 0,
    smoothing: 0.0
};
CPBrushInfo.prototype.applyPressure = function(pressure) {
    // FIXME: no variable size for smudge and oil :(
    if (this.pressureSize && this.brushMode != CPBrushInfo.BRUSH_MODE_SMUDGE && this.brushMode != CPBrushInfo.BRUSH_MODE_OIL) this.curSize = Math.max(0.1, this.size * pressure);
    else this.curSize = Math.max(0.1, this.size);
    // FIXME: what is the point of doing that?
    if (this.curSize > 16) this.curSize = Math.floor(this.curSize);
    // Don't allow brush size to exceed that supported by CPBrushManager
    this.curSize = Math.min(this.curSize, 400);
    this.curAlpha = this.pressureAlpha ? Math.floor(this.alpha * Math.min(pressure, 1.0)) : this.alpha;
    this.curSqueeze = this.squeeze;
    this.curAngle = this.angle;
    this.curScattering = this.scattering * this.curSize * (this.pressureScattering ? pressure : 1.0);
};
CPBrushInfo.prototype.clone = function() {
    return new CPBrushInfo(this);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jnFvT":[function(require,module,exports,__globalThis) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"3AbfY":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPArtwork);
var _cpimageLayerJs = require("./CPImageLayer.js");
var _cpimageLayerJsDefault = parcelHelpers.interopDefault(_cpimageLayerJs);
var _cplayerGroupJs = require("./CPLayerGroup.js");
var _cplayerGroupJsDefault = parcelHelpers.interopDefault(_cplayerGroupJs);
var _cpblendJs = require("./CPBlend.js");
var _cpblendJsDefault = parcelHelpers.interopDefault(_cpblendJs);
var _cpblendAdditionalJs = require("./CPBlendAdditional.js");
var _cpgreyBmpJs = require("./CPGreyBmp.js");
var _cpgreyBmpJsDefault = parcelHelpers.interopDefault(_cpgreyBmpJs);
var _cpblendTreeJs = require("./CPBlendTree.js");
var _cpblendTreeJsDefault = parcelHelpers.interopDefault(_cpblendTreeJs);
var _cpmaskViewJs = require("./CPMaskView.js");
var _cpmaskViewJsDefault = parcelHelpers.interopDefault(_cpmaskViewJs);
var _cpcolorBmpJs = require("./CPColorBmp.js");
var _cpcolorBmpJsDefault = parcelHelpers.interopDefault(_cpcolorBmpJs);
var _cpbrushManagerJs = require("./CPBrushManager.js");
var _cpbrushManagerJsDefault = parcelHelpers.interopDefault(_cpbrushManagerJs);
var _cpbrushInfoJs = require("./CPBrushInfo.js");
var _cpbrushInfoJsDefault = parcelHelpers.interopDefault(_cpbrushInfoJs);
var _cpundoJs = require("./CPUndo.js");
var _cpundoJsDefault = parcelHelpers.interopDefault(_cpundoJs);
var _cpclipJs = require("./CPClip.js");
var _cpclipJsDefault = parcelHelpers.interopDefault(_cpclipJs);
var _cpcolorJs = require("../util/CPColor.js");
var _cpcolorJsDefault = parcelHelpers.interopDefault(_cpcolorJs);
var _cprectJs = require("../util/CPRect.js");
var _cprectJsDefault = parcelHelpers.interopDefault(_cprectJs);
var _cprandomJs = require("../util/CPRandom.js");
var _cprandomJsDefault = parcelHelpers.interopDefault(_cprandomJs);
var _cptransformJs = require("../util/CPTransform.js");
var _cptransformJsDefault = parcelHelpers.interopDefault(_cptransformJs);
var _cppolyfillJs = require("../util/CPPolyfill.js");
var _canvasJs = require("../util/Canvas.js");
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
var _cpbrushToolJs = require("./CPBrushTool.js");
/**
 * Capitalize the first letter of the string.
 *
 * @param {string} string
 * @returns {string}
 */ function capitalizeFirst(string) {
    return string.substring(0, 1).toUpperCase() + string.substring(1);
}
function sum(a, b) {
    return a + b;
}
function arrayEquals(a, b) {
    if (a.length != b.length) return false;
    for(let i = 0; i < a.length; i++){
        if (a[i] != b[i]) return false;
    }
    return true;
}
/**
 * @param {HTMLCanvasElement} canvas
 * @returns {number}
 */ function memoryUsedByCanvas(canvas) {
    return canvas ? canvas.width * canvas.height * 4 : 0;
}
function CPArtwork(_width, _height) {
    _width = _width | 0;
    _height = _height | 0;
    const MAX_UNDO = 30, EMPTY_BACKGROUND_COLOR = 0xffffffff, EMPTY_MASK_COLOR = 0x00, EMPTY_LAYER_COLOR = 0x00ffffff, THUMBNAIL_REBUILD_DELAY_MSEC = 1000;
    const /**
         * The root of the document's hierarchy of layers and layer groups.
         *
         * @type {CPLayerGroup}
         */ layersRoot = new (0, _cplayerGroupJsDefault.default)("Root", (0, _cpblendJsDefault.default).LM_NORMAL), /**
         * Our cached strategy for merging the layers together into one for display.
         *
         * @type {CPBlendTree}
         */ blendTree = new (0, _cpblendTreeJsDefault.default)(layersRoot, _width, _height, true), /**
         * A copy of the current layer's image data that can be used for undo operations.
         *
         * @type {CPColorBmp}
         */ undoImage = new (0, _cpcolorBmpJsDefault.default)(_width, _height), /**
         * The region of the undoImage which is out of date with respect to the content of the layer, and needs updated
         * with prepareForLayerUndo().
         *
         * @type {CPRect}
         */ undoImageInvalidRegion = new (0, _cprectJsDefault.default)(0, 0, _width, _height), /**
         * A copy of the current layer's mask that can be used for undo operations.
         *
         * @type {CPGreyBmp}
         */ undoMask = new (0, _cpgreyBmpJsDefault.default)(_width, _height, 8), /**
         * The region of the undoMask which is out of date with respect to the content of the layer, and needs updated
         * with prepareForLayerUndo().
         *
         * @type {CPRect}
         */ undoMaskInvalidRegion = new (0, _cprectJsDefault.default)(0, 0, _width, _height), /**
         * We use this buffer so we can customize the accumulation of the area painted during a brush stroke.
         * (e.g. so that brushing over the same area multiple times during one stroke doesn't further increase opacity
         * there).
         *
         * Normally we use it as a 16-bit opacity channel per pixel, but some brushes use the full 32-bits per pixel
         * as ARGB.
         *
         * @type {CPGreyBmp}
         */ strokeBuffer = new (0, _cpgreyBmpJsDefault.default)(_width, _height, 32), /**
         * The area of dirty data contained by strokeBuffer that should be merged by fusionLayers()
         *
         * @type {CPRect}
         */ strokedRegion = new (0, _cprectJsDefault.default)(0, 0, 0, 0), brushManager = new (0, _cpbrushManagerJsDefault.default)(), that = this;
    let paintingModes = [], /**
         * The currently selected layer (should never be null)
         *
         * @type {(CPImageLayer|CPLayerGroup)}
         */ curLayer = layersRoot, /**
         * True if we're editing the mask of the currently selected layer, false otherwise.
         *
         * @type {boolean}
         */ maskEditingMode = false, /**
         * If the user is viewing a single mask from the document, we cache the view of that here for later invalidation.
         *
         * @type {CPMaskView}
         */ maskView = null, /**
         * Used by CPUndoPaint to keep track of the area of layer data that has been dirtied during a brush stroke
         * (or other drawing operation) and should be saved for later undo.
         */ paintUndoArea = new (0, _cprectJsDefault.default)(0, 0, 0, 0), hasUnsavedChanges = false, curSelection = new (0, _cprectJsDefault.default)(0, 0, 0, 0), /**
         * Points to a buffer which represents all the layers merged together. Since this buffer might be an actual
         * layer from the image stack, you must not write to it through here (you'll damage the image).
         *
         * @type {CPColorBmp}
         */ fusion = null, rnd = new (0, _cprandomJsDefault.default)(), previewOperation = null, /**
         * @type {?CPClip}
         */ clipboard = null, /**
         * @type {CPUndo[]}
         */ undoList = [], /**
         * @type {CPUndo[]}
         */ redoList = [], /**
         * @type {?CPBrushInfo}
         */ curBrush = null, lastX = 0.0, lastY = 0.0, lastPressure = 0.0, sampleAllLayers = false, /**
         * Set to true when the user is in the middle of a painting operation (so redrawing the thumbnail would be
         * a waste of time).
         *
         * @type {boolean}
         */ drawingInProgress = false, rebuildMaskThumbnail = new Set(), rebuildImageThumbnail = new Set(), thumbnailRebuildTimer = null, /**
         * @type {number}
         */ curColor = 0x000000, transformInterpolation = "smooth";
    /**
     * We use this routine to suppress the updating of a thumbnail while the user is still drawing.
     */ function beginPaintingInteraction() {
        drawingInProgress = true;
    }
    /**
     *
     * @param {boolean} immediateUpdateOfThumbnail
     */ function endPaintingInteraction(immediateUpdateOfThumbnail) {
        drawingInProgress = false;
        if (rebuildImageThumbnail.size > 0 || rebuildMaskThumbnail.size > 0) {
            if (immediateUpdateOfThumbnail) buildThumbnails();
            else if (!thumbnailRebuildTimer) setTimeout(buildThumbnails, THUMBNAIL_REBUILD_DELAY_MSEC);
        }
    }
    // When the selected rectangle changes
    function callListenersSelectionChange() {
        that.emitEvent("changeSelection", []);
    }
    /**
     * Get the root group which contains all the layers of the document.
     *
     * @returns {CPLayerGroup}
     */ this.getLayersRoot = function() {
        return layersRoot;
    };
    /**
     * Gets the current selection rect or a rectangle covering the whole canvas if there are no selections
     *
     * @returns {CPRect}
     */ this.getSelectionAutoSelect = function() {
        if (!curSelection.isEmpty()) return this.getSelection();
        return this.getBounds();
    };
    this.getSelection = function() {
        return curSelection.clone();
    };
    function callListenersUpdateRegion(region) {
        that.emitEvent("updateRegion", [
            region
        ]);
    }
    /**
     * Notify listeners that the structure of the document has changed (layers added or removed).
     */ function artworkStructureChanged() {
        that.emitEvent("changeStructure");
        blendTree.resetTree();
        invalidateUndoBuffers();
        callListenersUpdateRegion(that.getBounds());
    }
    /**
     * Notify listeners that the properties of the given layer has changed (opacity, blendMode, etc).
     *
     * @param {CPLayer} layer
     * @param {string} propertyName
     * @param {boolean} noVisibleEffect - If true, notify listeners that the layer has changed but don't redraw anything.
     *                                    This is useful for properties like "expanded" and "name" which don't change the
     *                                    visual appearance of the layer on the canvas.
     */ function layerPropertyChanged(layer, propertyName, noVisibleEffect) {
        that.emitEvent("changeLayer", [
            layer
        ]);
        if (!noVisibleEffect) {
            blendTree.layerPropertyChanged(layer, propertyName);
            const bounds = that.getBounds();
            callListenersUpdateRegion(bounds);
        }
    }
    function buildThumbnails() {
        for (let layer of rebuildImageThumbnail){
            layer.rebuildImageThumbnail();
            that.emitEvent("changeLayerImageThumb", [
                layer
            ]);
        }
        for (let layer of rebuildMaskThumbnail){
            layer.rebuildMaskThumbnail();
            that.emitEvent("changeLayerMaskThumb", [
                layer
            ]);
        }
        rebuildImageThumbnail.clear();
        if (thumbnailRebuildTimer) {
            clearTimeout(thumbnailRebuildTimer);
            thumbnailRebuildTimer = null;
        }
    }
    /**
     * Mark the given rectangle on the layer as needing to be re-fused (i.e. we've drawn in this region).
     * Listeners are notified about our updated canvas region.
     *
     * @param {(CPLayer|CPLayer[])} layers - Layer or layers to invalidate
     * @param {CPRect} rect - Rect to invalidate. Must have all integer co-ordinates, and the rectangle must be contained
     * within the artwork bounds.
     * @param {boolean} invalidateImage - True if drawing happened on the layer's image data
     * @param {boolean} invalidateMask - True if drawing happened on the layer's mask
     */ function invalidateLayer(layers, rect, invalidateImage, invalidateMask) {
        if (!Array.isArray(layers)) layers = [
            layers
        ];
        layers.forEach((layer)=>blendTree.invalidateLayerRect(layer, rect));
        let newThumbToRebuild = false;
        if (invalidateImage) {
            // This updated area will need to be updated in our undo buffer later
            undoImageInvalidRegion.union(rect);
            // Invalidate changed thumbnails
            for (let layer of layers)if (layer instanceof (0, _cpimageLayerJsDefault.default)) {
                rebuildImageThumbnail.add(layer);
                newThumbToRebuild = true;
            }
        }
        if (invalidateMask) {
            undoMaskInvalidRegion.union(rect);
            layers.forEach((layer)=>{
                rebuildMaskThumbnail.add(layer);
                if (maskView && maskView.layer == layer) maskView.invalidateRect(rect);
            });
            newThumbToRebuild = true;
        }
        // Update layer thumbnails
        if (newThumbToRebuild) {
            if (thumbnailRebuildTimer) {
                clearTimeout(thumbnailRebuildTimer);
                thumbnailRebuildTimer = null;
            }
            if (!drawingInProgress) thumbnailRebuildTimer = setTimeout(buildThumbnails, THUMBNAIL_REBUILD_DELAY_MSEC);
        }
        callListenersUpdateRegion(rect);
    }
    /**
     * Call when the layer's pixels have been updated as part of a paint operation, to mark it to be redrawn.
     *
     * The routine will decide if the layer's image or mask has been modified by using the global 'maskEditingMode'
     * flag. This is what you want for a typical painting operation (since it'll typically modify only the image the
     * user selected).
     *
     * @param {CPLayer} layer
     * @param {CPRect} rect
     */ function invalidateLayerPaint(layer, rect) {
        invalidateLayer(layer, rect, !maskEditingMode, maskEditingMode);
    }
    /**
     * Gets the image that the user has selected for drawing onto (a member of the currently active layer).
     * Can be null if selecting a group's "image".
     *
     * @returns {?CPColorBmp|CPGreyBmp}
     */ function getActiveImage() {
        return maskEditingMode ? curLayer.mask : curLayer.image;
    }
    this.setHasUnsavedChanges = function(value) {
        if (value != hasUnsavedChanges) {
            hasUnsavedChanges = value;
            this.emitEvent("unsavedChanges", [
                value
            ]);
        }
    };
    this.getHasUnsavedChanges = function() {
        return hasUnsavedChanges;
    };
    this.isAddLayerMaskAllowed = function() {
        return !curLayer.mask;
    };
    /**
     * Add a layer mask to the current layer.
     */ this.addLayerMask = function() {
        if (this.isAddLayerMaskAllowed()) addUndo(new CPActionAddLayerMask(curLayer));
    };
    this.isRemoveLayerMaskAllowed = function() {
        return curLayer.mask !== null;
    };
    this.removeLayerMask = function() {
        if (this.isRemoveLayerMaskAllowed()) addUndo(new CPActionRemoveLayerMask(curLayer, false));
    };
    this.isApplyLayerMaskAllowed = function() {
        return curLayer.mask !== null && curLayer instanceof (0, _cpimageLayerJsDefault.default);
    };
    this.applyLayerMask = function(apply) {
        if (this.isApplyLayerMaskAllowed()) addUndo(new CPActionRemoveLayerMask(curLayer, true));
    };
    /**
     * Add a layer of the specified type (layer, group) on top of the current layer.
     *
     * @param {string} layerType
     * @returns {CPLayer}
     */ this.addLayer = function(layerType) {
        let parentGroup, newLayerIndex, newLayer;
        if (curLayer instanceof (0, _cplayerGroupJsDefault.default) && curLayer.expanded) {
            parentGroup = curLayer;
            newLayerIndex = curLayer.layers.length;
        } else {
            parentGroup = curLayer.parent;
            newLayerIndex = parentGroup.layers.indexOf(curLayer) + 1;
        }
        switch(layerType){
            case "group":
                // Attempt to insert above the clipping group if we're trying to insert inside one
                while(parentGroup.layers[newLayerIndex] instanceof (0, _cpimageLayerJsDefault.default) && parentGroup.layers[newLayerIndex].clip)newLayerIndex++;
                newLayer = new (0, _cplayerGroupJsDefault.default)(this.getDefaultLayerName(true), (0, _cpblendJsDefault.default).LM_PASSTHROUGH);
                break;
            default:
                newLayer = new (0, _cpimageLayerJsDefault.default)(this.width, this.height, this.getDefaultLayerName(false));
                newLayer.image.clearAll(EMPTY_LAYER_COLOR);
        }
        addUndo(new CPActionAddLayer(parentGroup, newLayerIndex, newLayer));
        return newLayer;
    };
    /**
     * Effectively an internal method to be called by CPChibiFile to populate the layer stack.
     *
     * @param {CPLayerGroup} parent
     * @param {(CPImageLayer|CPLayerGroup)} layer
     */ this.addLayerObject = function(parent, layer) {
        parent.addLayer(layer);
        // Select the layer if it's the first one in the document (so we can get a valid curLayer field)
        if (parent == layersRoot && layersRoot.layers.length == 1) curLayer = layer;
        artworkStructureChanged();
    };
    /**
     * Internal method for CPChibiFile to call to wrap a group around the given number of children on
     * the top of the layer stack.
     *
     * @param {CPLayerGroup} parent
     * @param {CPLayerGroup} group
     * @param {number} numChildren - Number of layers from the parent group to wrap
     */ this.addLayerGroupObject = function(parent, group, numChildren) {
        let children = [];
        // Grab our child layers off the stack and add them to us.
        for(let i = 0; i < numChildren; i++)children.unshift(parent.layers.pop());
        children.forEach((child)=>group.addLayer(child));
        this.addLayerObject(parent, group);
    };
    this.isRemoveLayerAllowed = function() {
        if (curLayer instanceof (0, _cpimageLayerJsDefault.default)) return layersRoot.getLinearizedLayerList(false).some((layer)=>layer instanceof (0, _cpimageLayerJsDefault.default) && layer != curLayer);
        if (curLayer instanceof (0, _cplayerGroupJsDefault.default)) return layersRoot.getLinearizedLayerList(false).some((layer)=>layer instanceof (0, _cpimageLayerJsDefault.default) && !layer.hasAncestor(curLayer));
        return false;
    };
    /**
     * Remove the currently selected layer.
     *
     * @return {boolean} True if the layer was removed, or false when removal failed because there would be no image
     * layers left in the document after deletion.
     */ this.removeLayer = function() {
        if (this.isRemoveLayerAllowed()) {
            addUndo(new CPActionRemoveLayer(curLayer));
            return true;
        }
        return false;
    };
    this.duplicateLayer = function() {
        addUndo(new CPActionDuplicateLayer(curLayer));
    };
    this.isMergeDownAllowed = function() {
        let layerIndex = curLayer.parent.indexOf(curLayer);
        return layerIndex > 0 && curLayer instanceof (0, _cpimageLayerJsDefault.default) && curLayer.parent.layers[layerIndex - 1] instanceof (0, _cpimageLayerJsDefault.default);
    };
    this.mergeDown = function() {
        if (this.isMergeDownAllowed()) addUndo(new CPActionMergeDownLayer(curLayer));
    };
    this.isMergeGroupAllowed = function() {
        return curLayer instanceof (0, _cplayerGroupJsDefault.default) && curLayer.getEffectiveAlpha() > 0;
    };
    this.mergeGroup = function() {
        if (this.isMergeGroupAllowed()) addUndo(new CPActionMergeGroup(curLayer));
    };
    this.isMergeAllLayersAllowed = function() {
        return layersRoot.getLinearizedLayerList(false).length > 1;
    };
    this.mergeAllLayers = function(addFlattenedLayer = false) {
        if (this.isMergeAllLayersAllowed()) addUndo(new CPActionMergeAllLayers(addFlattenedLayer));
    };
    /**
     * Move a layer in the stack from one index to another.
     *
     * @param {(CPImageLayer|CPLayerGroup)} layer
     * @param {CPLayerGroup} toGroup
     * @param {number} toIndex
     */ this.relocateLayer = function(layer, toGroup, toIndex) {
        if (layer && toGroup && layer != toGroup && !toGroup.hasAncestor(layer)) addUndo(new CPActionRelocateLayer(layer, toGroup, toIndex));
    };
    /**
     *
     * @param {CPLayer} layer
     * @param {boolean} visible
     */ this.setLayerVisibility = function(layer, visible) {
        let layers = [];
        if (!layer.ancestorsAreVisible()) {
            // Assume the user wants to make this layer visible by revealing its hidden ancestors (as well as the layer)
            for(let node = layer; node != null; node = node.parent)if (!node.visible) layers.push(node);
            addUndo(new CPActionChangeLayerVisible(layers, true));
        } else if (layer.visible != visible) addUndo(new CPActionChangeLayerVisible(layer, visible));
    };
    /**
     * Expand or collapse the given layer group.
     *
     * @param {CPLayerGroup} group
     * @param {boolean} expand - True to expand, false to collapse
     */ this.expandLayerGroup = function(group, expand) {
        if (group.expanded != expand) {
            group.expanded = expand;
            if (!expand && curLayer.hasAncestor(group)) // Don't allow the selected layer to get hidden in the group
            this.setActiveLayer(group, false);
            layerPropertyChanged(group, "expanded", true);
        }
    };
    this.setLayerAlpha = function(alpha) {
        if (curLayer.getAlpha() != alpha) addUndo(new CPActionChangeLayerAlpha(curLayer, alpha));
    };
    this.setLayerMaskLinked = function(linked) {
        if (curLayer.maskLinked != linked) addUndo(new CPActionChangeLayerMaskLinked(curLayer, linked));
    };
    /**
     *
     * @param {CPLayer} layer
     * @param {boolean} visible
     */ this.setLayerMaskVisible = function(layer, visible) {
        if (layer.maskVisible != visible) addUndo(new CPActionChangeLayerMaskVisible(layer, visible));
    };
    this.setLayerBlendMode = function(blendMode) {
        if (curLayer.getBlendMode() != blendMode && (blendMode != (0, _cpblendJsDefault.default).LM_PASSTHROUGH || curLayer instanceof (0, _cplayerGroupJsDefault.default))) addUndo(new CPActionChangeLayerMode(curLayer, blendMode));
    };
    /**
     * @param {CPLayer} layer
     * @param {string} name
     */ this.setLayerName = function(layer, name) {
        if (layer.getName() != name) addUndo(new CPActionChangeLayerName(layer, name));
    };
    /**
     * Paint a dab of paint to the canvas using the current brush.
     *
     * @param {number} x - Position of brush tip
     * @param {number} y - Position of brush tip
     * @param {number} pressure - Pen pressure (tablets).
     */ this.paintDab = function(x, y, pressure) {
        curBrush.applyPressure(pressure);
        if (curBrush.scattering > 0.0) {
            x += rnd.nextGaussian() * curBrush.curScattering / 4.0;
            y += rnd.nextGaussian() * curBrush.curScattering / 4.0;
        }
        let brushTool = paintingModes[curBrush.brushMode], dab = brushManager.getDab(x, y, curBrush), brushRect = new (0, _cprectJsDefault.default)(0, 0, dab.width, dab.height), imageRect = new (0, _cprectJsDefault.default)(0, 0, dab.width, dab.height);
        imageRect.translate(dab.x, dab.y);
        that.getBounds().clipSourceDest(brushRect, imageRect);
        if (imageRect.isEmpty()) // drawing entirely outside the canvas
        return;
        paintUndoArea.union(imageRect);
        let destImage = maskEditingMode ? curLayer.mask : curLayer.image, sampleImage = sampleAllLayers && !maskEditingMode ? fusion : destImage;
        /* The brush will either paint itself directly to the image, or paint itself to the strokeBuffer and update
         * the strokedRegion (which will be merged to the image later by mergeStrokeBuffer(), perhaps in response
         * to a call to fusionLayers())
         */ brushTool.paintDab(destImage, imageRect, sampleImage, curBrush, brushRect, dab, curColor);
        if (!maskEditingMode && brushTool.noMergePhase && curLayer.getLockAlpha()) // This tool painted to the image during paintDab(), so we have to apply image alpha here instead of during merge
        restoreImageAlpha(destImage, imageRect);
        if (brushTool.wantsOutputAsInput) {
            mergeStrokeBuffer();
            if (sampleAllLayers && !maskEditingMode) that.fusionLayers();
        }
        invalidateLayerPaint(curLayer, imageRect);
    };
    this.getDefaultLayerName = function(isGroup) {
        let prefix = isGroup ? "Group " : "Layer ", nameRegex = isGroup ? /^Group [0-9]+$/ : /^Layer [0-9]+$/, highestLayerNb = 0, layers = layersRoot.getLinearizedLayerList(false);
        for(let i = 0; i < layers.length; i++){
            let layer = layers[i];
            if (nameRegex.test(layer.name)) highestLayerNb = Math.max(highestLayerNb, parseInt(layer.name.substring(prefix.length), 10));
        }
        return prefix + (highestLayerNb + 1);
    };
    /**
     * Restore the alpha channel of the given image from the undoImage (i.e. restore it to what it was before the
     * current drawing operation started).
     *
     * @param {CPColorBmp} image
     * @param {CPRect} rect
     */ function restoreImageAlpha(image, rect) {
        image.copyAlphaFrom(undoImage, rect);
    }
    /**
     * Merge the brushstroke buffer from the current drawing operation to the active layer.
     */ function mergeStrokeBuffer() {
        if (!strokedRegion.isEmpty()) {
            if (maskEditingMode) {
                let destMask = curLayer.mask;
                // Can't erase on masks, so just paint black instead
                if (curBrush.brushMode == (0, _cpbrushInfoJsDefault.default).BRUSH_MODE_ERASE) paintingModes[(0, _cpbrushInfoJsDefault.default).BRUSH_MODE_PAINT].mergeOntoMask(destMask, undoMask, 0xff000000);
                else paintingModes[curBrush.brushMode].mergeOntoMask(destMask, undoMask, curColor & 0xff);
            } else {
                let destImage = curLayer.image, lockAlpha = curLayer.getLockAlpha();
                if (curBrush.brushMode == (0, _cpbrushInfoJsDefault.default).BRUSH_MODE_ERASE && lockAlpha) // We're erasing with locked alpha, so the only sensible thing to do is paint white...
                // FIXME: it would be nice to be able to set the paper color
                paintingModes[(0, _cpbrushInfoJsDefault.default).BRUSH_MODE_PAINT].mergeOntoImage(destImage, undoImage, EMPTY_LAYER_COLOR);
                else paintingModes[curBrush.brushMode].mergeOntoImage(destImage, undoImage, curColor);
                if (lockAlpha) restoreImageAlpha(destImage, strokedRegion);
            }
            strokedRegion.makeEmpty();
        }
    }
    function prepareForFusion() {
        // The current brush renders out its buffers to the layer stack for us
        mergeStrokeBuffer();
        blendTree.buildTree();
    }
    this.addBackgroundLayer = function() {
        //背景レイヤーを追加
        let layer = new (0, _cpimageLayerJsDefault.default)(that.width, that.height, this.getDefaultLayerName(false));
        layer.image.clearAll(EMPTY_BACKGROUND_COLOR);
        this.addLayerObject(this.getLayersRoot(), layer);
    };
    this.addDefaultLayer = function() {
        //起動時に透明なレイヤーを1枚追加
        let layer = new (0, _cpimageLayerJsDefault.default)(that.width, that.height, this.getDefaultLayerName(false));
        layer.image.clearAll(EMPTY_LAYER_COLOR);
        this.addLayerObject(this.getLayersRoot(), layer);
        //アクティブレイヤーにセット
        this.setActiveLayer(layer, false);
    };
    /**
     * Merge together the visible layers and return the resulting image for display to the screen.
     *
     * The image is cached, so repeat calls are cheap.
     *
     * @returns {CPColorBmp}
     */ this.fusionLayers = function() {
        prepareForFusion();
        fusion = blendTree.blendTree().image;
        return fusion;
    };
    /**
     * Old ChibiPaint used a blending operator with a slightly different formula than us for blending onto opaque
     * canvases. We can fix this in two ways:
     *
     * default - If it looks like the original layer would have used the old Opaque Multiply algorithm, keep using that
     *           one, otherwise upgrade it to the new Multiply2 algorithm.
     *
     * bake - modify the pixels of Multiply layers in the document in order to bring their blended appearance to match what
     *        the old multiply algorithm would have produced.
     *
     *        The resulting artwork is not really editable, because the baked-in corrections will only look correct when
     *        the layers underneath the multiply layers are all the same as they originally were. Any change to layer
     *        opacities will also ruin the result.
     *
     * Either way, this must not be called on new (ChickenPaint 0.10 format) artworks.
     *
     * @param {?string} mode
     */ this.upgradeMultiplyLayers = function(mode) {
        let layers = this.getLayersRoot().getLinearizedLayerList(false, []), lastMultiplyLayerIndex = -1;
        for(let i = 0; i < layers.length; i++){
            let layer = layers[i];
            if (!(layer instanceof (0, _cpimageLayerJsDefault.default)) || layer.mask || layer.blendMode > (0, _cpblendJsDefault.default).LM_LAST_CHIBIPAINT) throw new Error("Bad layer type during multiply upgrade");
            if (layer.blendMode === (0, _cpblendJsDefault.default).LM_MULTIPLY) lastMultiplyLayerIndex = i;
        }
        if (lastMultiplyLayerIndex !== -1) {
            let fusion = new (0, _cpcolorBmpJsDefault.default)(this.width, this.height), hasTransparency = true, first = true, blendRect = this.getBounds();
            fusion.clearAll(blendRect, 0x00ffffff); // Transparent white
            for(let i = 0; i <= lastMultiplyLayerIndex; i++){
                let layer = layers[i];
                if (!first) hasTransparency = hasTransparency && fusion.hasAlphaInRect(blendRect);
                if (layer.blendMode === (0, _cpblendJsDefault.default).LM_MULTIPLY) switch(mode){
                    case "bake":
                        /* Don't make changes to hidden multiply layers, we won't support editing the resulting
                             * artwork to reveal these layers later anyway.
                             */ if (!hasTransparency && layer.getEffectiveAlpha() > 0) {
                            // The original drawing probably used the old Opaque blend mode, so let's fix it up
                            if (layer.alpha === 100) (0, _cpblendJsDefault.default).upgradeMultiplyOfOpaqueLayer(fusion, layer.image, 100, blendRect);
                            else (0, _cpblendJsDefault.default).upgradeMultiplyOfTransparentLayer(fusion, layer.image, layer.alpha, blendRect);
                            layer.setBlendMode((0, _cpblendJsDefault.default).LM_MULTIPLY2);
                        }
                        break;
                    default:
                        if (hasTransparency) /* The original drawing probably wouldn't have used the old Opaque blend mode for this layer,
                                 * so we can upgrade it.
                                 */ layer.setBlendMode((0, _cpblendJsDefault.default).LM_MULTIPLY2);
                }
                if (layer.getEffectiveAlpha() > 0) {
                    first = false;
                    (0, _cpblendJsDefault.default).fuseImageOntoImage(fusion, hasTransparency, layer.image, layer.alpha, layer.blendMode, blendRect, null);
                }
            }
        }
    };
    this.isCreateClippingMaskAllowed = function() {
        let layerIndex = curLayer.parent.indexOf(curLayer), underLayer = curLayer.parent.layers[layerIndex - 1];
        return curLayer instanceof (0, _cpimageLayerJsDefault.default) && !curLayer.clip && underLayer instanceof (0, _cpimageLayerJsDefault.default);
    };
    /**
     * Clip this layer to the one below, if it is not already clipped.
     */ this.createClippingMask = function() {
        if (this.isCreateClippingMaskAllowed()) addUndo(new CPActionChangeLayerClip(curLayer, true));
    };
    this.isReleaseClippingMaskAllowed = function() {
        return curLayer instanceof (0, _cpimageLayerJsDefault.default) && curLayer.clip;
    };
    /**
     * Clip this layer to the one below, if it is not already clipped.
     */ this.releaseClippingMask = function() {
        if (this.isReleaseClippingMaskAllowed()) addUndo(new CPActionChangeLayerClip(curLayer, false));
    };
    /**
     * Change the currently active layer. The layer may not be set to null.
     *
     * @param {(CPLayer|CPImageLayer|CPLayerGroup)} newLayer
     * @param {boolean} selectMask - True to select the layer's mask for editing
     */ this.setActiveLayer = function(newLayer, selectMask) {
        if (newLayer) {
            // Ensure the mask really exists if we ask to select it
            selectMask = newLayer.mask && selectMask;
            let editingModeChanged = selectMask != maskEditingMode;
            if (curLayer != newLayer || editingModeChanged) {
                let oldLayer = curLayer;
                curLayer = newLayer;
                maskEditingMode = selectMask;
                invalidateUndoBuffers();
                this.emitEvent("changeActiveLayer", [
                    oldLayer,
                    newLayer,
                    maskEditingMode
                ]);
                if (editingModeChanged) this.emitEvent("editModeChanged", [
                    maskEditingMode ? CPArtwork.EDITING_MODE_MASK : CPArtwork.EDITING_MODE_IMAGE
                ]);
                if (maskView && maskView.layer == oldLayer) {
                    if (selectMask) maskView.setLayer(newLayer);
                    else this.closeMaskView();
                }
            }
        }
    };
    this.closeMaskView = function() {
        maskView.close();
        maskView = null;
    };
    this.toggleMaskView = function() {
        if (maskView == null || !maskView.isOpen()) {
            if (curLayer.mask) maskView = new (0, _cpmaskViewJsDefault.default)(curLayer, mergeStrokeBuffer);
            else maskView = null;
        } else this.closeMaskView();
        return maskView;
    };
    /**
     * Select the topmost visible layer, or the topmost layer if none are visible.
     */ this.selectTopmostVisibleLayer = function() {
        let list = layersRoot.getLinearizedLayerList(false);
        // Find a visible, drawable layer
        for(let i = list.length - 1; i >= 0; i--)if (list[i] instanceof (0, _cpimageLayerJsDefault.default) && list[i].getEffectiveAlpha() > 0) {
            this.setActiveLayer(list[i], false);
            return;
        }
        // None? Okay, how about just a drawable layer
        for(let i = list.length - 1; i >= 0; i--)if (list[i] instanceof (0, _cpimageLayerJsDefault.default)) {
            this.setActiveLayer(list[i], false);
            return;
        }
        // Trying to be difficult, huh?
        this.setActiveLayer(list[list.length - 1], false);
    };
    /**
     * Get the currently active layer (the layer that drawing operations will be applied to))
     *
     * @returns {CPLayer}
     */ this.getActiveLayer = function() {
        return curLayer;
    };
    this.isEditingMask = function() {
        return maskEditingMode;
    };
    this.isActiveLayerDrawable = function() {
        return maskEditingMode && curLayer.mask || !maskEditingMode && curLayer instanceof (0, _cpimageLayerJsDefault.default);
    };
    /**
     *
     * @returns {number}
     */ this.getUndoMemoryUsed = function() {
        let total = 0;
        for (let redo of redoList)total += redo.getMemoryUsed(true, null);
        for (let undo of undoList)total += undo.getMemoryUsed(false, null);
        return total;
    };
    this.isUndoAllowed = function() {
        return undoList.length > 0;
    };
    this.isRedoAllowed = function() {
        return redoList.length > 0;
    };
    //
    // Undo / Redo
    //
    this.undo = function() {
        if (!this.isUndoAllowed()) return;
        this.setHasUnsavedChanges(true);
        let undo = undoList.pop();
        undo.undo();
        redoList.push(undo);
    };
    this.redo = function() {
        if (!this.isRedoAllowed()) return;
        this.setHasUnsavedChanges(true);
        let redo = redoList.pop();
        redo.redo();
        undoList.push(redo);
    };
    function prepareForLayerImageUndo() {
        if (curLayer instanceof (0, _cpimageLayerJsDefault.default) && !undoImageInvalidRegion.isEmpty()) {
            // console.log("Copying " + undoImageInvalidRegion + " to the image undo buffer");
            undoImage.copyBitmapRect(curLayer.image, undoImageInvalidRegion.left, undoImageInvalidRegion.top, undoImageInvalidRegion);
            undoImageInvalidRegion.makeEmpty();
        }
    }
    function prepareForLayerMaskUndo() {
        if (curLayer.mask && !undoMaskInvalidRegion.isEmpty()) {
            // console.log("Copying " + undoMaskInvalidRegion + " to the mask undo buffer");
            undoMask.copyBitmapRect(curLayer.mask, undoMaskInvalidRegion.left, undoMaskInvalidRegion.top, undoMaskInvalidRegion);
            undoMaskInvalidRegion.makeEmpty();
        }
    }
    /**
     * Call before making a paint operation on the current layer, in order to store the state of the layer for
     * later undo with CPUndoPaint.
     */ function prepareForLayerPaintUndo() {
        if (maskEditingMode) prepareForLayerMaskUndo();
        else prepareForLayerImageUndo();
    }
    /**
     * Call when the undo buffer has become completely worthless (e.g. after the active layer index changes, the undo
     * buffer won't contain any data from the new layer to begin with).
     */ function invalidateUndoBuffers() {
        let bounds = that.getBounds();
        undoImageInvalidRegion.set(bounds);
        undoMaskInvalidRegion.set(bounds);
    }
    /**
     * The result of some of our operations aren't needed until later, so we can defer them until the user is idle.
     *
     * You may call this routine at any time (or never, if you like) as a hint that the user is idle and we should
     * try to perform pending operations before we will need to block on their results.
     */ this.performIdleTasks = function() {
        prepareForLayerPaintUndo();
        prepareForFusion();
    };
    /**
     *
     * @param {CPUndo} undo
     */ function addUndo(undo) {
        that.setHasUnsavedChanges(true);
        if (redoList.length > 0) redoList = [];
        if (undoList.length === 0 || !undoList[undoList.length - 1].merge(undo)) {
            if (undoList.length >= MAX_UNDO) undoList.shift();
            that.compactUndo();
            undoList.push(undo);
        } else if (undoList[undoList.length - 1].noChange()) // Two merged changes can mean no change at all
        // don't leave a useless undo in the list
        undoList.pop();
    }
    /**
     * Compress the undo action at the top of the stack to save space. Intended for internal calls only.
     */ this.compactUndo = function() {
        if (undoList.length > 0) undoList[undoList.length - 1].compact();
    };
    this.clearHistory = function() {
        undoList = [];
        redoList = [];
    };
    /**
     * Sample the color at the given coordinates.
     *
     * @param {number} x
     * @param {number} y
     * @returns {number}
     */ this.colorPicker = function(x, y) {
        if (maskEditingMode && curLayer.mask) return (0, _cpcolorJsDefault.default).greyToRGB(curLayer.mask.getPixel(~~x, ~~y));
        else return fusion.getPixel(~~x, ~~y) & 0xffffff;
    };
    this.setSelection = function(rect) {
        curSelection.set(rect);
        // Ensure we never have fractional coordinates in our selections:
        curSelection.roundNearest();
        curSelection.clipTo(this.getBounds());
    };
    this.emptySelection = function() {
        curSelection.makeEmpty();
    };
    /**
     * Flood fill the current layer using the current color at the given coordinates.
     *
     * @param {number} x
     * @param {number} y
     */ this.floodFill = function(x, y) {
        let target = getActiveImage();
        if (target) {
            prepareForLayerPaintUndo();
            paintUndoArea = this.getBounds();
            target.floodFill(~~x, ~~y, curColor | 0xff000000);
            addUndo(new CPUndoPaint());
            invalidateLayerPaint(curLayer, this.getBounds());
        }
    };
    this.gradientFill = function(fromX, fromY, toX, toY, gradientPoints) {
        let r = this.getSelectionAutoSelect(), target = getActiveImage();
        if (target) {
            prepareForLayerPaintUndo();
            paintUndoArea = r.clone();
            target.gradient(r, fromX, fromY, toX, toY, gradientPoints, false);
            if (this.getLayerLockAlpha() && target instanceof (0, _cpcolorBmpJsDefault.default)) restoreImageAlpha(target, r);
            addUndo(new CPUndoPaint());
            invalidateLayerPaint(curLayer, r);
        }
    };
    /**
     * Replace the pixels in the selection rectangle with the specified color.
     *
     * @param {number} color - ARGB color to fill with
     */ this.fill = function(color) {
        let r = this.getSelectionAutoSelect(), target = getActiveImage();
        if (target) {
            prepareForLayerPaintUndo();
            paintUndoArea = r.clone();
            target.clearRect(r, color);
            addUndo(new CPUndoPaint());
            invalidateLayerPaint(curLayer, r);
        }
    };
    this.clear = function() {
        if (maskEditingMode) this.fill(EMPTY_MASK_COLOR);
        else this.fill(EMPTY_LAYER_COLOR);
    };
    /**
     *
     * @param {boolean} horizontal
     */ this.flip = function(horizontal) {
        let rect = this.getSelection(), flipWholeLayer = rect.isEmpty(), transformBoth = flipWholeLayer && curLayer instanceof (0, _cpimageLayerJsDefault.default) && curLayer.mask && curLayer.maskLinked, transformImage = (!maskEditingMode || transformBoth) && curLayer instanceof (0, _cpimageLayerJsDefault.default), transformMask = (maskEditingMode || transformBoth) && curLayer.mask, routine = horizontal ? "copyRegionHFlip" : "copyRegionVFlip";
        if (!transformImage && !transformMask) return;
        if (flipWholeLayer) rect = this.getBounds();
        paintUndoArea = rect.clone();
        if (transformImage) {
            prepareForLayerImageUndo();
            curLayer.image[routine](rect, undoImage);
        }
        if (transformMask) {
            prepareForLayerMaskUndo();
            curLayer.mask[routine](rect, undoMask);
        }
        addUndo(new CPUndoPaint(transformImage, transformMask));
        invalidateLayer(curLayer, rect, transformImage, transformMask);
    };
    this.hFlip = function() {
        this.flip(true);
    };
    this.vFlip = function() {
        this.flip(false);
    };
    this.monochromaticNoise = function() {
        let r = this.getSelectionAutoSelect(), target = getActiveImage();
        if (target) {
            prepareForLayerPaintUndo();
            paintUndoArea = r.clone();
            target.fillWithNoise(r);
            addUndo(new CPUndoPaint());
            invalidateLayerPaint(curLayer, r);
        }
    };
    this.isColorNoiseAllowed = function() {
        return !this.isEditingMask() && this.isActiveLayerDrawable();
    };
    /**
     * We can only fill layer images with color noise (not masks)
     */ this.colorNoise = function() {
        if (this.isColorNoiseAllowed()) {
            let r = this.getSelectionAutoSelect();
            prepareForLayerPaintUndo();
            paintUndoArea = r.clone();
            curLayer.image.fillWithColorNoise(r);
            addUndo(new CPUndoPaint(true, false));
            invalidateLayer(curLayer, r, true, false);
        }
    };
    this.invert = function() {
        let r = this.getSelectionAutoSelect(), target = getActiveImage();
        if (target) {
            prepareForLayerPaintUndo();
            paintUndoArea = r.clone();
            target.invert(r);
            addUndo(new CPUndoPaint());
            invalidateLayerPaint(curLayer, r);
        }
    };
    this.brightnessToOpacity = function() {
        let r = this.getSelectionAutoSelect(), target = getActiveImage();
        if (target) {
            prepareForLayerPaintUndo();
            paintUndoArea = r.clone();
            target.brightnessToOpacity(r);
            addUndo(new CPUndoPaint());
            invalidateLayerPaint(curLayer, r);
        }
    };
    /**
     *
     * @param {number} radiusX
     * @param {number} radiusY
     * @param {number} iterations
     */ this.boxBlur = function(radiusX, radiusY, iterations) {
        let r = this.getSelectionAutoSelect(), target = getActiveImage();
        if (target) {
            prepareForLayerPaintUndo();
            paintUndoArea = r.clone();
            for(let i = 0; i < iterations; i++)target.boxBlur(r, radiusX, radiusY);
            addUndo(new CPUndoPaint());
            invalidateLayerPaint(curLayer, r);
        }
    };
    this.rectangleSelection = function(r) {
        let newSelection = r.clone();
        newSelection.clipTo(this.getBounds());
        addUndo(new CPUndoRectangleSelection(this.getSelection(), newSelection));
        this.setSelection(newSelection);
    };
    /**
     * Get the most recently completed operation from the undo list, or null if the undo list is empty.
     *
     * @returns {*}
     */ function getActiveOperation() {
        if (undoList.length > 0) return undoList[undoList.length - 1];
        return null;
    }
    /**
     * Move the currently selected layer by the given offset.
     *
     * @param {number} offsetX
     * @param {number} offsetY
     * @param {boolean} copy - Make a copy of the selection instead of moving it.
     */ this.move = function(offsetX, offsetY, copy) {
        /*
         * Add rounding to ensure we haven't been given float coordinates (that would cause horrible flow-on effects like
         * the boundary of the undo rectangle having float coordinates)
         */ offsetX |= 0;
        offsetY |= 0;
        if (offsetX == 0 && offsetY == 0) return;
        let activeOp = getActiveOperation();
        // If we've changed layers since our last move, we want to move the new layer, not the old one, so can't amend
        if (!copy && activeOp instanceof CPActionMoveSelection && activeOp.layer == this.getActiveLayer()) {
            activeOp.amend(offsetX, offsetY);
            redoList = [];
            this.setHasUnsavedChanges(true);
        } else {
            let action = new CPActionMoveSelection(offsetX, offsetY, copy);
            addUndo(action);
            action.redo();
        }
    };
    /**
     * Change the interpolation mode used by Free Transform operations
     *
     * @param {string} interpolation - Either "sharp" or "smooth"
     */ this.setTransformInterpolation = function(interpolation) {
        transformInterpolation = interpolation;
        if (previewOperation instanceof CPActionAffineTransformSelection) previewOperation.setInterpolation(interpolation);
    };
    /**
     * If the current operation is an affine transform, roll it back and remove it from the undo history.
     */ this.transformAffineAbort = function() {
        if (previewOperation instanceof CPActionAffineTransformSelection) {
            previewOperation.undo();
            previewOperation = null;
            endPaintingInteraction(true);
        }
    };
    /**
     * Begins transforming the current selection/layer, and returns the initial source rectangle and initial transform.
     * You can update the transform by calling transformAffineAmend().
     *
     * You must call transformAffineFinish() or transformAffineAbort() to finish the transformation.
     *
     * Returns null if the current selection/layer doesn't contain any non-transparent pixels, and doesn't start
     * transforming.
     */ this.transformAffineBegin = function() {
        // Are we already transforming? Continue that instead
        if (previewOperation instanceof CPActionAffineTransformSelection) return {
            transform: previewOperation.getTransform(),
            rect: previewOperation.getInitialTransformRect(),
            selection: previewOperation.getInitialSelectionRect()
        };
        let initialTransform = new (0, _cptransformJsDefault.default)(), operation;
        /* If we introduce other previewOperations, we might want to check we aren't overwriting them here...
         * Though probably ChickenPaint's global exclusive mode will enforce this for us.
         */ operation = new CPActionAffineTransformSelection(initialTransform, transformInterpolation);
        if (operation.getInitialTransformRect().isEmpty()) // Tried to transform a selection which contained no pixels
        return null;
        previewOperation = operation;
        // No need for an initial .redo() since the transform is the identity
        beginPaintingInteraction();
        return {
            transform: initialTransform,
            rect: operation.getInitialTransformRect(),
            selection: operation.getInitialSelectionRect()
        };
    };
    /**
     * Finish and save the transform that is currently in progress.
     */ this.transformAffineFinish = function() {
        if (previewOperation instanceof CPActionAffineTransformSelection) {
            addUndo(previewOperation);
            previewOperation = null;
            endPaintingInteraction(true);
        }
    };
    /**
     * Transform the currently selected layer data using the given AffineTransform.
     *
     * @param {CPTransform} affineTransform
     */ this.transformAffineAmend = function(affineTransform) {
        if (previewOperation instanceof CPActionAffineTransformSelection) previewOperation.amend(affineTransform);
    };
    // Copy/Paste functions
    this.isCutSelectionAllowed = function() {
        return !this.getSelection().isEmpty() && getActiveImage() !== null;
    };
    this.isCopySelectionAllowed = this.isCutSelectionAllowed;
    this.cutSelection = function() {
        if (this.isCutSelectionAllowed()) addUndo(new CPActionCut(curLayer, maskEditingMode, this.getSelection()));
    };
    this.copySelection = function() {
        if (this.isCopySelectionAllowed()) {
            let selection = that.getSelection(), image = getActiveImage();
            clipboard = new (0, _cpclipJsDefault.default)(image.cloneRect(selection), selection.left, selection.top);
        }
    };
    this.isCopySelectionMergedAllowed = function() {
        return !this.getSelection().isEmpty();
    };
    this.copySelectionMerged = function() {
        if (this.isCopySelectionMergedAllowed()) {
            let selection = that.getSelection();
            clipboard = new (0, _cpclipJsDefault.default)(this.fusionLayers().cloneRect(selection), selection.left, selection.top);
        }
    };
    this.isPasteClipboardAllowed = function() {
        return !this.isClipboardEmpty();
    };
    this.pasteClipboard = function() {
        if (this.isPasteClipboardAllowed()) addUndo(new CPActionPaste(clipboard));
    };
    /**
     *
     * @returns {CPClip}
     */ this.getClipboard = function() {
        return clipboard;
    };
    /*
     * @param {CPClip} clipboard
     */ this.setClipboard = function(newClipboard) {
        clipboard = newClipboard;
    };
    this.isClipboardEmpty = function() {
        return clipboard == null;
    };
    this.setSampleAllLayers = function(b) {
        sampleAllLayers = b;
    };
    this.getLayerLockAlpha = function() {
        return this.getActiveLayer().getLockAlpha();
    };
    this.setLayerLockAlpha = function(lock) {
        if (curLayer.getLockAlpha() != lock) addUndo(new CPActionChangeLayerLockAlpha(curLayer, lock));
    };
    /**
     * @param {number} color - RGB color
     */ this.setForegroundColor = function(color) {
        curColor = color;
    };
    this.setBrush = function(brush) {
        curBrush = brush;
    };
    this.setBrushTexture = function(texture) {
        brushManager.setTexture(texture);
    };
    /**
     * Start a painting operation.
     *
     * @param {float} x
     * @param {float} y
     * @param {float} pressure
     * @returns {boolean} - true if the painting began successfully, false otherwise (don't call continueStroke or endStroke!)
     */ this.beginStroke = function(x, y, pressure) {
        if (curBrush === null || !this.isActiveLayerDrawable()) return false;
        prepareForLayerPaintUndo();
        paintUndoArea.makeEmpty();
        strokeBuffer.clearAll(0);
        strokedRegion.makeEmpty();
        lastX = x;
        lastY = y;
        lastPressure = pressure;
        beginPaintingInteraction();
        paintingModes[curBrush.brushMode].beginStroke();
        this.paintDab(x, y, pressure);
        return true;
    };
    this.continueStroke = function(x, y, pressure) {
        if (curBrush == null) return;
        let dist = Math.sqrt((lastX - x) * (lastX - x) + (lastY - y) * (lastY - y)), spacing = Math.max(curBrush.minSpacing, curBrush.curSize * curBrush.spacing);
        if (dist > spacing) {
            let nx = lastX, ny = lastY, np = lastPressure, df = (spacing - 0.001) / dist;
            for(let f = df; f <= 1.0; f += df){
                nx = f * x + (1.0 - f) * lastX;
                ny = f * y + (1.0 - f) * lastY;
                np = f * pressure + (1.0 - f) * lastPressure;
                this.paintDab(nx, ny, np);
            }
            lastX = nx;
            lastY = ny;
            lastPressure = np;
        }
    };
    this.endStroke = function() {
        if (curBrush == null) return;
        mergeStrokeBuffer();
        paintingModes[curBrush.brushMode].endStroke();
        paintUndoArea.clipTo(this.getBounds());
        // Did we end up painting anything?
        if (!paintUndoArea.isEmpty()) {
            addUndo(new CPUndoPaint());
            /* Eagerly update the undo buffer for next time so we can avoid this lengthy
             * prepare at the beginning of a paint stroke
             */ prepareForLayerPaintUndo();
        }
        endPaintingInteraction(false);
    };
    this.hasAlpha = function() {
        return fusion.hasAlpha();
    };
    /**
     * Get the artwork as a single flat PNG image.
     *
     * Rotation is [0..3] and selects a multiple of 90 degrees of clockwise rotation to be applied to the drawing before
     * saving.
     *
     * @return {string} A binary string of the PNG file data.
     */ this.getFlatPNG = function(rotation) {
        this.fusionLayers();
        return fusion.getAsPNG(rotation);
    };
    /**
     * Get the artwork as a single flat PNG image.
     *
     * Rotation is [0..3] and selects a multiple of 90 degrees of clockwise rotation to be applied to the drawing before
     * saving.
     *
     * @return {Buffer}
     */ this.getFlatPNGBuffer = function(rotation) {
        this.fusionLayers();
        return fusion.getAsPNGBuffer(rotation);
    };
    /**
     * Returns true if this artwork can be exactly represented as a simple transparent PNG (i.e. doesn't have multiple
     * layers, and base layer's opacity is set to 100%).
     */ this.isSimpleDrawing = function() {
        return layersRoot.layers.length == 1 && layersRoot.layers[0] instanceof (0, _cpimageLayerJsDefault.default) && !layersRoot.layers[0].mask && layersRoot.layers[0].getEffectiveAlpha() == 100;
    };
    /**
     * Save the difference between the current layer and the undoImage / undoMask (within the undoArea) for undo, and
     * clear the undoArea.
     *
     * @constructor
     */ function CPUndoPaint(paintedImage, paintedMask) {
        if (!paintedImage && !paintedMask) {
            paintedImage = !maskEditingMode;
            paintedMask = maskEditingMode;
        }
        let rect = paintUndoArea.clone(), xorImage = paintedImage ? undoImage.copyRectXOR(curLayer.image, rect) : null, xorMask = paintedMask ? undoMask.copyRectXOR(curLayer.mask, rect) : null;
        this.layer = curLayer;
        paintUndoArea.makeEmpty();
        this.undo = function() {
            if (xorImage) this.layer.image.setRectXOR(xorImage, rect);
            if (xorMask) this.layer.mask.setRectXOR(xorMask, rect);
            invalidateLayer(this.layer, rect, xorImage != null, xorMask != null);
        };
        this.redo = this.undo;
        this.getMemoryUsed = function(undone, param) {
            return (xorImage ? xorImage.length : 0) + (xorMask ? xorMask.length : 0);
        };
    }
    CPUndoPaint.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
    CPUndoPaint.prototype.constructor = CPUndoPaint;
    /**
     * Upon creation, adds a layer mask to the given layer.
     *
     * @param {CPLayer} layer
     *
     * @constructor
     */ function CPActionAddLayerMask(layer) {
        let oldMaskLinked = layer.maskLinked, oldMaskVisible = layer.maskVisible;
        this.undo = function() {
            layer.setMask(null);
            layer.maskLinked = oldMaskLinked;
            layer.maskVisible = oldMaskVisible;
            artworkStructureChanged();
            that.setActiveLayer(layer, false);
        };
        this.redo = function() {
            let newMask = new (0, _cpgreyBmpJsDefault.default)(that.width, that.height, 8);
            newMask.clearAll(255);
            layer.maskLinked = true;
            layer.maskVisible = true;
            layer.setMask(newMask);
            artworkStructureChanged();
            that.setActiveLayer(layer, true);
        };
        this.redo();
    }
    CPActionAddLayerMask.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
    CPActionAddLayerMask.prototype.constructor = CPActionAddLayerMask;
    /**
     * Upon creation, removes, or applies and removes, the layer mask on the given layer.
     *
     * @param {CPLayer} layer
     * @param {boolean} apply
     *
     * @constructor
     */ function CPActionRemoveLayerMask(layer, apply) {
        let oldMask = layer.mask, oldLayerImage, maskWasSelected = false;
        if (apply && layer instanceof (0, _cpimageLayerJsDefault.default)) oldLayerImage = layer.image.clone();
        else oldLayerImage = null;
        maskWasSelected = curLayer == layer && maskEditingMode;
        this.undo = function() {
            layer.setMask(oldMask);
            if (oldLayerImage) {
                layer.image.copyPixelsFrom(oldLayerImage);
                invalidateLayer(layer, layer.image.getBounds(), true, false);
            }
            if (maskWasSelected) that.setActiveLayer(layer, true);
            artworkStructureChanged();
        };
        this.redo = function() {
            if (oldLayerImage) {
                (0, _cpblendJsDefault.default).multiplyAlphaByMask(layer.image, 100, layer.mask);
                // Ensure thumbnail is repainted (artworkStructureChanged() doesn't repaint thumbs)
                invalidateLayer(layer, that.getBounds(), true, false);
            }
            if (maskWasSelected) that.setActiveLayer(layer, false);
            layer.setMask(null);
            artworkStructureChanged();
        };
        this.redo();
    }
    CPActionRemoveLayerMask.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
    CPActionRemoveLayerMask.prototype.constructor = CPActionRemoveLayerMask;
    /**
     * Upon creation, adds a layer at the given index in the given layer group.
     *
     * @param {CPLayerGroup} parentGroup
     * @param {number} newLayerIndex
     * @param {CPLayer} newLayer
     *
     * @constructor
     */ function CPActionAddLayer(parentGroup, newLayerIndex, newLayer) {
        const newLayerWasClipped = newLayer instanceof (0, _cpimageLayerJsDefault.default) && newLayer.clip, toBelowLayer = parentGroup.layers[newLayerIndex], toBelowLayerWasClipped = toBelowLayer instanceof (0, _cpimageLayerJsDefault.default) && toBelowLayer.clip, fromMask = maskEditingMode;
        this.undo = function() {
            parentGroup.removeLayer(newLayer);
            let newSelection = parentGroup.layers[newLayerIndex - 1] || parentGroup.layers[0] || parentGroup;
            if (toBelowLayer instanceof (0, _cpimageLayerJsDefault.default)) toBelowLayer.clip = toBelowLayerWasClipped;
            if (newLayer instanceof (0, _cpimageLayerJsDefault.default)) newLayer.clip = newLayerWasClipped;
            artworkStructureChanged();
            that.setActiveLayer(newSelection, fromMask);
        };
        this.redo = function() {
            parentGroup.insertLayer(newLayerIndex, newLayer);
            if (toBelowLayerWasClipped) {
                if (newLayer instanceof (0, _cpimageLayerJsDefault.default)) // Join a clipping group if we add an image layer in the middle of it
                newLayer.clip = true;
                else // If we add a group into a clipping group, break it
                toBelowLayer.clip = false;
            }
            artworkStructureChanged();
            that.setActiveLayer(newLayer, false);
        };
        this.redo();
    }
    CPActionAddLayer.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
    CPActionAddLayer.prototype.constructor = CPActionAddLayer;
    /**
     * Make a copy of the currently selected layer and add the new layer on top of the current layer.
     *
     * @param {CPLayer} sourceLayer
     * @constructor
     */ function CPActionDuplicateLayer(sourceLayer) {
        let newLayer = sourceLayer.clone(), oldMask = maskEditingMode;
        this.undo = function() {
            newLayer.parent.removeLayer(newLayer);
            artworkStructureChanged();
            that.setActiveLayer(sourceLayer, oldMask);
        };
        this.redo = function() {
            const COPY_SUFFIX = " Copy";
            let newLayerName = sourceLayer.name;
            if (!newLayerName.endsWith(COPY_SUFFIX)) newLayerName += COPY_SUFFIX;
            newLayer.name = newLayerName;
            sourceLayer.parent.insertLayer(sourceLayer.parent.indexOf(sourceLayer) + 1, newLayer);
            artworkStructureChanged();
            that.setActiveLayer(newLayer, false);
        };
        this.redo();
    }
    CPActionDuplicateLayer.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
    CPActionDuplicateLayer.prototype.constructor = CPActionDuplicateLayer;
    /**
     * @param {CPLayer} layer
     */ function CPActionRemoveLayer(layer) {
        let oldGroup = layer.parent, oldIndex = oldGroup.indexOf(layer), oldMask = maskEditingMode, numLayersClippedAbove = 0;
        if (layer instanceof (0, _cpimageLayerJsDefault.default) && !layer.clip) for(let i = oldIndex + 1; i < oldGroup.layers.length; i++){
            if (oldGroup.layers[i] instanceof (0, _cpimageLayerJsDefault.default) && oldGroup.layers[i].clip) numLayersClippedAbove++;
            else break;
        }
        this.undo = function() {
            oldGroup.insertLayer(oldIndex, layer);
            for(let i = 0; i < numLayersClippedAbove; i++)oldGroup.layers[i + oldIndex + 1].clip = true;
            artworkStructureChanged();
            that.setActiveLayer(layer, oldMask);
        };
        this.redo = function() {
            // Release the clip of any layers who had us as their clipping root
            for(let i = 0; i < numLayersClippedAbove; i++)oldGroup.layers[i + oldIndex + 1].clip = false;
            oldGroup.removeLayerAtIndex(oldIndex);
            let newSelectedLayer;
            /* Attempt to select the layer underneath the one that was removed, otherwise the one on top,
             * otherwise the group that contained the layer.
             */ if (oldGroup.layers.length == 0) newSelectedLayer = layer.parent;
            else newSelectedLayer = oldGroup.layers[Math.max(oldIndex - 1, 0)];
            artworkStructureChanged();
            that.setActiveLayer(newSelectedLayer, false);
        };
        this.getMemoryUsed = function(undone, param) {
            return undone ? 0 : layer.getMemoryUsed();
        };
        this.redo();
    }
    CPActionRemoveLayer.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
    CPActionRemoveLayer.prototype.constructor = CPActionRemoveLayer;
    /**
     * Merge the given group together to form an image layer.
     *
     * @param {CPLayerGroup} layerGroup
     * @constructor
     */ function CPActionMergeGroup(layerGroup) {
        let oldGroupIndex = layerGroup.parent.indexOf(layerGroup), fromMask = maskEditingMode, mergedLayer = new (0, _cpimageLayerJsDefault.default)(that.width, that.height, "");
        this.undo = function() {
            layerGroup.parent.setLayerAtIndex(oldGroupIndex, layerGroup);
            artworkStructureChanged();
            that.setActiveLayer(layerGroup, fromMask);
        };
        this.redo = function() {
            layerGroup.parent.setLayerAtIndex(oldGroupIndex, mergedLayer);
            artworkStructureChanged();
            that.setActiveLayer(mergedLayer, false);
        };
        this.getMemoryUsed = function(undone, param) {
            return undone ? 0 : layerGroup.getMemoryUsed();
        };
        let blendTree = new (0, _cpblendTreeJsDefault.default)(layerGroup, that.width, that.height, false), blended;
        blendTree.buildTree();
        blended = blendTree.blendTree();
        mergedLayer.name = layerGroup.name;
        mergedLayer.alpha = blended.alpha;
        mergedLayer.image = blended.image;
        mergedLayer.blendMode = blended.blendMode;
        mergedLayer.mask = blended.mask;
        if (mergedLayer.blendMode == (0, _cpblendJsDefault.default).LM_PASSTHROUGH) // Passthrough is not a meaningful blend mode for a single layer
        mergedLayer.blendMode = (0, _cpblendJsDefault.default).LM_NORMAL;
        this.redo();
    }
    CPActionMergeGroup.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
    CPActionMergeGroup.prototype.constructor = CPActionMergeGroup;
    /**
     * Merge the top layer onto the under layer and remove the top layer.
     *
     * @param {CPImageLayer} topLayer
     * @constructor
     */ function CPActionMergeDownLayer(topLayer) {
        let group = topLayer.parent, underLayer = group.layers[group.indexOf(topLayer) - 1], mergedLayer = new (0, _cpimageLayerJsDefault.default)(that.width, that.height, ""), fromMask = maskEditingMode;
        this.undo = function() {
            let mergedIndex = group.indexOf(mergedLayer);
            group.removeLayerAtIndex(mergedIndex);
            group.insertLayer(mergedIndex, topLayer);
            group.insertLayer(mergedIndex, underLayer);
            artworkStructureChanged();
            that.setActiveLayer(topLayer, fromMask);
        };
        this.redo = function() {
            // 上のレイヤーがクリッピングされていない時と、下のレイヤーがクリッピングされている時には、クリッピング処理は必要ない。
            if (underLayer.clip || !topLayer.clip) {
                // `underLayer` を `mergedLayer` にコピー
                mergedLayer.copyFrom(underLayer);
                if (topLayer.getEffectiveAlpha() > 0) {
                    // Ensure base layer has alpha 100, and apply its mask, ready for blending
                    if (mergedLayer.mask) (0, _cpblendJsDefault.default).multiplyAlphaByMask(mergedLayer.image, mergedLayer.alpha, mergedLayer.mask);
                    else (0, _cpblendJsDefault.default).multiplyAlphaBy(mergedLayer.image, mergedLayer.alpha);
                    (0, _cpblendJsDefault.default).fuseImageOntoImage(mergedLayer.image, true, topLayer.image, topLayer.alpha, topLayer.blendMode, topLayer.getBounds(), topLayer.mask);
                }
            } else {
                // 下のレイヤーと結合する時にクリッピング処理が必要
                // 上下のレイヤーを含むレイヤーグループを一時的に作成
                const tempGroup = new (0, _cplayerGroupJsDefault.default)();
                tempGroup.layers = [
                    underLayer,
                    topLayer
                ];
                tempGroup.parent = null; // No parent for this temporary group
                tempGroup.name = "Temporary Group";
                // ブレンドツリーを作成してビルド
                let blendTree = new (0, _cpblendTreeJsDefault.default)(tempGroup, that.width, that.height, false);
                blendTree.buildTree();
                let blended = blendTree.blendTree();
                // `mergedLayer` の合成結果を設定
                mergedLayer.image = blended.image;
            }
            // 合成結果を `mergedLayer` のプロパティに設定する
            mergedLayer.name = underLayer.name; // 下のレイヤーの名前が残る
            mergedLayer.alpha = 100;
            mergedLayer.blendMode = underLayer.blendMode; // 下のレイヤーの合成方法を使用
            mergedLayer.mask = null; // マスクをクリア
            let underIndex = group.indexOf(underLayer);
            // 上下のレイヤーを結合されたレイヤーに置き換える
            group.removeLayerAtIndex(underIndex);
            group.removeLayerAtIndex(underIndex);
            // 下のレイヤーの位置に結合したレイヤーを挿入する
            group.insertLayer(underIndex, mergedLayer);
            artworkStructureChanged();
            that.setActiveLayer(mergedLayer, false);
        };
        this.getMemoryUsed = function(undone, param) {
            return undone ? 0 : topLayer.getMemoryUsed() + mergedLayer.getMemoryUsed();
        };
        this.redo();
    }
    CPActionMergeDownLayer.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
    CPActionMergeDownLayer.prototype.constructor = CPActionMergeDownLayer;
    function CPActionMergeAllLayers(addFlattenedLayer = false) {
        let oldActiveLayer = that.getActiveLayer(), oldRootLayers = layersRoot.layers.slice(0), flattenedLayer = new (0, _cpimageLayerJsDefault.default)(that.width, that.height, "");
        this.undo = function() {
            layersRoot.layers = oldRootLayers.slice(0);
            artworkStructureChanged();
            that.setActiveLayer(oldActiveLayer, false);
        };
        this.redo = function() {
            let mergedImage = that.fusionLayers();
            flattenedLayer.copyImageFrom(mergedImage);
            // Generate the name after the document is empty (so it can be "Layer 1")
            flattenedLayer.setName(that.getDefaultLayerName(false));
            if (addFlattenedLayer) {
                // 元のレイヤーは残して、flattenedLayer を上に追加
                layersRoot.layers = oldRootLayers.slice(0); // 念のため復元
                layersRoot.addLayer(flattenedLayer);
            } else {
                // 元のレイヤーをすべて削除し、flattenedLayer だけにする
                layersRoot.clearLayers();
                layersRoot.addLayer(flattenedLayer);
            }
            artworkStructureChanged();
            that.setActiveLayer(flattenedLayer, false);
        };
        this.getMemoryUsed = function(undone, param) {
            return oldRootLayers.map((layer)=>layer.getMemoryUsed()).reduce(sum, 0);
        };
        this.redo();
    }
    CPActionMergeAllLayers.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
    CPActionMergeAllLayers.prototype.constructor = CPActionMergeAllLayers;
    /**
     * Move the layer to the given position in the layer tree.
     *
     * @param {CPLayer} layer
     * @param {CPLayerGroup} toGroup - The group that the layer will be a child of after moving
     * @param {number} toIndex - The index of the layer inside the destination group that the layer will be below after the
     *                        move.
     * @constructor
     */ function CPActionRelocateLayer(layer, toGroup, toIndex) {
        const fromGroup = layer.parent, fromIndex = layer.parent.indexOf(layer), fromMask = maskEditingMode, fromBelowLayer = fromGroup.layers[fromGroup.indexOf(layer) + 1], toBelowLayer = toGroup.layers[toIndex], wasClipped = layer instanceof (0, _cpimageLayerJsDefault.default) && layer.clip, wasClippedTo = wasClipped ? layer.getClippingBase() : false;
        let fromNumLayersClippedAbove = 0, toNumLayersClippedAbove = 0;
        if (layer instanceof (0, _cpimageLayerJsDefault.default) && !layer.clip) // Release the clip of any layers that had us as their clipping root
        for(let i = fromIndex + 1; i < fromGroup.layers.length; i++){
            if (fromGroup.layers[i] instanceof (0, _cpimageLayerJsDefault.default) && fromGroup.layers[i].clip) fromNumLayersClippedAbove++;
            else break;
        }
        else if (layer instanceof (0, _cplayerGroupJsDefault.default)) // If we move a group into the middle of a clipping group, release the clip of the layers above
        for(let i = toIndex; i < toGroup.layers.length; i++){
            if (toGroup.layers[i] instanceof (0, _cpimageLayerJsDefault.default) && toGroup.layers[i].clip) toNumLayersClippedAbove++;
            else break;
        }
        this.undo = function() {
            layer.parent.removeLayer(layer);
            let newIndex = fromBelowLayer ? fromGroup.indexOf(fromBelowLayer) : fromGroup.layers.length;
            fromGroup.insertLayer(newIndex, layer);
            if (layer instanceof (0, _cpimageLayerJsDefault.default)) layer.clip = wasClipped;
            for(let i = 0; i < fromNumLayersClippedAbove; i++)fromGroup.layers[i + fromIndex + 1].clip = true;
            for(let i = 0; i < toNumLayersClippedAbove; i++)toGroup.layers[i + toIndex].clip = true;
            artworkStructureChanged();
            that.setActiveLayer(layer, fromMask);
        };
        this.redo = function() {
            for(let i = 0; i < fromNumLayersClippedAbove; i++)fromGroup.layers[i + fromIndex + 1].clip = false;
            layer.parent.removeLayer(layer);
            let newIndex = toBelowLayer ? toGroup.indexOf(toBelowLayer) : toGroup.layers.length;
            toGroup.insertLayer(newIndex, layer);
            for(let i = 0; i < toNumLayersClippedAbove; i++)toGroup.layers[i + newIndex + 1].clip = false;
            if (layer instanceof (0, _cpimageLayerJsDefault.default)) {
                /*
                 * Release the layer clip if we move the layer somewhere it won't be clipped onto its original base
                 */ if (layer.clip && layer.getClippingBase() != wasClippedTo) layer.clip = false;
                // If we're moving into the middle of a new clipping group, join the clip
                if (toBelowLayer instanceof (0, _cpimageLayerJsDefault.default) && toBelowLayer.clip) layer.clip = true;
            }
            for(let i = 0; i < toNumLayersClippedAbove; i++)toGroup.layers[i + newIndex + 1].clip = false;
            artworkStructureChanged();
            // TODO if moving to a collapsed group, select the group rather than the layer
            that.setActiveLayer(layer, false);
        };
        this.redo();
    }
    CPActionRelocateLayer.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
    CPActionRelocateLayer.prototype.constructor = CPActionRelocateLayer;
    /**
     * @param {string} propertyName
     * @param {boolean} invalidatesLayer
     *
     * @returns {typeof CPUndo}
     */ function generateLayerPropertyChangeAction(propertyName, invalidatesLayer) {
        let capitalPropertyName = capitalizeFirst(propertyName), ChangeAction = function(layers, newValue) {
            if (!Array.isArray(layers)) layers = [
                layers
            ];
            this.layers = layers;
            this.from = this.layers.map((layer)=>layer["get" + capitalPropertyName]());
            this.to = newValue;
            this.redo();
        };
        ChangeAction.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
        ChangeAction.prototype.constructor = ChangeAction;
        ChangeAction.prototype.undo = function() {
            this.layers.forEach((layer, index)=>layer["set" + capitalPropertyName](this.from[index]));
            this.layers.forEach((layer)=>layerPropertyChanged(layer, propertyName, !invalidatesLayer));
        };
        ChangeAction.prototype.redo = function() {
            this.layers.forEach((layer)=>layer["set" + capitalPropertyName](this.to));
            this.layers.forEach((layer)=>layerPropertyChanged(layer, propertyName, !invalidatesLayer));
        };
        ChangeAction.prototype.merge = function(u) {
            if (u instanceof ChangeAction && arrayEquals(this.layers, u.layers)) {
                this.to = u.to;
                return true;
            }
            return false;
        };
        ChangeAction.prototype.noChange = function() {
            for(let i = 0; i < this.from.length; i++){
                if (this.from[i] != this.to) return false;
            }
            return true;
        };
        return ChangeAction;
    }
    let CPActionChangeLayerAlpha = generateLayerPropertyChangeAction("alpha", true), CPActionChangeLayerMode = generateLayerPropertyChangeAction("blendMode", true), CPActionChangeLayerVisible = generateLayerPropertyChangeAction("visible", true), CPActionChangeLayerClip = generateLayerPropertyChangeAction("clip", true), CPActionChangeLayerMaskVisible = generateLayerPropertyChangeAction("maskVisible", true), CPActionChangeLayerName = generateLayerPropertyChangeAction("name", false), CPActionChangeLayerLockAlpha = generateLayerPropertyChangeAction("lockAlpha", false), CPActionChangeLayerMaskLinked = generateLayerPropertyChangeAction("maskLinked", false);
    /**
     * @param {CPRect} from
     * @param {CPRect} to
     *
     * @constructor
     */ function CPUndoRectangleSelection(from, to) {
        from = from.clone();
        to = to.clone();
        this.undo = function() {
            that.setSelection(from);
            // TODO this is just because CPCanvas doesn't know when to repaint the selection box
            callListenersUpdateRegion(that.getBounds());
        };
        this.redo = function() {
            that.setSelection(to);
            callListenersUpdateRegion(that.getBounds());
        };
        this.noChange = function() {
            return from.equals(to);
        };
    }
    CPUndoRectangleSelection.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
    CPUndoRectangleSelection.prototype.constructor = CPUndoRectangleSelection;
    class CPActionTransformSelection extends (0, _cpundoJsDefault.default) {
        constructor(){
            super();
            /**
             * The layer we're moving (which might be an image layer or a whole group of layers).
             *
             * @type {CPLayer}
             */ this.layer = curLayer;
            /**
             * @type {CPRect}
             */ this.fromSelection = that.getSelection();
            this.fromMaskMode = maskEditingMode;
            this.movingWholeLayer = this.fromSelection.isEmpty();
            this.movingImage = !maskEditingMode || this.movingWholeLayer && this.layer.maskLinked;
            this.movingMask = maskEditingMode || this.movingWholeLayer && this.layer.maskLinked;
            this.hasFullUndo = false;
            /**
             * Set to true for transformations which will clear the pixels of the source rectangle (i.e. moves)
             * @type {boolean}
             */ this.erasesSourceRect = false;
            /**
             * The rectangle we transformed onto in a previous iteration.
             *
             * @type {CPRect}
             */ this.dstRect = new (0, _cprectJsDefault.default)(0, 0, 0, 0);
            /**
             * @typedef {Object} LayerMoveInfo
             *
             * @property {CPLayer} layer
             * @property {boolean} moveImage
             * @property {boolean} moveMask
             *
             * We either have these full undos which cover the whole layer area:
             *
             * @property {?CPColorBmp} imageUndo
             * @property {?CPGreyBmp} maskUndo
             *
             * Or else we have this map from rectangles to images which cover the dirtied areas only.
             *
             * @property {Map} imageRect
             * @property {Map} maskRect
             */ /**
             * A list of the layers we're moving, and their properties.
             *
             * @type {LayerMoveInfo[]}
             */ this.movingLayers = [
                {
                    layer: this.layer,
                    moveImage: this.layer instanceof (0, _cpimageLayerJsDefault.default) && this.movingImage,
                    moveMask: this.layer.mask !== null && this.movingMask,
                    imageRect: new Map(),
                    maskRect: new Map()
                }
            ];
            // Moving the "image" of a group means to move all of its children
            if (this.layer instanceof (0, _cplayerGroupJsDefault.default) && this.movingImage && this.movingWholeLayer) this.movingLayers = this.movingLayers.concat(this.layer.getLinearizedLayerList(false).map((layer)=>({
                    layer: layer,
                    moveImage: layer instanceof (0, _cpimageLayerJsDefault.default),
                    moveMask: layer.mask !== null && layer.maskLinked,
                    imageRect: new Map(),
                    maskRect: new Map()
                })));
            // Only need to transform the non-transparent pixels
            let occupiedSpace = new (0, _cprectJsDefault.default)(0, 0, 0, 0);
            if (this.movingWholeLayer) {
                /**
                 * @type {CPRect}
                 */ this.srcRect = that.getBounds();
                for(let i = 0; i < this.movingLayers.length && !occupiedSpace.equals(this.srcRect); i++){
                    let layerInfo = this.movingLayers[i];
                    if (layerInfo.moveMask) // Find the non-white pixels, since we'll be erasing the moved area with white
                    occupiedSpace.union(layerInfo.layer.mask.getValueBounds(this.srcRect, 0xff));
                    if (layerInfo.moveImage) occupiedSpace.union(layerInfo.layer.image.getNonTransparentBounds(this.srcRect));
                }
            } else {
                this.srcRect = this.fromSelection.clone();
                for(let i = 0; i < this.movingLayers.length && !occupiedSpace.equals(this.srcRect); i++){
                    let layerInfo = this.movingLayers[i];
                    if (layerInfo.moveMask) // Find the non-black pixels, since we'll be erasing the moved area with black
                    occupiedSpace.union(layerInfo.layer.mask.getValueBounds(this.srcRect, 0x00));
                    if (layerInfo.moveImage) occupiedSpace.union(layerInfo.layer.image.getNonTransparentBounds(this.srcRect));
                }
            }
            this.srcRect = occupiedSpace;
        }
        /**
         * @override
         */ undo() {
            let restoreRegions = [];
            if (!this.dstRect.isEmpty()) restoreRegions.push(this.dstRect);
            if (this.erasesSourceRect) {
                restoreRegions.push(this.srcRect);
                restoreRegions = (0, _cprectJsDefault.default).union(restoreRegions);
            }
            this.movingLayers.forEach((layerInfo)=>{
                if (this.hasFullUndo) restoreRegions.forEach((region)=>{
                    if (layerInfo.moveImage) layerInfo.layer.image.copyBitmapRect(layerInfo.imageUndo, region.left, region.top, region);
                    if (layerInfo.moveMask) layerInfo.layer.mask.copyBitmapRect(layerInfo.maskUndo, region.left, region.top, region);
                });
                else {
                    if (layerInfo.moveImage) layerInfo.imageRect.forEach((image, rect)=>{
                        layerInfo.layer.image.copyBitmapRect(image, rect.left, rect.top, image.getBounds());
                    });
                    if (layerInfo.moveMask) layerInfo.maskRect.forEach((mask, rect)=>{
                        layerInfo.layer.mask.copyBitmapRect(mask, rect.left, rect.top, mask.getBounds());
                    });
                }
            });
            invalidateLayer(this.movingLayers.map((layerInfo)=>layerInfo.layer), restoreRegions.reduce((a, b)=>a.getUnion(b), new (0, _cprectJsDefault.default)(0, 0, 0, 0)), true, true);
            // Call this after we're done with restoreRegions, since it might be a part of that array.
            this.dstRect.makeEmpty();
            that.setSelection(this.fromSelection);
            that.setActiveLayer(this.layer, this.fromMaskMode);
            /*
             * FIXME Required because in the case of a copy, we don't invalidate the source rect in the fusion, so the canvas
             * won't end up repainting the selection rectangle there.
             */ callListenersSelectionChange();
        }
        getMemoryUsed(undone, param) {
            return this.movingLayers.map(function(layerInfo) {
                let images = [
                    layerInfo.imageUndo,
                    layerInfo.maskUndo,
                    layerInfo.imageRect,
                    layerInfo.maskRect
                ];
                return images.map((image)=>image ? image.getMemorySize() : 0).reduce(sum, 0);
            }).reduce(sum, 0);
        }
        /**
         * Called internally to reverse the effects of compact()
         */ buildFullUndo() {
            if (!this.hasFullUndo) {
                this.movingLayers.forEach(function(layerInfo) {
                    if (layerInfo.moveImage) layerInfo.imageUndo = layerInfo.layer.image.clone();
                    if (layerInfo.moveMask) layerInfo.maskUndo = layerInfo.layer.mask.clone();
                    layerInfo.imageRect.clear();
                    layerInfo.maskRect.clear();
                });
                this.hasFullUndo = true;
            }
        }
        /**
         * Called when we're no longer the top operation in the undo stack, so that we can optimize for lower memory
         * usage instead of faster revision speed
         */ compact() {
            if (this.hasFullUndo) {
                // Replace our copy of the whole layers with just a copy of the areas we damaged
                let damagedRects = [];
                if (!this.dstRect.isEmpty()) damagedRects.push(this.dstRect);
                if (this.erasesSourceRect) {
                    damagedRects.push(this.srcRect);
                    damagedRects = (0, _cprectJsDefault.default).union(damagedRects);
                }
                this.movingLayers.forEach((layerInfo)=>{
                    layerInfo.imageRect.clear();
                    layerInfo.maskRect.clear();
                    damagedRects.forEach((rect)=>{
                        if (layerInfo.moveImage) layerInfo.imageRect.set(rect, layerInfo.imageUndo.cloneRect(rect));
                        if (layerInfo.moveMask) layerInfo.maskRect.set(rect, layerInfo.maskUndo.cloneRect(rect));
                    });
                    // Discard the full-size undos
                    layerInfo.imageUndo = null;
                    layerInfo.maskUndo = null;
                });
                this.hasFullUndo = false;
            }
        }
    }
    /**
     * Transforms the currently selected region of the current layer by the given affine transform.
     *
     * @param {CPTransform} affineTransform - Transform to apply
     * @param {string} interpolation - "smooth" or "sharp"
     */ class CPActionAffineTransformSelection extends CPActionTransformSelection {
        constructor(affineTransform, interpolation){
            super();
            this.erasesSourceRect = true;
            this.affineTransform = affineTransform.clone();
            this.interpolation = interpolation || "smooth";
            /**
             * A canvas for composing the transform onto
             * @type {HTMLCanvasElement}
             */ this.composeCanvas = null;
            /**
             * @type {CanvasRenderingContext2D}
             */ this.composeCanvasContext = null;
        }
        /**
         * @override
         */ buildFullUndo() {
            if (!this.hasFullUndo) {
                super.buildFullUndo();
                // Make a copy of just the source rectangles in their own canvases so we can transform them layer with Canvas APIs
                this.movingLayers.forEach((layerInfo)=>{
                    if (layerInfo.moveImage) {
                        let canvas = (0, _canvasJs.createCanvas)(this.srcRect.getWidth(), this.srcRect.getHeight()), context = canvas.getContext("2d");
                        context.putImageData(layerInfo.layer.image.getImageData(), -this.srcRect.left, -this.srcRect.top, this.srcRect.left, this.srcRect.top, this.srcRect.getWidth(), this.srcRect.getHeight());
                        layerInfo.imageSourceCanvas = canvas;
                    }
                    if (layerInfo.moveMask) {
                        let canvas = (0, _canvasJs.createCanvas)(this.srcRect.getWidth(), this.srcRect.getHeight()), context = canvas.getContext("2d");
                        context.putImageData(layerInfo.layer.mask.getImageData(this.srcRect.left, this.srcRect.top, this.srcRect.getWidth(), this.srcRect.getHeight()), 0, 0);
                        layerInfo.maskSourceCanvas = canvas;
                    }
                });
                this.composeCanvas = (0, _canvasJs.createCanvas)(that.width, that.height);
                // willReadFrequently オプションを使用して Canvas コンテキストを取得
                this.composeCanvasContext = this.composeCanvas.getContext("2d", {
                    willReadFrequently: true
                });
                (0, _cppolyfillJs.setCanvasInterpolation)(this.composeCanvasContext, this.interpolation == "smooth");
                /* Calling getImageData on the canvas forces Chrome to disable hardware acceleration for it, see
                 * GetImageDataForcesNoAcceleration in https://cs.chromium.org/chromium/src/third_party/WebKit/Source/platform/graphics/ExpensiveCanvasHeuristicParameters.h
                 *
                 * We normally call this as part of finishing up our redo(), which means that our first redo() would
                 * use hardware acceleration, and all subsequent redo()s would use software emulation, with subtly
                 * different pixel results.
                 *
                 * Force our results to be consistent by calling that right now:
                 */ this.junk = this.composeCanvasContext.getImageData(0, 0, 1, 1);
            }
        }
        redo() {
            this.buildFullUndo();
            let oldDstRect = this.dstRect.clone(), dstCorners = this.srcRect.toPoints();
            this.affineTransform.transformPoints(dstCorners);
            this.dstRect.set((0, _cprectJsDefault.default).createBoundingBox(dstCorners).roundContain().clipTo(that.getBounds()));
            const /* The area of original image data that we need to compose the transformed area onto (i.e. excluding the
                 * source area we're just going to erase)
                 */ composeOntoRects = (0, _cprectJsDefault.default).subtract(this.dstRect, this.srcRect), /* We need to erase the area we're moving from.
                 *
                 * If this is an amend(), we've already erased the source rectangle (except for the part occupied by the
                 * old destination rectangle)
                 *
                 * We don't need to erase the area we're planning to overwrite later (dstRect)
                 */ eraseRects = (0, _cprectJsDefault.default).subtract(oldDstRect.isEmpty() ? this.srcRect : this.srcRect.getIntersection(oldDstRect), this.dstRect), // The region of the source rectangle that we want to compose onto
            srcComposeRect = this.srcRect.getIntersection(this.dstRect), // Regions from oldDstRect in the layer data that we need to clean up after our operation
            repairOldRects = (0, _cprectJsDefault.default).subtract(oldDstRect, [
                this.dstRect,
                this.srcRect
            ]), // The region which needs repainting (from the previous redo() and after our redo())
            invalidateRect = this.srcRect.getUnion(this.dstRect).getUnion(oldDstRect);
            this.movingLayers.forEach((layerInfo)=>{
                // Erase the source area that won't be replaced by the canvas dest area
                eraseRects.forEach((rect)=>{
                    if (layerInfo.moveImage) layerInfo.layer.image.clearRect(rect, EMPTY_LAYER_COLOR);
                    if (layerInfo.moveMask) {
                        if (this.movingWholeLayer) layerInfo.layer.mask.clearRect(rect, 0xff);
                        else layerInfo.layer.mask.clearRect(rect, EMPTY_MASK_COLOR);
                    }
                });
                if (!this.dstRect.isEmpty()) {
                    if (layerInfo.moveImage) {
                        let imageData = layerInfo.imageUndo.getImageData();
                        /*
                         * Make a fresh copy of the undo data into the Canvas so we can compose the transformed data on top of
                         * it (except the source region since we'll just erase that).
                         */ composeOntoRects.forEach((rect)=>{
                            this.composeCanvasContext.putImageData(imageData, 0, 0, rect.left, rect.top, rect.getWidth(), rect.getHeight());
                        });
                        // Erase the portion of the source region that we're going to compose onto
                        this.composeCanvasContext.clearRect(srcComposeRect.left, srcComposeRect.top, srcComposeRect.getWidth(), srcComposeRect.getHeight());
                        this.composeCanvasContext.save();
                        // Apply the transform when drawing the transformed fragment
                        this.composeCanvasContext.setTransform(this.affineTransform.m[0], this.affineTransform.m[1], this.affineTransform.m[2], this.affineTransform.m[3], this.affineTransform.m[4], this.affineTransform.m[5]);
                        this.composeCanvasContext.drawImage(layerInfo.imageSourceCanvas, this.srcRect.left, this.srcRect.top);
                        this.composeCanvasContext.restore();
                        // Save that to the layer data
                        layerInfo.layer.image.copyBitmapRect(new (0, _cpcolorBmpJsDefault.default)(this.composeCanvasContext.getImageData(this.dstRect.left, this.dstRect.top, this.dstRect.getWidth(), this.dstRect.getHeight())), this.dstRect.left, this.dstRect.top, new (0, _cprectJsDefault.default)(0, 0, this.dstRect.getWidth(), this.dstRect.getHeight()));
                    }
                    if (layerInfo.moveMask) {
                        composeOntoRects.forEach((rect)=>{
                            this.composeCanvasContext.putImageData(layerInfo.layer.mask.getImageData(rect.left, rect.top, rect.getWidth(), rect.getHeight()), rect.left, rect.top);
                        });
                        if (this.movingWholeLayer) this.composeCanvasContext.fillStyle = "#FFF";
                        else this.composeCanvasContext.fillStyle = "#000";
                        this.composeCanvasContext.fillRect(srcComposeRect.left, srcComposeRect.top, srcComposeRect.getWidth(), srcComposeRect.getHeight());
                        this.composeCanvasContext.save();
                        // TODO set blend mode to replace? We don't have any alpha in the source or dest images
                        this.composeCanvasContext.setTransform(this.affineTransform.m[0], this.affineTransform.m[1], this.affineTransform.m[2], this.affineTransform.m[3], this.affineTransform.m[4], this.affineTransform.m[5]);
                        this.composeCanvasContext.drawImage(layerInfo.maskSourceCanvas, this.srcRect.left, this.srcRect.top);
                        this.composeCanvasContext.restore();
                        layerInfo.layer.mask.pasteImageData(this.composeCanvasContext.getImageData(this.dstRect.left, this.dstRect.top, this.dstRect.getWidth(), this.dstRect.getHeight()), this.dstRect.left, this.dstRect.top);
                    }
                }
                /*
                 * Use the CPColorBmp/CPGreyBmp undo data to erase any leftovers from the previous redo(). We do this
                 * instead of just copying from the canvas, since Canvas' getImageData/setImageData doesn't round-trip
                 * (due to premultiplied alpha on some browsers/systems) and we want to avoid damaging areas we don't
                 * need to touch.
                 */ repairOldRects.forEach((rect)=>{
                    if (layerInfo.moveImage) layerInfo.layer.image.copyBitmapRect(layerInfo.imageUndo, rect.left, rect.top, rect);
                    if (layerInfo.moveMask) layerInfo.layer.mask.copyBitmapRect(layerInfo.maskUndo, rect.left, rect.top, rect);
                });
            });
            invalidateLayer(this.movingLayers.map((layerInfo)=>layerInfo.layer), invalidateRect, true, true);
            // Transform the selection rect to enclose the transformed selection
            if (!this.fromSelection.isEmpty()) {
                let toSelectionPoints = this.fromSelection.toPoints(), toSelectionRect;
                this.affineTransform.transformPoints(toSelectionPoints);
                toSelectionRect = (0, _cprectJsDefault.default).createBoundingBox(toSelectionPoints);
                toSelectionRect.roundNearest();
                that.setSelection(toSelectionRect);
                callListenersSelectionChange();
            }
            that.setActiveLayer(this.layer, this.fromMaskMode);
        }
        /**
         * Replace the transform with the given one.
         *
         * @override
         *
         * @param {CPTransform} affineTransform
         */ amend(affineTransform) {
            if (!this.hasFullUndo) /* redo() requires a full undo to be available to update the transform. It'll effectively undo the
                 * current transform for us while it does the redo.
                 *
                 * If there's no full undo, for redo() to be able to generate it we'll have to undo() for them first.
                 */ this.undo();
            this.affineTransform = affineTransform.clone();
            this.redo();
        }
        setInterpolation(newInterpolation) {
            if (newInterpolation != this.interpolation) {
                this.interpolation = newInterpolation;
                if (this.composeCanvasContext) (0, _cppolyfillJs.setCanvasInterpolation)(this.composeCanvasContext, this.interpolation == "smooth");
                this.undo();
                this.redo();
            }
        }
        /**
         * @override
         */ compact() {
            super.compact();
            // Discard our temporary drawing canvases
            this.composeCanvas = null;
            this.composeCanvasContext = null;
            this.movingLayers.forEach((layerInfo)=>layerInfo.imageSourceCanvas = null);
        }
        /**
         * @override
         */ getMemoryUsed(undone, param) {
            let result = super.getMemoryUsed(undone, param);
            result += memoryUsedByCanvas(this.composeCanvas);
            result += this.movingLayers.map((layerInfo)=>memoryUsedByCanvas(layerInfo.imageSourceCanvas)).reduce(sum, 0);
            return result;
        }
        /**
         * Get a copy of the affine transform.
         */ getTransform() {
            return this.affineTransform.clone();
        }
        /**
         * Get a copy of the initial document rectangle (before the transform was applied)
         *
         * @returns {CPRect}
         */ getInitialTransformRect() {
            return this.srcRect.clone();
        }
        /**
         * Get a copy of the initial user selection rectangle (before the transform was applied). Can be empty if
         * the user didn't have anything selected before the transform began.
         *
         * @returns {CPRect}
         */ getInitialSelectionRect() {
            return this.fromSelection.clone();
        }
    }
    /**
     * Upon creation, moves the currently selected region of the current layer by the given offset
     *
     * @param {?CPRect} srcRect - Rectangle that will be moved, or an empty rectangle to move whole layer.
     * @param {number} offsetX
     * @param {number} offsetY
     * @param {boolean} copy - True if we should copy to the destination instead of move.
     * @constructor
     */ class CPActionMoveSelection extends CPActionTransformSelection {
        constructor(offsetX, offsetY, copy){
            super();
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.erasesSourceRect = !copy;
        }
        redo() {
            let oldDestRect = this.dstRect.clone(), destRectUnclipped, /**
                 * Do we have anything to repaint from a previous call to redo()? (if we are called by amend())
                 * @type {CPRect[]}
                 */ restoreFromUndoAreas, invalidateRegion = oldDestRect.clone(), eraseRegion = null;
            this.buildFullUndo();
            this.dstRect.set(this.srcRect);
            this.dstRect.translate(this.offsetX, this.offsetY);
            destRectUnclipped = this.dstRect.clone();
            this.dstRect.clipTo(that.getBounds());
            if (this.erasesSourceRect) {
                // We're moving, so erase the source region we're moving out of.
                if (oldDestRect.isEmpty()) eraseRegion = this.srcRect;
                else /*
                     * We've erased the source rect already in a previous redo(), so we only need to erase the damaged
                     * area.
                     */ eraseRegion = this.srcRect.getIntersection(oldDestRect);
                invalidateRegion.union(eraseRegion);
                restoreFromUndoAreas = oldDestRect.subtract(this.srcRect);
            } else restoreFromUndoAreas = [
                oldDestRect
            ];
            this.movingLayers.forEach((layerInfo)=>{
                if (eraseRegion) {
                    if (layerInfo.moveImage) layerInfo.layer.image.clearRect(eraseRegion, EMPTY_LAYER_COLOR);
                    if (layerInfo.moveMask) layerInfo.layer.mask.clearRect(eraseRegion, this.movingWholeLayer ? 0xff : EMPTY_MASK_COLOR);
                }
                restoreFromUndoAreas.forEach(function(restore) {
                    if (layerInfo.moveImage) layerInfo.layer.image.copyBitmapRect(layerInfo.imageUndo, restore.left, restore.top, restore);
                    if (layerInfo.moveMask) layerInfo.layer.mask.copyBitmapRect(layerInfo.maskUndo, restore.left, restore.top, restore);
                });
                /* Note that while we could copy image data from the layer itself onto the layer (instead of sourcing that
                 * data from the undo buffers), this would require that pasteAlphaRect do the right thing when source and
                 * dest rectangles overlap, which it doesn't.
                 */ if (layerInfo.moveImage) (0, _cpblendJsDefault.default).normalFuseImageOntoImageAtPosition(layerInfo.layer.image, layerInfo.imageUndo, destRectUnclipped.left, destRectUnclipped.top, this.srcRect);
                if (layerInfo.moveMask) layerInfo.layer.mask.copyBitmapRect(layerInfo.maskUndo, destRectUnclipped.left, destRectUnclipped.top, this.srcRect);
            });
            invalidateRegion.union(this.dstRect);
            invalidateLayer(this.movingLayers.map((layerInfo)=>layerInfo.layer), invalidateRegion, true, true);
            if (!this.fromSelection.isEmpty()) {
                let toSelection = this.fromSelection.clone();
                toSelection.translate(this.offsetX, this.offsetY);
                that.setSelection(toSelection);
                callListenersSelectionChange();
            }
        }
        /**
         * Move further by the given offset on top of the current offset.
         *
         * @param {number} offsetX
         * @param {number} offsetY
         */ amend(offsetX, offsetY) {
            if (!this.hasFullUndo) this.undo();
            this.offsetX += offsetX;
            this.offsetY += offsetY;
            this.redo();
        }
    }
    /**
     * Cut the selected rectangle from the layer
     *
     * @param {CPImageLayer} layer - Layer to cut from
     * @param {boolean} cutFromMask - True to cut from the mask of the layer, false to cut from the image
     * @param {CPRect} selection - The cut rectangle co-ordinates
     */ function CPActionCut(layer, cutFromMask, selection) {
        const fromImage = cutFromMask ? layer.mask : layer.image, cutData = fromImage.cloneRect(selection);
        selection = selection.clone();
        this.undo = function() {
            fromImage.copyBitmapRect(cutData, selection.left, selection.top, cutData.getBounds());
            that.setActiveLayer(layer, cutFromMask);
            that.setSelection(selection);
            invalidateLayer(layer, selection, !cutFromMask, cutFromMask);
        };
        this.redo = function() {
            if (cutFromMask) fromImage.clearRect(selection, EMPTY_MASK_COLOR);
            else fromImage.clearRect(selection, EMPTY_LAYER_COLOR);
            clipboard = new (0, _cpclipJsDefault.default)(cutData, selection.left, selection.top);
            that.setActiveLayer(layer, cutFromMask);
            that.emptySelection();
            invalidateLayer(layer, selection, !cutFromMask, cutFromMask);
        };
        this.getMemoryUsed = function(undone, param) {
            return cutData == param ? 0 : cutData.getMemorySize();
        };
        this.redo();
    }
    CPActionCut.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
    CPActionCut.prototype.constructor = CPActionCut;
    /**
     * Paste the given clipboard onto the given layer.
     *
     * @param {CPClip} clip
     */ function CPActionPaste(clip) {
        const oldSelection = that.getSelection(), oldMask = maskEditingMode, newLayer = new (0, _cpimageLayerJsDefault.default)(that.width, that.height, that.getDefaultLayerName(false)), oldLayer = curLayer, parentGroup = oldLayer.parent;
        this.undo = function() {
            parentGroup.removeLayer(newLayer);
            that.setSelection(oldSelection);
            artworkStructureChanged();
            that.setActiveLayer(oldLayer, oldMask);
        };
        this.redo = function() {
            let layerIndex = parentGroup.indexOf(oldLayer), sourceRect = clip.bmp.getBounds(), x, y;
            parentGroup.insertLayer(layerIndex + 1, newLayer);
            if (sourceRect.isInside(that.getBounds())) {
                x = clip.x;
                y = clip.y;
            } else {
                x = (that.width - clip.bmp.width) / 2 | 0;
                y = (that.height - clip.bmp.height) / 2 | 0;
            }
            if (clip.bmp instanceof (0, _cpgreyBmpJsDefault.default)) {
                // Need to convert greyscale to color before we can paste
                let clone = new (0, _cpcolorBmpJsDefault.default)(clip.bmp.width, clip.bmp.height);
                clone.copyPixelsFromGreyscale(clip.bmp);
                newLayer.image.copyBitmapRect(clone, x, y, sourceRect);
            } else newLayer.image.copyBitmapRect(clip.bmp, x, y, sourceRect);
            that.emptySelection();
            artworkStructureChanged();
            that.setActiveLayer(newLayer, false);
        };
        this.getMemoryUsed = function(undone, param) {
            return clip.bmp == param ? 0 : clip.bmp.getMemorySize();
        };
        this.redo();
    }
    CPActionPaste.prototype = Object.create((0, _cpundoJsDefault.default).prototype);
    CPActionPaste.prototype.constructor = CPActionPaste;
    paintingModes = [
        (0, _cpbrushToolJs.CPBrushTool),
        (0, _cpbrushToolJs.CPBrushToolEraser),
        (0, _cpbrushToolJs.CPBrushToolDodge),
        (0, _cpbrushToolJs.CPBrushToolBurn),
        (0, _cpbrushToolJs.CPBrushToolWatercolor),
        (0, _cpbrushToolJs.CPBrushToolBlur),
        (0, _cpbrushToolJs.CPBrushToolSmudge),
        (0, _cpbrushToolJs.CPBrushToolOil)
    ].map((modeFunc)=>new modeFunc(strokeBuffer, strokedRegion));
    this.width = _width;
    this.height = _height;
}
CPArtwork.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
CPArtwork.prototype.constructor = CPArtwork;
CPArtwork.prototype.getBounds = function() {
    return new (0, _cprectJsDefault.default)(0, 0, this.width, this.height);
};
CPArtwork.prototype.isPointWithin = function(x, y) {
    return x >= 0 && y >= 0 && x < this.width && y < this.height;
};
CPArtwork.EDITING_MODE_IMAGE = 0;
CPArtwork.EDITING_MODE_MASK = 1;

},{"./CPImageLayer.js":"93gOf","./CPLayerGroup.js":"k5mD3","./CPBlend.js":"k5HfA","./CPBlendAdditional.js":"dA7oJ","./CPGreyBmp.js":"fGKWG","./CPBlendTree.js":"92wgz","./CPMaskView.js":"iy9lO","./CPColorBmp.js":"5rykl","./CPBrushManager.js":"ebcUl","./CPBrushInfo.js":"b7K5Z","./CPUndo.js":"iYRR9","./CPClip.js":"8PjxN","../util/CPColor.js":"ioCeM","../util/CPRect.js":"aDqvw","../util/CPRandom.js":"hX4pE","../util/CPTransform.js":"hM3oc","../util/CPPolyfill.js":"89GR9","../util/Canvas.js":"bniay","wolfy87-eventemitter":"gPUo0","./CPBrushTool.js":"ak7pj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"93gOf":[function(require,module,exports,__globalThis) {
/*
 ChickenPaint

 ChickenPaint is a translation of ChibiPaint from Java to JavaScript
 by Nicholas Sherlock / Chicken Smoothie.

 ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

 ChickenPaint is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 ChickenPaint is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPImageLayer);
var _cpcolorBmpJs = require("./CPColorBmp.js");
var _cpcolorBmpJsDefault = parcelHelpers.interopDefault(_cpcolorBmpJs);
var _cplayerJs = require("./CPLayer.js");
var _cplayerJsDefault = parcelHelpers.interopDefault(_cplayerJs);
var _cprectJs = require("../util/CPRect.js");
var _cprectJsDefault = parcelHelpers.interopDefault(_cprectJs);
function CPImageLayer(width, height, name) {
    (0, _cplayerJsDefault.default).call(this, name);
    if (width > 0 && height > 0) this.image = new (0, _cpcolorBmpJsDefault.default)(width, height);
    else this.image = null;
    /**
	 * True if this layer should be clipped onto the CPImageLayer beneath it.
	 *
	 * @type {boolean}
	 */ this.clip = false;
    /**
	 *
	 * @type {?CPColorBmp}
	 */ this.imageThumbnail = null;
}
CPImageLayer.prototype = Object.create((0, _cplayerJsDefault.default).prototype);
CPImageLayer.prototype.constructor = CPImageLayer;
CPImageLayer.createFromImage = function(image, name) {
    let result = new CPImageLayer(0, 0, name);
    result.image = image;
    return result;
};
/**
 * Returns an independent copy of this layer.
 *
 * @returns {CPImageLayer}
 */ CPImageLayer.prototype.clone = function() {
    var result = new CPImageLayer(0, 0, this.name);
    result.copyFrom(this);
    return result;
};
/**
 *
 * @param {CPImageLayer} layer
 */ CPImageLayer.prototype.copyFrom = function(layer) {
    (0, _cplayerJsDefault.default).prototype.copyFrom.call(this, layer);
    this.clip = layer.clip;
    if (!this.image) this.image = layer.image.clone();
    else this.image.copyPixelsFrom(layer.image);
};
/**
 * Do we have any non-opaque pixels in the entire layer?
 */ CPImageLayer.prototype.hasAlpha = function() {
    if (this.alpha != 100) return true;
    return this.image.hasAlpha();
};
/**
 * Do we have any semi-transparent pixels in the given rectangle?
 *
 * @param {CPRect} rect
 * @returns {boolean}
 */ CPImageLayer.prototype.hasAlphaInRect = function(rect) {
    if (this.alpha != 100) return true;
    return this.image.hasAlphaInRect(rect);
};
/**
 *
 * @param {CPColorBmp} that
 */ CPImageLayer.prototype.copyImageFrom = function(that) {
    this.image.copyPixelsFrom(that);
};
/**
 * If this layer is clipped, return the layer that this layer is clipped to, otherwise return null.
 *
 * @returns {CPImageLayer}
 */ CPImageLayer.prototype.getClippingBase = function() {
    if (this.clip && this.parent) for(var i = this.parent.indexOf(this) - 1; i >= 0; i--){
        if (this.parent.layers[i] instanceof CPImageLayer) {
            if (!this.parent.layers[i].clip) return this.parent.layers[i];
        } else break;
    }
    return null;
};
/**
 *
 * @returns {boolean}
 */ CPImageLayer.prototype.getClip = function() {
    return this.clip;
};
/**
 *
 * @param {boolean} clip
 */ CPImageLayer.prototype.setClip = function(clip) {
    this.clip = clip;
};
/**
 * Get a rectangle that encloses any non-transparent pixels in the layer within the given initialBounds (or an empty
 * rect if the pixels inside the given bounds are 100% transparent).
 *
 * Ignores the layer alpha and visibility properties, you may want to check .getEffectiveAlpha() > 0 before calling.
 *
 * @param {CPRect} initialBounds - The rect to search within
 *
 * @returns {CPRect}
 */ CPImageLayer.prototype.getNonTransparentBounds = function(initialBounds) {
    return this.image.getNonTransparentBounds(initialBounds);
};
/**
 * @returns {CPRect}
 */ CPImageLayer.prototype.getBounds = function() {
    return new (0, _cprectJsDefault.default)(0, 0, this.image.width, this.image.height);
};
/**
 * Get an approximation of the number of bytes of memory used by this layer.
 *
 * @returns {number}
 */ CPImageLayer.prototype.getMemoryUsed = function() {
    return this.image ? this.image.getMemorySize() : 0;
};
/**
 * Recreate the image thumbnail for this layer.
 */ CPImageLayer.prototype.rebuildImageThumbnail = function() {
    if (!this.imageThumbnail) {
        var scaleDivider = Math.ceil(Math.max(this.image.width / (0, _cplayerJsDefault.default).LAYER_THUMBNAIL_WIDTH, this.image.height / (0, _cplayerJsDefault.default).LAYER_THUMBNAIL_HEIGHT));
        this.imageThumbnail = new (0, _cpcolorBmpJsDefault.default)(Math.floor(this.image.width / scaleDivider), Math.floor(this.image.height / scaleDivider));
    }
    this.imageThumbnail.createThumbnailFrom(this.image);
};
/**
 * Get the image thumbnail for this layer (or build one if one was not already built)
 *
 * @returns {CPColorBmp}
 */ CPImageLayer.prototype.getImageThumbnail = function() {
    if (!this.imageThumbnail) this.rebuildImageThumbnail();
    return this.imageThumbnail;
};

},{"./CPColorBmp.js":"5rykl","./CPLayer.js":"1fr05","../util/CPRect.js":"aDqvw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5rykl":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPColorBmp);
/**
 * Returns a new canvas with a rotated version of the given canvas.
 *
 * @param {HTMLCanvasElement} canvas
 * @param {number} rotation - [0..3], selects a multiple of 90 degrees of clockwise rotation to be applied.
 */ parcelHelpers.export(exports, "getRotatedCanvas", ()=>getRotatedCanvas);
var _cpbitmapJs = require("./CPBitmap.js");
var _cpbitmapJsDefault = parcelHelpers.interopDefault(_cpbitmapJs);
var _cprectJs = require("../util/CPRect.js");
var _cprectJsDefault = parcelHelpers.interopDefault(_cprectJs);
var _canvasJs = require("../util/Canvas.js");
function CPColorBmp(width, height) {
    if (typeof width == "number") {
        (0, _cpbitmapJsDefault.default).call(this, width, height);
        this.imageData = (0, _canvasJs.createImageData)(this.width, this.height);
    } else {
        var imageData = width;
        (0, _cpbitmapJsDefault.default).call(this, imageData.width, imageData.height);
        this.imageData = imageData;
    }
    this.data = this.imageData.data;
}
CPColorBmp.prototype = Object.create((0, _cpbitmapJsDefault.default).prototype);
CPColorBmp.prototype.constructor = CPColorBmp;
CPColorBmp.BYTES_PER_PIXEL = 4;
CPColorBmp.RED_BYTE_OFFSET = 0;
CPColorBmp.GREEN_BYTE_OFFSET = 1;
CPColorBmp.BLUE_BYTE_OFFSET = 2;
CPColorBmp.ALPHA_BYTE_OFFSET = 3;
/**
 * Create an independent copy of this bitmap.
 *
 * @returns {CPColorBmp}
 */ CPColorBmp.prototype.clone = function() {
    return this.cloneRect(this.getBounds());
};
/**
 * Creates a CPColorBmp from a portion of this bitmap
 *
 * @param {CPRect} rect
 * @returns {CPColorBmp}
 */ CPColorBmp.prototype.cloneRect = function(rect) {
    var result = new CPColorBmp(rect.getWidth(), rect.getHeight());
    result.copyBitmapRect(this, 0, 0, rect);
    return result;
};
/**
 * Pixel access with friendly clipping.
 *
 * @returns {number} 32-bit integer in ARGB format
 */ CPColorBmp.prototype.getPixel = function(x, y) {
    x = Math.max(0, Math.min(this.width - 1, x));
    y = Math.max(0, Math.min(this.height - 1, y));
    var pixIndex = this.offsetOfPixel(x, y);
    return this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] << 24 | this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] << 16 | this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] << 8 | this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET];
};
/**
 * Get an r,g,b,a array of the xor of this bitmap and the given one, within the given rectangle
 *
 * @param {CPColorBmp} bmp
 * @param {CPRect} rect
 *
 * @returns {Uint8Array}
 */ CPColorBmp.prototype.copyRectXOR = function(bmp, rect) {
    rect = this.getBounds().clipTo(rect);
    var w = rect.getWidth(), h = rect.getHeight(), buffer = new Uint8Array(w * h * CPColorBmp.BYTES_PER_PIXEL), outputIndex = 0, bmp1Index = this.offsetOfPixel(rect.left, rect.top), bmp2Index = bmp.offsetOfPixel(rect.left, rect.top), bmp1YSkip = (this.width - w) * CPColorBmp.BYTES_PER_PIXEL, bmp2YSkip = (bmp.width - w) * CPColorBmp.BYTES_PER_PIXEL, widthBytes = w * CPColorBmp.BYTES_PER_PIXEL;
    for(var y = rect.top; y < rect.bottom; y++, bmp1Index += bmp1YSkip, bmp2Index += bmp2YSkip)for(var x = 0; x < widthBytes; x++, outputIndex++, bmp1Index++, bmp2Index++)buffer[outputIndex] = this.data[bmp1Index] ^ bmp.data[bmp2Index];
    return buffer;
};
CPColorBmp.prototype.setRectXOR = function(buffer, rect) {
    rect = this.getBounds().clipTo(rect);
    var w = rect.getWidth(), h = rect.getHeight(), bmp1Index = this.offsetOfPixel(rect.left, rect.top), bufferIndex = 0, bmp1YSkip = (this.width - w) * CPColorBmp.BYTES_PER_PIXEL, widthBytes = w * CPColorBmp.BYTES_PER_PIXEL;
    for(var y = 0; y < h; y++){
        for(var x = 0; x < widthBytes; x++)this.data[bmp1Index++] ^= buffer[bufferIndex++];
        bmp1Index += bmp1YSkip;
    }
};
/** 
 * Copy the rectangle at srcRect from bmp onto this image at (dstX, dstY).
 *
 * @param {CPColorBmp} bmp
 * @param {number} dstX
 * @param {number} dstY
 * @param {CPRect} srcRect
 */ CPColorBmp.prototype.copyBitmapRect = function(bmp, dstX, dstY, srcRect) {
    var dstRect = new (0, _cprectJsDefault.default)(dstX, dstY, 0, 0);
    srcRect = srcRect.clone();
    this.getBounds().clipSourceDest(srcRect, dstRect);
    var w = dstRect.getWidth() | 0, h = dstRect.getHeight() | 0;
    // Are we just trying to duplicate the bitmap?
    if (dstRect.left == 0 && dstRect.top == 0 && w == this.width && h == this.height && w == bmp.width && h == bmp.height) this.copyPixelsFrom(bmp);
    else {
        var dstIndex = this.offsetOfPixel(dstRect.left, dstRect.top), dstYSkip = (this.width - w) * CPColorBmp.BYTES_PER_PIXEL, srcIndex = bmp.offsetOfPixel(srcRect.left, srcRect.top), srcYSkip = (bmp.width - w) * CPColorBmp.BYTES_PER_PIXEL;
        for(var y = 0; y < h; y++, srcIndex += srcYSkip, dstIndex += dstYSkip)for(var x = 0; x < w; x++, srcIndex += CPColorBmp.BYTES_PER_PIXEL, dstIndex += CPColorBmp.BYTES_PER_PIXEL){
            this.data[dstIndex] = bmp.data[srcIndex];
            this.data[dstIndex + 1] = bmp.data[srcIndex + 1];
            this.data[dstIndex + 2] = bmp.data[srcIndex + 2];
            this.data[dstIndex + 3] = bmp.data[srcIndex + 3];
        }
    }
};
//
// Copies the Alpha channel from another bitmap. Assumes both bitmaps are the same width.
//
CPColorBmp.prototype.copyAlphaFrom = function(bmp, rect) {
    rect = this.getBounds().clipTo(rect);
    var w = rect.getWidth() | 0, h = rect.getHeight() | 0, pixIndex = this.offsetOfPixel(rect.left, rect.top) + CPColorBmp.ALPHA_BYTE_OFFSET | 0 /* Apply offset here so we don't have to do it per-pixel*/ , ySkip = (this.width - w) * CPColorBmp.BYTES_PER_PIXEL | 0;
    for(var y = 0; y < h; y++, pixIndex += ySkip)for(var x = 0; x < w; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL)this.data[pixIndex] = bmp.data[pixIndex];
};
/**
 * Resize this bitmap to be the same size as that one
 *
 * @param {CPBitmap} bmp
 */ CPColorBmp.prototype.setToSize = function(bmp) {
    if (bmp.width != this.width || bmp.height != this.height) {
        this.width = bmp.width;
        this.height = bmp.height;
        this.imageData = (0, _canvasJs.createImageData)(this.width, this.height);
        this.data = this.imageData.data;
    }
};
/**
 *
 * @param {CPColorBmp} bmp
 */ CPColorBmp.prototype.copyPixelsFrom = function(bmp) {
    this.setToSize(bmp);
    if ("set" in this.data) this.data.set(bmp.data);
    else // IE doesn't use Uint8ClampedArray for ImageData, so set() isn't available
    for(var i = 0; i < this.data.length; i++)this.data[i] = bmp.data[i];
};
CPColorBmp.prototype.copyPixelsFromGreyscale = function(bmp) {
    var srcIndex, dstIndex = 0, pixels = bmp.width * bmp.height;
    this.setToSize(bmp);
    for(srcIndex = 0; srcIndex < pixels; srcIndex++, dstIndex += CPColorBmp.BYTES_PER_PIXEL){
        this.data[dstIndex + CPColorBmp.RED_BYTE_OFFSET] = bmp.data[srcIndex];
        this.data[dstIndex + CPColorBmp.GREEN_BYTE_OFFSET] = bmp.data[srcIndex];
        this.data[dstIndex + CPColorBmp.BLUE_BYTE_OFFSET] = bmp.data[srcIndex];
        this.data[dstIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = 0xFF;
    }
};
/**
 * Use nearest-neighbor (subsampling) to scale that bitmap to replace the pixels of this one.
 *
 * @param {CPColorBmp} that
 */ CPColorBmp.prototype.copyScaledNearestNeighbor = function(that) {
    var destPixIndex = 0, xSkip = that.width / this.width, ySkip = that.height / this.height, srcRowStart;
    for(var y = 0, srcRow = 0; y < this.height; y++, srcRow += ySkip){
        srcRowStart = that.offsetOfPixel(0, Math.round(srcRow));
        for(var x = 0, srcCol = 0; x < this.width; x++, destPixIndex += CPColorBmp.BYTES_PER_PIXEL, srcCol += xSkip){
            var srcPixIndex = srcRowStart + Math.round(srcCol) * CPColorBmp.BYTES_PER_PIXEL;
            this.data[destPixIndex] = that.data[srcPixIndex];
            this.data[destPixIndex + 1] = that.data[srcPixIndex + 1];
            this.data[destPixIndex + 2] = that.data[srcPixIndex + 2];
            this.data[destPixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = that.data[srcPixIndex + CPColorBmp.ALPHA_BYTE_OFFSET];
        }
    }
};
/**
 * Replace the pixels in this image with a scaled down thumbnail of that image.
 *
 * The thumbnail will attempt to exaggerate the contribution of thin opaque strokes on a transparent background, in order
 * to make lineart layers more visible.
 *
 * @param {CPColorBmp} that
 */ CPColorBmp.prototype.createThumbnailFrom = function(that) {
    const MAX_SAMPLES_PER_OUTPUT_PIXEL = 3, numSamples = Math.min(Math.floor(that.width / this.width), MAX_SAMPLES_PER_OUTPUT_PIXEL);
    if (numSamples < 2) {
        // If we only take one sample per output pixel, there's no need for our filtering strategy
        this.copyScaledNearestNeighbor(that);
        return;
    }
    const // Uint16 means we can have up to 16 (since 16*16 ~= 65535/255) times scale reduction without overflow
    rowBuffer = new Uint16Array(this.width * 5 /* 4 bytes of RGBA plus one to record the max alpha of the samples */ ), srcRowByteLength = that.width * CPColorBmp.BYTES_PER_PIXEL, sourceBytesBetweenOutputCols = Math.floor(that.width / this.width) * CPColorBmp.BYTES_PER_PIXEL, intersampleXByteSpacing = Math.floor(that.width / this.width / numSamples) * CPColorBmp.BYTES_PER_PIXEL, /* Due to the floor() in intersampleXByteSkip, it's likely that the gap between the last sample for an output pixel
     * and the start of the sample for the next pixel will be higher than the intersample gap. So we'll add this between
     * pixels if needed.
     */ interpixelXByteSkip = sourceBytesBetweenOutputCols - intersampleXByteSpacing * numSamples, // Now we do the same for rows...
    sourceRowsBetweenOutputRows = Math.floor(that.height / this.height), intersampleYRowsSpacing = Math.floor(that.height / this.height / numSamples), intersampleYByteSkip = intersampleYRowsSpacing * srcRowByteLength - sourceBytesBetweenOutputCols * this.width, interpixelYByteSkip = (sourceRowsBetweenOutputRows - intersampleYRowsSpacing * numSamples) * srcRowByteLength;
    let srcPixIndex = 0, dstPixIndex = 0;
    // For each output thumbnail row...
    for(let y = 0; y < this.height; y++, srcPixIndex += interpixelYByteSkip){
        let bufferIndex = 0;
        rowBuffer.fill(0);
        // Sum the contributions of the input rows that correspond to this output row
        for(let y2 = 0; y2 < numSamples; y2++, srcPixIndex += intersampleYByteSkip){
            bufferIndex = 0;
            for(let x = 0; x < this.width; x++, bufferIndex += 5, srcPixIndex += interpixelXByteSkip)for(let x2 = 0; x2 < numSamples; x2++, srcPixIndex += intersampleXByteSpacing){
                let sourceAlpha = that.data[srcPixIndex + CPColorBmp.ALPHA_BYTE_OFFSET], sourceAlphaScale = sourceAlpha / 255;
                // Accumulate the pre-multiplied pixels in the sample area
                rowBuffer[bufferIndex] += that.data[srcPixIndex] * sourceAlphaScale;
                rowBuffer[bufferIndex + 1] += that.data[srcPixIndex + 1] * sourceAlphaScale;
                rowBuffer[bufferIndex + 2] += that.data[srcPixIndex + 2] * sourceAlphaScale;
                rowBuffer[bufferIndex + CPColorBmp.ALPHA_BYTE_OFFSET] += sourceAlpha;
                // And keep track of the highest alpha we see
                rowBuffer[bufferIndex + 4] = Math.max(rowBuffer[bufferIndex + 4], sourceAlpha);
            }
        }
        // Now this thumbnail row is complete and we can write the buffer to the output
        bufferIndex = 0;
        for(let x = 0; x < this.width; x++, bufferIndex += 5, dstPixIndex += CPColorBmp.BYTES_PER_PIXEL){
            let maxAlphaForSample = rowBuffer[bufferIndex + 4];
            if (maxAlphaForSample == 0) this.data[dstPixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = 0;
            else {
                // Undo the premultiplication of the pixel data, scaling it to the max() alpha we want
                let sampleAlphaScale = maxAlphaForSample / rowBuffer[bufferIndex + CPColorBmp.ALPHA_BYTE_OFFSET];
                this.data[dstPixIndex] = rowBuffer[bufferIndex] * sampleAlphaScale;
                this.data[dstPixIndex + 1] = rowBuffer[bufferIndex + 1] * sampleAlphaScale;
                this.data[dstPixIndex + 2] = rowBuffer[bufferIndex + 2] * sampleAlphaScale;
                this.data[dstPixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = maxAlphaForSample;
            }
        }
    }
};
/**
 * Flood fill the given color starting from the given point
 * @param x int
 * @param y int
 * @param color int
 */ CPColorBmp.prototype.floodFill = function(x, y, color) {
    if (!this.isInside(x, y)) return;
    let oldColor = this.getPixel(x, y), oldAlpha = oldColor >> 24 & 0xFF, oldRed = oldColor >> 16 & 0xFF, oldGreen = oldColor >> 8 & 0xFF, oldBlue = oldColor & 0xFF, colorAlpha = color >> 24 & 0xFF, colorRed = color >> 16 & 0xFF, colorGreen = color >> 8 & 0xFF, colorBlue = color & 0xFF, stack = [], clip = this.getBounds(), data = this.data;
    // Change the left and right bounds from pixel indexes into byte indexes for easy clipping
    clip.left *= CPColorBmp.BYTES_PER_PIXEL;
    clip.right *= CPColorBmp.BYTES_PER_PIXEL;
    stack.push({
        x1: x * CPColorBmp.BYTES_PER_PIXEL,
        x2: x * CPColorBmp.BYTES_PER_PIXEL,
        y: y,
        dy: -1
    });
    stack.push({
        x1: x * CPColorBmp.BYTES_PER_PIXEL,
        x2: x * CPColorBmp.BYTES_PER_PIXEL,
        y: y + 1,
        dy: 1
    });
    /* 
     * If we are filling 100% transparent areas then we need to ignore the residual color information
     * (it would also be possible to clear it when erasing, but then the performance impact would be on the eraser 
     * rather than on this low importance flood fill)
     */ if (oldAlpha == 0) {
        if (colorAlpha == 0) return;
        while(stack.length > 0){
            let line = stack.pop();
            if (line.y < clip.top || line.y >= clip.bottom) continue;
            let lineOffset = this.offsetOfPixel(0, line.y), left = line.x1, next;
            while(left >= clip.left && data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] == 0){
                data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] = colorRed;
                data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] = colorGreen;
                data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] = colorBlue;
                data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] = colorAlpha;
                left -= CPColorBmp.BYTES_PER_PIXEL;
            }
            if (left >= line.x1) {
                while(left <= line.x2 && data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] != oldAlpha)left += CPColorBmp.BYTES_PER_PIXEL;
                next = left + CPColorBmp.BYTES_PER_PIXEL;
                if (left > line.x2) continue;
            } else {
                left += CPColorBmp.BYTES_PER_PIXEL;
                if (left < line.x1) stack.push({
                    x1: left,
                    x2: line.x1 - CPColorBmp.BYTES_PER_PIXEL,
                    y: line.y - line.dy,
                    dy: -line.dy
                });
                next = line.x1 + CPColorBmp.BYTES_PER_PIXEL;
            }
            do {
                data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] = colorRed;
                data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] = colorGreen;
                data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] = colorBlue;
                data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] = colorAlpha;
                while(next < clip.right && data[next + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] == oldAlpha){
                    data[next + lineOffset + CPColorBmp.RED_BYTE_OFFSET] = colorRed;
                    data[next + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] = colorGreen;
                    data[next + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] = colorBlue;
                    data[next + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] = colorAlpha;
                    next += CPColorBmp.BYTES_PER_PIXEL;
                }
                stack.push({
                    x1: left,
                    x2: next - CPColorBmp.BYTES_PER_PIXEL,
                    y: line.y + line.dy,
                    dy: line.dy
                });
                if (next - CPColorBmp.BYTES_PER_PIXEL > line.x2) stack.push({
                    x1: line.x2 + CPColorBmp.BYTES_PER_PIXEL,
                    x2: next - CPColorBmp.BYTES_PER_PIXEL,
                    y: line.y - line.dy,
                    dy: -line.dy
                });
                left = next + CPColorBmp.BYTES_PER_PIXEL;
                while(left <= line.x2 && data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] != oldAlpha)left += CPColorBmp.BYTES_PER_PIXEL;
                next = left + CPColorBmp.BYTES_PER_PIXEL;
            }while (left <= line.x2);
        }
    } else {
        if (color == oldColor) return;
        while(stack.length > 0){
            let line = stack.pop();
            if (line.y < clip.top || line.y >= clip.bottom) continue;
            let lineOffset = this.offsetOfPixel(0, line.y), left = line.x1, next;
            while(left >= clip.left && data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] == oldRed && data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] == oldGreen && data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] == oldBlue && data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] == oldAlpha){
                data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] = colorRed;
                data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] = colorGreen;
                data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] = colorBlue;
                data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] = colorAlpha;
                left -= CPColorBmp.BYTES_PER_PIXEL;
            }
            if (left >= line.x1) {
                while(left <= line.x2 && !(data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] == oldRed && data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] == oldGreen && data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] == oldBlue && data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] == oldAlpha))left += CPColorBmp.BYTES_PER_PIXEL;
                next = left + CPColorBmp.BYTES_PER_PIXEL;
                if (left > line.x2) continue;
            } else {
                left += CPColorBmp.BYTES_PER_PIXEL;
                if (left < line.x1) stack.push({
                    x1: left,
                    x2: line.x1 - CPColorBmp.BYTES_PER_PIXEL,
                    y: line.y - line.dy,
                    dy: -line.dy
                });
                next = line.x1 + CPColorBmp.BYTES_PER_PIXEL;
            }
            do {
                data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] = colorRed;
                data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] = colorGreen;
                data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] = colorBlue;
                data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] = colorAlpha;
                while(next < clip.right && data[next + lineOffset + CPColorBmp.RED_BYTE_OFFSET] == oldRed && data[next + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] == oldGreen && data[next + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] == oldBlue && data[next + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] == oldAlpha){
                    data[next + lineOffset + CPColorBmp.RED_BYTE_OFFSET] = colorRed;
                    data[next + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] = colorGreen;
                    data[next + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] = colorBlue;
                    data[next + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] = colorAlpha;
                    next += CPColorBmp.BYTES_PER_PIXEL;
                }
                stack.push({
                    x1: left,
                    x2: next - CPColorBmp.BYTES_PER_PIXEL,
                    y: line.y + line.dy,
                    dy: line.dy
                });
                if (next - CPColorBmp.BYTES_PER_PIXEL > line.x2) stack.push({
                    x1: line.x2 + CPColorBmp.BYTES_PER_PIXEL,
                    x2: next - CPColorBmp.BYTES_PER_PIXEL,
                    y: line.y - line.dy,
                    dy: -line.dy
                });
                left = next + CPColorBmp.BYTES_PER_PIXEL;
                while(left <= line.x2 && !(data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] == oldRed && data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] == oldGreen && data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] == oldBlue && data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] == oldAlpha))left += CPColorBmp.BYTES_PER_PIXEL;
                next = left + CPColorBmp.BYTES_PER_PIXEL;
            }while (left <= line.x2);
        }
    }
};
/**
 * Premultiply the RGB channels in the given R,G,B,A channel buffer with the alpha channel.
 * 
 * @param {Uint8Array} buffer - buffer R,G,B,A channel array
 * @param {number} len - Number of pixels in buffer to modify
 */ function multiplyAlpha(buffer, len) {
    var pixIndex = 0;
    for(var i = 0; i < len; i++){
        var alpha = buffer[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET];
        // Multiply the RGB channels by alpha
        for(var j = 0; j < 3; j++, pixIndex++)buffer[pixIndex] = Math.round(buffer[pixIndex] * alpha / 255);
        pixIndex++; // Don't modify alpha channel
    }
}
/**
 * Inverse of multiplyAlpha()
 */ function separateAlpha(buffer, len) {
    var pixIndex = 0;
    for(var i = 0; i < len; i++){
        var alpha = buffer[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET];
        if (alpha != 0) {
            var invAlpha = 255 / alpha;
            for(var j = 0; j < 3; j++, pixIndex++)buffer[pixIndex] = Math.min(Math.round(buffer[pixIndex] * invAlpha), 255);
            // Don't modify alpha channel
            pixIndex++;
        } else pixIndex += CPColorBmp.BYTES_PER_PIXEL;
    }
}
/**
 * Blur the first `len` pixels in the src array by `radius` pixels, and store the result in the `dst` array.
 *
 * @param {Uint8Array} src
 * @param {Uint8Array} dst
 * @param {number} len
 * @param {number} radius - Number of pixels that will be averaged either side of a target pixel.
 */ function boxBlurLine(src, dst, len, radius) {
    var pixelCount = 0, channelSums = [
        0,
        0,
        0,
        0
    ], pixIndex, dstIndex;
    pixIndex = 0;
    for(let i = 0; i < radius && i < len; i++){
        for(let j = 0; j < CPColorBmp.BYTES_PER_PIXEL; j++)channelSums[j] += src[pixIndex++];
        pixelCount++;
    }
    dstIndex = 0;
    for(let i = 0; i < len; i++){
        // New pixel joins the window at the right
        if (i + radius < len) {
            pixIndex = (i + radius) * CPColorBmp.BYTES_PER_PIXEL;
            for(let j = 0; j < CPColorBmp.BYTES_PER_PIXEL; j++)channelSums[j] += src[pixIndex++];
            pixelCount++;
        }
        for(let j = 0; j < CPColorBmp.BYTES_PER_PIXEL; j++)dst[dstIndex++] = Math.round(channelSums[j] / pixelCount);
        // Old pixel leaves the window at the left
        if (i - radius >= 0) {
            pixIndex = (i - radius) * CPColorBmp.BYTES_PER_PIXEL;
            for(let j = 0; j < CPColorBmp.BYTES_PER_PIXEL; j++)channelSums[j] -= src[pixIndex++];
            pixelCount--;
        }
    }
}
/**
 * Copy a column of pixels in the bitmap to the given R,G,B,A buffer.
 * 
 * @param {number} x X-coordinate of column
 * @param {number} y Y-coordinate of top of column to copy
 * @param {number} len Number of pixels to copy
 * @param {Uint8Array} buffer R,G,B,A array
 */ CPColorBmp.prototype.copyPixelColumnToArray = function(x, y, len, buffer) {
    var yJump = (this.width - 1) * CPColorBmp.BYTES_PER_PIXEL, dstOffset = 0, srcOffset = this.offsetOfPixel(x, y);
    for(var i = 0; i < len; i++){
        for(var j = 0; j < CPColorBmp.BYTES_PER_PIXEL; j++)buffer[dstOffset++] = this.data[srcOffset++];
        srcOffset += yJump;
    }
};
/**
 * Copy the pixels from the given R,G,B,A buffer to a column of pixels in the bitmap.
 * 
 * @param {number} x X-coordinate of column
 * @param {number} y Y-coordinate of top of column to copy
 * @param {number} len Number of pixels to copy
 * @param {Uint8Array} buffer R,G,B,A array to copy from
 */ CPColorBmp.prototype.copyArrayToPixelColumn = function(x, y, len, buffer) {
    var yJump = (this.width - 1) * CPColorBmp.BYTES_PER_PIXEL, srcOffset = 0, dstOffset = this.offsetOfPixel(x, y);
    for(var i = 0; i < len; i++){
        for(var j = 0; j < CPColorBmp.BYTES_PER_PIXEL; j++)this.data[dstOffset++] = buffer[srcOffset++];
        dstOffset += yJump;
    }
};
CPColorBmp.prototype.boxBlur = function(rect, radiusX, radiusY) {
    rect = this.getBounds().clipTo(rect);
    let rectWidth = rect.getWidth(), rectWidthBytes = rectWidth * CPColorBmp.BYTES_PER_PIXEL, rectHeight = rect.getHeight(), rectLength = Math.max(rectWidth, rectHeight), src = new Uint8Array(rectLength * CPColorBmp.BYTES_PER_PIXEL), dst = new Uint8Array(rectLength * CPColorBmp.BYTES_PER_PIXEL);
    // 横方向のぼかし
    for(let y = rect.top; y < rect.bottom; y++){
        var pixOffset = this.offsetOfPixel(rect.left, y);
        // ピクセルデータをコピー
        for(let x = 0; x < rectWidthBytes; x++)src[x] = this.data[pixOffset++];
        // 透明部分を考慮してアルファを掛ける
        multiplyAlpha(src, rectWidth);
        // ぼかし処理
        boxBlurLine(src, dst, rectWidth, radiusX);
        // 結果を元のデータにコピー
        pixOffset = this.offsetOfPixel(rect.left, y);
        for(let x = 0; x < rectWidthBytes; x++)this.data[pixOffset++] = dst[x];
    }
    // 縦方向のぼかし
    for(let x = rect.left; x < rect.right; x++){
        this.copyPixelColumnToArray(x, rect.top, rectHeight, src);
        // 縦方向のぼかし処理
        boxBlurLine(src, dst, rectHeight, radiusY);
        // 透明部分を分離して再設定
        separateAlpha(dst, rectHeight);
        this.copyArrayToPixelColumn(x, rect.top, rectHeight, dst);
    }
};
CPColorBmp.prototype.offsetOfPixel = function(x, y) {
    return (y * this.width + x) * 4 | 0;
};
CPColorBmp.prototype.getMemorySize = function() {
    return this.data.length;
};
CPColorBmp.prototype.getImageData = function() {
    return this.imageData;
};
/**
 * Replace the image data with the provided ImageData object (i.e. use it by reference).
 *
 * @param imageData {ImageData}
 */ CPColorBmp.prototype.setImageData = function(imageData) {
    this.width = imageData.width;
    this.height = imageData.height;
    this.imageData = imageData;
    this.data = imageData.data;
};
CPColorBmp.prototype.clearAll = function(color) {
    if (color == 0 && "fill" in this.data) this.data.fill(0);
    else {
        var a = color >> 24 & 0xFF, r = color >> 16 & 0xFF, g = color >> 8 & 0xFF, b = color & 0xFF;
        for(var i = 0; i < this.width * this.height * CPColorBmp.BYTES_PER_PIXEL;){
            this.data[i++] = r;
            this.data[i++] = g;
            this.data[i++] = b;
            this.data[i++] = a;
        }
    }
};
/**
 *
 * @param {CPRect} rect
 * @param {number} color
 */ CPColorBmp.prototype.clearRect = function(rect, color) {
    rect = this.getBounds().clipTo(rect);
    var a = color >> 24 & 0xFF, r = color >> 16 & 0xFF, g = color >> 8 & 0xFF, b = color & 0xFF, yStride = (this.width - rect.getWidth()) * CPColorBmp.BYTES_PER_PIXEL, pixIndex = this.offsetOfPixel(rect.left, rect.top);
    for(var y = rect.top; y < rect.bottom; y++, pixIndex += yStride)for(var x = rect.left; x < rect.right; x++){
        this.data[pixIndex++] = r;
        this.data[pixIndex++] = g;
        this.data[pixIndex++] = b;
        this.data[pixIndex++] = a;
    }
};
/**
 * @param rect CPRect
 * @param source CPColorBmp
 */ CPColorBmp.prototype.copyRegionHFlip = function(rect, source) {
    rect = this.getBounds().clipTo(rect);
    for(var y = rect.top; y < rect.bottom; y++){
        var dstOffset = this.offsetOfPixel(rect.left, y), srcOffset = source.offsetOfPixel(rect.right - 1, y);
        for(var x = rect.left; x < rect.right; x++, srcOffset -= CPColorBmp.BYTES_PER_PIXEL * 2)for(var i = 0; i < CPColorBmp.BYTES_PER_PIXEL; i++)this.data[dstOffset++] = source.data[srcOffset++];
    }
};
/**
 * @param rect CPRect
 * @param source CPColorBmp
 */ CPColorBmp.prototype.copyRegionVFlip = function(rect, source) {
    rect = this.getBounds().clipTo(rect);
    var widthBytes = rect.getWidth() * CPColorBmp.BYTES_PER_PIXEL;
    for(var y = rect.top; y < rect.bottom; y++){
        var dstOffset = this.offsetOfPixel(rect.left, y), srcOffset = source.offsetOfPixel(rect.left, rect.bottom - 1 - (y - rect.top));
        for(var x = 0; x < widthBytes; x++)this.data[dstOffset++] = source.data[srcOffset++];
    }
};
/**
 * @param {CPRect} rect
 */ CPColorBmp.prototype.fillWithNoise = function(rect) {
    rect = this.getBounds().clipTo(rect);
    var value, yStride = (this.width - rect.getWidth()) * CPColorBmp.BYTES_PER_PIXEL, pixIndex = this.offsetOfPixel(rect.left, rect.top);
    for(var y = rect.top; y < rect.bottom; y++, pixIndex += yStride)for(var x = rect.left; x < rect.right; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL){
        value = Math.random() * 0x100 | 0;
        this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] = value;
        this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] = value;
        this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET] = value;
        this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = 0xFF;
    }
};
/**
 * Replace the pixels in the given rect with the given horizontal gradient.
 *
 * @param rect CPRect
 * @param fromX int
 * @param toX int
 * @param gradientPoints int[]
 */ CPColorBmp.prototype.gradientHorzReplace = function(rect, fromX, toX, gradientPoints) {
    var fromColor = {
        r: gradientPoints[0] >> 16 & 0xFF,
        g: gradientPoints[0] >> 8 & 0xFF,
        b: gradientPoints[0] & 0xFF,
        a: gradientPoints[0] >> 24 & 0xFF
    }, toColor = {
        r: gradientPoints[1] >> 16 & 0xFF,
        g: gradientPoints[1] >> 8 & 0xFF,
        b: gradientPoints[1] & 0xFF,
        a: gradientPoints[1] >> 24 & 0xFF
    }, yStride = (this.width - rect.getWidth()) * CPColorBmp.BYTES_PER_PIXEL, pixIndex = this.offsetOfPixel(rect.left, rect.top) | 0, h = rect.bottom - rect.top | 0;
    if (toX < fromX) {
        var temp = toX;
        toX = fromX;
        fromX = temp;
        temp = fromColor;
        fromColor = toColor;
        toColor = temp;
    }
    var gradientRange = toX - fromX | 0, rStep = (toColor.r - fromColor.r) / gradientRange, gStep = (toColor.g - fromColor.g) / gradientRange, bStep = (toColor.b - fromColor.b) / gradientRange, aStep = (toColor.a - fromColor.a) / gradientRange, jump = Math.max(rect.left - fromX, 0);
    for(var y = 0; y < h; y++, pixIndex += yStride){
        // The solid color section before the gradient
        var x = rect.left;
        for(var xEnd = Math.min(fromX, rect.right) | 0; x < xEnd; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL){
            this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] = fromColor.r;
            this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] = fromColor.g;
            this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET] = fromColor.b;
            this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = fromColor.a;
        }
        // In the gradient
        var r = fromColor.r + rStep * jump, g = fromColor.g + gStep * jump, b = fromColor.b + bStep * jump, a = fromColor.a + aStep * jump;
        for(xEnd = Math.min(toX, rect.right) | 0; x < xEnd; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL){
            this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] = r;
            this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] = g;
            this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET] = b;
            this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = a;
            r += rStep;
            g += gStep;
            b += bStep;
            a += aStep;
        }
        // The section after the end of the gradient
        for(; x < rect.right; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL){
            this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] = toColor.r;
            this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] = toColor.g;
            this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET] = toColor.b;
            this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = toColor.a;
        }
    }
};
/**
 * Replace the pixels in the given rect with the given vertical gradient.
 *
 * @param {CPRect} rect
 * @param fromY int
 * @param toY int
 * @param gradientPoints int[]
 */ CPColorBmp.prototype.gradientVertReplace = function(rect, fromY, toY, gradientPoints) {
    let fromColor = {
        r: gradientPoints[0] >> 16 & 0xFF,
        g: gradientPoints[0] >> 8 & 0xFF,
        b: gradientPoints[0] & 0xFF,
        a: gradientPoints[0] >> 24 & 0xFF
    }, toColor = {
        r: gradientPoints[1] >> 16 & 0xFF,
        g: gradientPoints[1] >> 8 & 0xFF,
        b: gradientPoints[1] & 0xFF,
        a: gradientPoints[1] >> 24 & 0xFF
    }, yStride = (this.width - rect.getWidth()) * CPColorBmp.BYTES_PER_PIXEL, pixIndex = this.offsetOfPixel(rect.left, rect.top) | 0, w = rect.right - rect.left | 0;
    if (toY < fromY) {
        let temp = toY;
        toY = fromY;
        fromY = temp;
        temp = fromColor;
        fromColor = toColor;
        toColor = temp;
    }
    let y = rect.top;
    // The solid color section before the start of the gradient
    for(let yEnd = Math.min(rect.bottom, fromY) | 0; y < yEnd; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL){
        this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] = fromColor.r;
        this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] = fromColor.g;
        this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET] = fromColor.b;
        this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = fromColor.a;
    }
    // Inside the gradient
    var gradientRange = toY - fromY | 0, rStep = (toColor.r - fromColor.r) / gradientRange, gStep = (toColor.g - fromColor.g) / gradientRange, bStep = (toColor.b - fromColor.b) / gradientRange, aStep = (toColor.a - fromColor.a) / gradientRange, jump = Math.max(y - fromY, 0), r = fromColor.r + rStep * jump, g = fromColor.g + gStep * jump, b = fromColor.b + bStep * jump, a = fromColor.a + aStep * jump;
    for(let yEnd = Math.min(rect.bottom, toY) | 0; y < yEnd; y++, pixIndex += yStride){
        for(let x = 0; x < w; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL){
            this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] = r;
            this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] = g;
            this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET] = b;
            this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = a;
        }
        r += rStep;
        g += gStep;
        b += bStep;
        a += aStep;
    }
    // The section after the end of the gradient
    for(; y < rect.bottom; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL){
        this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] = toColor.r;
        this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] = toColor.g;
        this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET] = toColor.b;
        this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = toColor.a;
    }
};
/**
 * Replace the pixels in the given rect with the given gradient.
 *
 * @param rect CPRect
 * @param fromX int
 * @param fromY int
 * @param toX int
 * @param toY int
 * @param gradientPoints int[]
 */ CPColorBmp.prototype.gradientReplace = function(rect, fromX, fromY, toX, toY, gradientPoints) {
    var yStride = (this.width - rect.getWidth()) * CPColorBmp.BYTES_PER_PIXEL, pixIndex = this.offsetOfPixel(rect.left, rect.top) | 0, w = rect.right - rect.left | 0, fromColor = {
        r: gradientPoints[0] >> 16 & 0xFF,
        g: gradientPoints[0] >> 8 & 0xFF,
        b: gradientPoints[0] & 0xFF,
        a: gradientPoints[0] >> 24 & 0xFF
    }, toColor = {
        r: gradientPoints[1] >> 16 & 0xFF,
        g: gradientPoints[1] >> 8 & 0xFF,
        b: gradientPoints[1] & 0xFF,
        a: gradientPoints[1] >> 24 & 0xFF
    }, // How many pixels vertically does the gradient sequence complete over (+infinity for horizontal gradients!)
    vertRange = toY - fromY + (toX - fromX) * (toX - fromX) / (toY - fromY), // Same for horizontal
    horzRange = toX - fromX + (toY - fromY) * (toY - fromY) / (toX - fromX), horzStep = 1 / horzRange;
    for(var y = rect.top; y < rect.bottom; y++, pixIndex += yStride){
        var // The position the row starts at in the gradient [0.0 ... 1.0)
        prop = (rect.left - fromX) / horzRange + (y - fromY) / vertRange;
        for(var x = 0; x < w; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL){
            var propClamped = Math.min(Math.max(prop, 0.0), 1.0), invPropClamped = 1 - propClamped;
            this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] = fromColor.r * invPropClamped + toColor.r * propClamped;
            this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] = fromColor.g * invPropClamped + toColor.g * propClamped;
            this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET] = fromColor.b * invPropClamped + toColor.b * propClamped;
            this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = fromColor.a * invPropClamped + toColor.a * propClamped;
            prop += horzStep;
        }
    }
};
/**
 * Alpha blend the given gradient onto the pixels in the given rect.
 *
 * @param rect CPRect
 * @param fromX int
 * @param fromY int
 * @param toX int
 * @param toY int
 * @param gradientPoints int[]
 */ CPColorBmp.prototype.gradientAlpha = function(rect, fromX, fromY, toX, toY, gradientPoints) {
    var yStride = (this.width - rect.getWidth()) * CPColorBmp.BYTES_PER_PIXEL, pixIndex = this.offsetOfPixel(rect.left, rect.top) | 0, w = rect.right - rect.left | 0, fromColor = {
        r: gradientPoints[0] >> 16 & 0xFF,
        g: gradientPoints[0] >> 8 & 0xFF,
        b: gradientPoints[0] & 0xFF,
        a: gradientPoints[0] >> 24 & 0xFF
    }, toColor = {
        r: gradientPoints[1] >> 16 & 0xFF,
        g: gradientPoints[1] >> 8 & 0xFF,
        b: gradientPoints[1] & 0xFF,
        a: gradientPoints[1] >> 24 & 0xFF
    }, // How many pixels vertically does the gradient sequence complete over (+infinity for horizontal gradients!)
    vertRange = toY - fromY + (toX - fromX) * (toX - fromX) / (toY - fromY), // Same for horizontal
    horzRange = toX - fromX + (toY - fromY) * (toY - fromY) / (toX - fromX), horzStep = 1 / horzRange;
    for(var y = rect.top; y < rect.bottom; y++, pixIndex += yStride){
        var // The position the row starts at in the gradient [0.0 ... 1.0)
        prop = (rect.left - fromX) / horzRange + (y - fromY) / vertRange;
        for(var x = 0; x < w; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL){
            var propClamped = Math.min(Math.max(prop, 0.0), 1.0), invPropClamped = 1 - propClamped, // The gradient color to draw
            r = fromColor.r * invPropClamped + toColor.r * propClamped, g = fromColor.g * invPropClamped + toColor.g * propClamped, b = fromColor.b * invPropClamped + toColor.b * propClamped, a = fromColor.a * invPropClamped + toColor.a * propClamped, alpha2 = this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET], newAlpha = a + alpha2 - a * alpha2 / 255 | 0;
            if (newAlpha > 0) {
                var realAlpha = a * 255 / newAlpha | 0, invAlpha = 255 - realAlpha;
                this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] = (r * realAlpha + this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] * invAlpha) / 255 | 0;
                this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] = (g * realAlpha + this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] * invAlpha) / 255 | 0;
                this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET] = (b * realAlpha + this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET] * invAlpha) / 255 | 0;
                this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = newAlpha;
            }
            prop += horzStep;
        }
    }
};
/**
 * Draw a gradient which begins at fromX, fromY and ends at toX, toY, clipped to the given rect, on top of the
 * pixels in the bitmap.
 *
 * @param {CPRect} rect
 * @param {Object[]} gradientPoints Array with gradient colors (ARGB integers)
 * @param {number} fromX
 * @param {number} fromY
 * @param {number} toX
 * @param {number} toY
 * @param {boolean} replace - True if the contents of the destination should be ignored (opaque blend)
 */ CPColorBmp.prototype.gradient = function(rect, fromX, fromY, toX, toY, gradientPoints, replace) {
    rect = this.getBounds().clipTo(rect);
    // Degenerate case
    if (fromX == toX && fromY == toY) return;
    // Opaque blend if possible
    if (replace || gradientPoints[0] >>> 24 == 255 && gradientPoints[1] >>> 24 == 255) {
        if (fromX == toX) this.gradientVertReplace(rect, fromY, toY, gradientPoints);
        else if (fromY == toY) this.gradientHorzReplace(rect, fromX, toX, gradientPoints);
        else this.gradientReplace(rect, fromX, fromY, toX, toY, gradientPoints);
    } else this.gradientAlpha(rect, fromX, fromY, toX, toY, gradientPoints);
};
/**
 * @param {CPRect} rect
 */ CPColorBmp.prototype.fillWithColorNoise = function(rect) {
    rect = this.getBounds().clipTo(rect);
    var value, yStride = (this.width - rect.getWidth()) * CPColorBmp.BYTES_PER_PIXEL, pixIndex = this.offsetOfPixel(rect.left, rect.top);
    for(var y = rect.top; y < rect.bottom; y++, pixIndex += yStride)for(var x = rect.left; x < rect.right; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL){
        value = Math.random() * 0x1000000 | 0;
        this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] = value >> 16 & 0xFF;
        this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] = value >> 8 & 0xFF;
        this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET] = value & 0xFF;
        this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = 0xFF;
    }
};
/**
 * @param {CPRect} rect
 */ CPColorBmp.prototype.invert = function(rect) {
    rect = this.getBounds().clipTo(rect);
    var yStride = (this.width - rect.getWidth()) * CPColorBmp.BYTES_PER_PIXEL, pixIndex = this.offsetOfPixel(rect.left, rect.top);
    for(var y = rect.top; y < rect.bottom; y++, pixIndex += yStride)for(var x = rect.left; x < rect.right; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL){
        this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] ^= 0xFF;
        this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] ^= 0xFF;
        this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET] ^= 0xFF;
    }
};
/**
 * @param {CPRect} rect
 */ CPColorBmp.prototype.brightnessToOpacity = function(rect) {
    rect = this.getBounds().clipTo(rect);
    const threshold = 250;
    const yStride = (this.width - rect.getWidth()) * CPColorBmp.BYTES_PER_PIXEL;
    let pixIndex = this.offsetOfPixel(rect.left, rect.top);
    for(let y = rect.top; y < rect.bottom; y++, pixIndex += yStride)for(let x = rect.left; x < rect.right; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL){
        // 輝度の計算
        const brightness = (this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] + this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] + this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET]) / 3;
        // 元のアルファ値を取得
        const originalAlpha = this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] / 255;
        // しきい値を基に透明度を設定
        let newAlpha;
        if (brightness > threshold) newAlpha = 0; // 完全に透明
        else // 線形にマッピングして中間の透明度を計算 (輝度が高いほど透明に近づく)
        newAlpha = Math.round((1 - brightness / threshold) * 255);
        // 元のアルファ値を考慮して透明度を更新
        this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] = Math.round(newAlpha * originalAlpha);
        // 不透明な線画の明度を0に
        if (newAlpha > 0) {
            this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] = 0;
            this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] = 0;
            this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET] = 0;
        }
    }
};
/**
 * Get a rectangle that encloses any non-transparent pixels in the bitmap within the given initialBounds (or an empty
 * rect if the pixels inside the given bounds are 100% transparent).
 *
 * @param {CPRect} initialBounds - The rect to search within (pass getBounds() to search the whole bitmap)
 *
 * @returns {CPRect}
 */ CPColorBmp.prototype.getNonTransparentBounds = function(initialBounds) {
    var pixIndex, result = initialBounds.clone(), x, y, alphaOred, yStride;
    // Find the first non-transparent row
    yStride = (this.width - result.getWidth()) * CPColorBmp.BYTES_PER_PIXEL;
    pixIndex = this.offsetOfPixel(result.left, result.top) + CPColorBmp.ALPHA_BYTE_OFFSET;
    for(y = result.top; y < result.bottom; y++, pixIndex += yStride){
        alphaOred = 0x00;
        for(x = result.left; x < result.right; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL)alphaOred |= this.data[pixIndex];
        // Only check once per row in order to reduce branching in the inner loop
        if (alphaOred != 0x00) break;
    }
    result.top = y;
    if (result.top == result.bottom) // Rect is empty, no opaque pixels in the initialBounds
    return result;
    // Now the last non-transparent row
    pixIndex = this.offsetOfPixel(result.right - 1, result.bottom - 1) + CPColorBmp.ALPHA_BYTE_OFFSET;
    for(y = result.bottom - 1; y >= result.top; y--, pixIndex -= yStride){
        alphaOred = 0x00;
        for(x = result.right - 1; x >= result.left; x--, pixIndex -= CPColorBmp.BYTES_PER_PIXEL)alphaOred |= this.data[pixIndex];
        // Only check once per row in order to reduce branching in the inner loop
        if (alphaOred != 0x00) break;
    }
    result.bottom = y + 1; /* +1 since the bottom/right edges of the rect are exclusive */ 
    // Now columns from the left
    yStride = CPColorBmp.BYTES_PER_PIXEL * this.width;
    for(x = result.left; x < result.right; x++){
        pixIndex = this.offsetOfPixel(x, result.top) + CPColorBmp.ALPHA_BYTE_OFFSET;
        alphaOred = 0x00;
        for(y = result.top; y < result.bottom; y++, pixIndex += yStride)alphaOred |= this.data[pixIndex];
        if (alphaOred != 0x00) break;
    }
    result.left = x;
    // And columns from the right
    for(x = result.right - 1; x >= result.left; x--){
        pixIndex = this.offsetOfPixel(x, result.top) + CPColorBmp.ALPHA_BYTE_OFFSET;
        alphaOred = 0x00;
        for(y = result.top; y < result.bottom; y++, pixIndex += yStride)alphaOred |= this.data[pixIndex];
        if (alphaOred != 0x00) break;
    }
    result.right = x + 1;
    return result;
};
function getRotatedCanvas(canvas, rotation) {
    rotation = rotation % 4;
    if (rotation == 0) return canvas;
    let rotatedCanvas = (0, _canvasJs.createCanvas)(0, 0), rotatedCanvasContext = rotatedCanvas.getContext("2d");
    if (rotation % 2 == 0) {
        rotatedCanvas.width = canvas.width;
        rotatedCanvas.height = canvas.height;
    } else {
        //noinspection JSSuspiciousNameCombination
        rotatedCanvas.width = canvas.height;
        //noinspection JSSuspiciousNameCombination
        rotatedCanvas.height = canvas.width;
    }
    switch(rotation){
        case 1:
            // 90 degree clockwise:
            rotatedCanvasContext.rotate(Math.PI / 2);
            rotatedCanvasContext.drawImage(canvas, 0, -canvas.height);
            break;
        case 2:
            rotatedCanvasContext.rotate(Math.PI);
            rotatedCanvasContext.drawImage(canvas, -canvas.width, -canvas.height);
            break;
        case 3:
            // 90 degree counter-clockwise:
            rotatedCanvasContext.rotate(-Math.PI / 2);
            rotatedCanvasContext.drawImage(canvas, -canvas.width, 0);
            break;
        case 0:
        default:
            return canvas;
    }
    return rotatedCanvas;
}
function decodeBase64PNGDataURL(url) {
    if (typeof url !== "string" || !url.match(/^data:image\/png;base64,/i)) return false;
    return window.atob(url.substring(22));
}
/**
 * Get the image as Canvas.
 *
 * Rotation is [0..3] and selects a multiple of 90 degrees of clockwise rotation to be applied, or 0 to leave
 * unrotated.
 *
 * @returns {HTMLCanvasElement}
 */ CPColorBmp.prototype.getAsCanvas = function(rotation) {
    var canvas = (0, _canvasJs.createCanvas)(this.imageData.width, this.imageData.height), canvasContext = canvas.getContext("2d");
    canvasContext.putImageData(this.imageData, 0, 0);
    // Rotate it if needed
    return getRotatedCanvas(canvas, rotation || 0);
};
/**
 * Get the image as a PNG image.
 *
 * Rotation is [0..3] and selects a multiple of 90 degrees of clockwise rotation to be applied, or 0 to leave
 * unrotated.
 *
 * @returns {string} - "Binary string" representation of the PNG file
 */ CPColorBmp.prototype.getAsPNG = function(rotation) {
    let canvas = this.getAsCanvas(rotation);
    return decodeBase64PNGDataURL(canvas.toDataURL('image/png'));
};
/**
 * Get the image as a PNG image.
 *
 * Rotation is [0..3] and selects a multiple of 90 degrees of clockwise rotation to be applied, or 0 to leave
 * unrotated.
 *
 * @returns {Buffer}
 */ CPColorBmp.prototype.getAsPNGBuffer = function(rotation) {
    let canvas = this.getAsCanvas(rotation);
    // API provided by node-canvas for running on Node (browsers don't support this)
    return canvas.toBuffer('image/png');
};
/**
 * Returns true if any of the pixels in the given rectangle are not opaque.
 *
 * @param {CPRect} rect
 * @returns {boolean}
 */ CPColorBmp.prototype.hasAlphaInRect = function(rect) {
    rect = this.getBounds().clipTo(rect);
    var yStride = (this.width - rect.getWidth()) * CPColorBmp.BYTES_PER_PIXEL, pixIndex = this.offsetOfPixel(rect.left, rect.top) + CPColorBmp.ALPHA_BYTE_OFFSET;
    for(var y = rect.top; y < rect.bottom; y++, pixIndex += yStride){
        var alphaAnded = 0xFF;
        for(var x = rect.left; x < rect.right; x++, pixIndex += CPColorBmp.BYTES_PER_PIXEL)alphaAnded &= this.data[pixIndex];
        // Only check once per row in order to reduce branching in the inner loop
        if (alphaAnded != 0xFF) return true;
    }
    return false;
};
/**
 * Returns true if there are any transparent pixels in this image.
 * 
 * @returns {boolean}
 */ CPColorBmp.prototype.hasAlpha = function() {
    return this.hasAlphaInRect(this.getBounds());
};
/**
 * Create from a loaded HTML Image object
 *
 * @param {HTMLImageElement} image
 */ CPColorBmp.createFromImage = function(image) {
    var imageCanvas = (0, _canvasJs.createCanvas)(image.width, image.height), imageContext = imageCanvas.getContext("2d");
    imageContext.globalCompositeOperation = "copy";
    imageContext.drawImage(image, 0, 0);
    return new CPColorBmp(imageContext.getImageData(0, 0, image.width, image.height));
};
/**
 * Are all the pixels in this image identical to those of that?
 *
 * @param {CPColorBmp} that
 */ CPColorBmp.prototype.equals = function(that) {
    if (this.width != that.width || this.height != that.height) return false;
    for(let pixIndex = 0; pixIndex < this.data.length; pixIndex += CPColorBmp.BYTES_PER_PIXEL)// Fully transparent pixels don't need their color channels compared
    if (this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] != 0 || that.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] != 0) {
        if (this.data[pixIndex] != that.data[pixIndex] || this.data[pixIndex + 1] != that.data[pixIndex + 1] || this.data[pixIndex + 2] != that.data[pixIndex + 2] || this.data[pixIndex + 3] != that.data[pixIndex + 3]) return false;
    }
    return true;
};

},{"./CPBitmap.js":"ibRmc","../util/CPRect.js":"aDqvw","../util/Canvas.js":"bniay","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ibRmc":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPBitmap);
var _cprectJs = require("../util/CPRect.js");
var _cprectJsDefault = parcelHelpers.interopDefault(_cprectJs);
function CPBitmap(width, height) {
    // Width and height forced to integers
    this.width = width | 0;
    this.height = height | 0;
}
CPBitmap.prototype.getBounds = function() {
    return new (0, _cprectJsDefault.default)(0, 0, this.width, this.height);
};
CPBitmap.prototype.isInside = function(x, y) {
    return x >= 0 && y >= 0 && x < this.width && y < this.height;
};

},{"../util/CPRect.js":"aDqvw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aDqvw":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPRect);
function CPRect(left, top, right, bottom) {
    /*
    if (left === undefined || top === undefined || right === undefined || bottom === undefined) {
        throw "Bad rect";
    }
    
    if (~~left !== left || ~~top !== top || ~~right !== right || ~~bottom !== bottom) {
        throw "Bad rect";
    }
    */ this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
}
CPRect.prototype.makeEmpty = function() {
    this.left = 0;
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
};
CPRect.prototype.union = function(that) {
    if (this.isEmpty()) this.set(that);
    else if (!that.isEmpty()) {
        this.left = Math.min(this.left, that.left);
        this.top = Math.min(this.top, that.top);
        this.right = Math.max(this.right, that.right);
        this.bottom = Math.max(this.bottom, that.bottom);
    }
};
CPRect.prototype.getUnion = function(that) {
    var result = this.clone();
    result.union(that);
    return result;
};
/**
 * Get the intersection (possibly empty) of this rectangle and that.
 *
 * @param {CPRect} that
 * @returns {CPRect}
 */ CPRect.prototype.getIntersection = function(that) {
    return new CPRect(Math.max(this.left, that.left), Math.max(this.top, that.top), Math.min(this.right, that.right), Math.min(this.bottom, that.bottom));
};
/**
 * Clip this rectangle to fit within `that`.
 * 
 * @returns {CPRect} A reference to this rectangle for chaining
 */ CPRect.prototype.clipTo = function(that) {
    if (!this.isEmpty()) {
        if (that.isEmpty()) this.makeEmpty();
        else {
            this.left = Math.min(Math.max(this.left, that.left), that.right);
            this.top = Math.min(Math.max(this.top, that.top), that.bottom);
            this.right = Math.max(Math.min(this.right, that.right), that.left);
            this.bottom = Math.max(Math.min(this.bottom, that.bottom), that.top);
        }
    }
    return this;
};
CPRect.prototype.containsPoint = function(p) {
    return !(p.x < this.left || p.y < this.top || p.x >= this.right || p.y >= this.bottom);
};
CPRect.prototype.isInside = function(that) {
    return this.left >= that.left && this.top >= that.top && this.right <= that.right && this.bottom <= that.bottom;
};
/**
 * Use this rectangle as bounds to clip the placement of the area of srcRect at the position of dstRect inside
 * our bounds.
 *
 * dstRect has its right and bottom set by this operation to match the area that would be copied from the source.
 * srcRect has its coordinates tweaked to match the area that will be copied.
 */ CPRect.prototype.clipSourceDest = function(srcRect, dstRect) {
    dstRect.right = dstRect.left + srcRect.getWidth();
    dstRect.bottom = dstRect.top + srcRect.getHeight();
    if (this.isEmpty() || dstRect.left >= this.right || dstRect.top >= this.bottom || dstRect.right <= this.left || dstRect.bottom <= this.top) {
        srcRect.makeEmpty();
        dstRect.makeEmpty();
    } else {
        // bottom/right
        if (dstRect.right > this.right) {
            srcRect.right -= dstRect.right - this.right;
            dstRect.right = this.right;
        }
        if (dstRect.bottom > this.bottom) {
            srcRect.bottom -= dstRect.bottom - this.bottom;
            dstRect.bottom = this.bottom;
        }
        // top/left
        if (dstRect.left < this.left) {
            srcRect.left += this.left - dstRect.left;
            dstRect.left = this.left;
        }
        if (dstRect.top < this.top) {
            srcRect.top += this.top - dstRect.top;
            dstRect.top = this.top;
        }
    }
};
CPRect.prototype.getWidth = function() {
    return this.right - this.left;
};
CPRect.prototype.getHeight = function() {
    return this.bottom - this.top;
};
CPRect.prototype.getArea = function() {
    return this.getWidth() * this.getHeight();
};
CPRect.prototype.isEmpty = function() {
    return this.right <= this.left || this.bottom <= this.top;
};
/**
 * Set this rectangle's coordinates to a copy of that ones.
 *
 * @param {CPRect} thatRect
 */ CPRect.prototype.set = function(thatRect) {
    this.left = thatRect.left;
    this.top = thatRect.top;
    this.right = thatRect.right;
    this.bottom = thatRect.bottom;
};
/**
 * Get an independent copy of this rectangle.
 *
 * @returns {CPRect}
 */ CPRect.prototype.clone = function() {
    return new CPRect(this.left, this.top, this.right, this.bottom);
};
/**
 * Move the rectangle by the given offset
 *
 * @param {number} x
 * @param {number} y
 *
 * @returns {CPRect} This rectangle for chaining
 */ CPRect.prototype.translate = function(x, y) {
    this.left += x;
    this.right += x;
    this.top += y;
    this.bottom += y;
    return this;
};
CPRect.prototype.getTranslated = function(x, y) {
    var result = this.clone();
    result.translate(x, y);
    return result;
};
CPRect.prototype.moveTo = function(x, y) {
    this.translate(x - this.left, y - this.top);
};
CPRect.prototype.equals = function(that) {
    return this.left == that.left && this.right == that.right && this.top == that.top && this.bottom == that.bottom;
};
/**
 * Add h pixels to both the left and right sides of the rectangle, and v pixels to both the top and bottom sides.
 *  
 * @param h
 * @param v
 */ CPRect.prototype.grow = function(h, v) {
    // TODO checks for rectangles with zero-extent
    this.left -= h;
    this.right += h;
    this.top -= v;
    this.bottom += v;
};
CPRect.prototype.toString = function() {
    return "(" + this.left + "," + this.top + "," + this.right + "," + this.bottom + ")";
};
/**
 * Convert the rectangle into an array of points of the corners of the rectangle (clockwise starting from the top left
 * point).
 */ CPRect.prototype.toPoints = function() {
    return [
        {
            x: this.left,
            y: this.top
        },
        {
            x: this.right,
            y: this.top
        },
        {
            x: this.right,
            y: this.bottom
        },
        {
            x: this.left,
            y: this.bottom
        }
    ];
};
/**
 * Round the rectangle coordinates to the nearest integer.
 *
 * @returns {CPRect} This rectangle for chaining
 */ CPRect.prototype.roundNearest = function() {
    this.left = Math.round(this.left);
    this.top = Math.round(this.top);
    this.right = Math.round(this.right);
    this.bottom = Math.round(this.bottom);
    return this;
};
/**
 * Round the rectangle coordinates to integers so that the old rectangle is contained by the new one.
 *
 * @returns {CPRect} This rectangle for chaining
 */ CPRect.prototype.roundContain = function() {
    this.left = Math.floor(this.left);
    this.top = Math.floor(this.top);
    this.right = Math.ceil(this.right);
    this.bottom = Math.ceil(this.bottom);
    return this;
};
/**
 * Create an AABB CPRect which encloses the given array of points.
 *
 * @param {{x: number, y: number}[]} points
 *
 * @returns {CPRect}
 */ CPRect.createBoundingBox = function(points) {
    if (points.length === 0) return new CPRect(0, 0, 0, 0);
    let result = new CPRect(points[0].x, points[0].y, points[0].x, points[0].y);
    for(let i = 1; i < points.length; i++){
        result.left = Math.min(result.left, points[i].x);
        result.top = Math.min(result.top, points[i].y);
        result.right = Math.max(result.right, points[i].x);
        result.bottom = Math.max(result.bottom, points[i].y);
    }
    return result;
};
/**
 * Subtract that rectangle from this one and return an array of CPRects to represent the resulting area (possibly
 * empty).
 *
 * @param {CPRect} that
 * @returns {CPRect[]}
 */ CPRect.prototype.subtract = function(that) {
    return CPRect.subtract(this, that);
};
/**
 * Subtract the second rectangle or array of rectangles from the first one, and return an array of CPRects to represent
 * the resulting area (possibly empty).
 *
 * @param {(CPRect|CPRect[])} rectsA
 * @param {(CPRect|CPRect[])} rectsB
 * @returns {CPRect[]}
 */ CPRect.subtract = function(rectsA, rectsB) {
    if (rectsA instanceof CPRect) rectsA = [
        rectsA
    ];
    if (rectsB instanceof CPRect) rectsB = [
        rectsB
    ];
    let result = rectsA.slice(0);
    for(let i = 0; i < rectsB.length; i++){
        // Don't re-examine any new rectangles we push onto the result, since we know they don't intersect this rectB:
        let rectB = rectsB[i], resultLength = result.length;
        for(let j = 0; j < resultLength; j++){
            let rectA = result[j];
            if (!rectA) continue;
            let intersection = rectA.getIntersection(rectB);
            if (!intersection.isEmpty()) {
                let newRects = [];
                if (rectA.top < rectB.top) newRects.push(new CPRect(rectA.left, rectA.top, rectA.right, intersection.top));
                if (rectA.bottom > rectB.bottom) newRects.push(new CPRect(rectA.left, intersection.bottom, rectA.right, rectA.bottom));
                if (rectA.left < rectB.left) newRects.push(new CPRect(rectA.left, intersection.top, intersection.left, intersection.bottom));
                if (rectA.right > rectB.right) newRects.push(new CPRect(intersection.right, intersection.top, rectA.right, intersection.bottom));
                newRects = newRects.filter((rect)=>!rect.isEmpty());
                // Replace the original rectangle in the array with the new fragments
                if (newRects.length > 0) {
                    result[j] = newRects[0];
                    for(let k = 1; k < newRects.length; k++)result.push(newRects[k]);
                } else result[j] = null;
            }
        }
    }
    return result.filter((rect)=>rect != null);
};
/**
 * Create a union of the given rectangles, and return an array of non-overlapping CPRects to represent
 * the resulting shape (possibly empty).
 *
 * @param {(CPRect|CPRect[])} rects
 * @returns {CPRect[]}
 */ CPRect.union = function(rects) {
    let result;
    if (rects instanceof CPRect) result = [
        rects
    ];
    else {
        result = rects.slice(0); // Clone to avoid damaging the original array
        for(let i = 0; i < result.length; i++){
            // Intersect this rectangle with all the others
            let rectA = result[i], resultLength = result.length;
            if (!rectA) continue;
            // Don't re-examine any new rectangles we push onto the result
            for(let j = i + 1; j < resultLength; j++){
                let rectB = result[j];
                if (!rectB) continue;
                let intersection = rectA.getIntersection(rectB);
                if (!intersection.isEmpty()) {
                    /* We need to eliminate the overlap between these rectangles. Subtract rectA from rectB and leave
                     * rectA alone.
                     */ let newRects = CPRect.subtract(rectB, rectA);
                    // Replace rectB with one of the fragments
                    result[j] = newRects[0];
                    // And add the rest of the fragments to the end
                    for(let k = 1; k < newRects.length; k++)result.push(newRects[k]);
                }
            }
        }
    }
    return result.filter((rect)=>rect && !rect.isEmpty());
};
/* 
 * Chrome is initially eager to optimize CPRect and users assuming that all the fields are SMIs, then later on decides
 * that they should be tagged numbers after all. This causes all the blending operation functions to be reoptimized
 * a couple of times. 
 * 
 * Avoid that mess by starting things off with floats in the members.  
 */ if (typeof window == "object") window.cpRectGarbage = new CPRect(1.5, 2.5, 3.5, 4.5);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bniay":[function(require,module,exports,__globalThis) {
/*
	ChickenPaint
	
	ChickenPaint is a translation of ChibiPaint from Java to JavaScript
	by Nicholas Sherlock / Chicken Smoothie.
	
	ChibiPaint is Copyright (c) 2006-2008 Marc Schefer
	
	ChickenPaint is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.
	
	ChickenPaint is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	
	You should have received a copy of the GNU General Public License
	along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createCanvas", ()=>createCanvas);
parcelHelpers.export(exports, "createImageData", ()=>createImageData);
function createCanvas(width, height) {
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
}
function createImageData(width, height) {
    // return new ImageData(this.width, this.height); // Doesn't work on old IE
    var canvas = document.createElement("canvas"), context = canvas.getContext("2d");
    return context.createImageData(width, height);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1fr05":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPLayer);
var _cplayerGroupJs = require("./CPLayerGroup.js");
var _cplayerGroupJsDefault = parcelHelpers.interopDefault(_cplayerGroupJs);
var _cpblendJs = require("./CPBlend.js");
var _cpblendJsDefault = parcelHelpers.interopDefault(_cpblendJs);
var _cpgreyBmpJs = require("./CPGreyBmp.js");
var _cpgreyBmpJsDefault = parcelHelpers.interopDefault(_cpgreyBmpJs);
var _cprectJs = require("../util/CPRect.js");
var _cprectJsDefault = parcelHelpers.interopDefault(_cprectJs);
function CPLayer(name) {
    /**
     *
     * @type {String}
     */ this.name = name || "";
    /**
     * The parent of this layer, if this node is in a layer group.
     *
     * @type {?CPLayerGroup}
     */ this.parent = null;
    /**
     * True if drawing operations on the image of this layer should not change the alpha component of the layer.
     *
     * @type {boolean}
     */ this.lockAlpha = false;
    /**
     * The opacity of this layer (0 = transparent, 100 = opaque)
     *
     * @type {number}
     */ this.alpha = 100;
    /**
     * True if this layer and its children should be drawn.
     *
     * @type {boolean}
     */ this.visible = true;
    /**
     * One of the CMBlend.LM_* constants.
     *
     * @type {number}
     */ this.blendMode = (0, _cpblendJsDefault.default).LM_NORMAL;
    /**
     * The layer mask (if present)
     * 
     * @type {?CPGreyBmp}
     */ this.mask = null;
    /**
     * True if transformations applied to the layer should also be applied to the mask (and vice versa)
     *
     * @type {boolean}
     */ this.maskLinked = true;
    /**
     * True if the mask should be applied (if present)
     *
	 * @type {boolean}
	 */ this.maskVisible = true;
    /**
     * The thumbnail of the mask (if a mask is present and the thumb has been built)
     * @type {?CPGreyBmp}
     */ this.maskThumbnail = null;
    /**
     * True if this layer should use CPBlend.LM_MULTIPLY instead of CPBlend.LM_MULTIPLY2
	 * @type {boolean}
	 */ this.useLegacyMultiply = false;
}
/**
 *
 * @param {CPLayer} layer
 */ CPLayer.prototype.copyFrom = function(layer) {
    this.name = layer.name;
    this.blendMode = layer.blendMode;
    this.useLegacyMultiply = layer.useLegacyMultiply;
    this.alpha = layer.alpha;
    this.visible = layer.visible;
    this.parent = layer.parent;
    this.lockAlpha = layer.lockAlpha;
    if (!layer.mask) this.mask = null;
    else if (this.mask) this.mask.copyPixelsFrom(layer.mask);
    else this.mask = layer.mask.clone();
    this.maskLinked = layer.maskLinked;
    this.maskVisible = layer.maskVisible;
    if (!layer.maskThumbnail) this.maskThumbnail = null;
    else if (this.maskThumbnail) this.maskThumbnail.copyPixelsFrom(layer.maskThumbnail);
    else this.maskThumbnail = layer.maskThumbnail.clone();
};
CPLayer.prototype.setMask = function(mask) {
    this.mask = mask;
    if (!mask) this.maskThumbnail = null;
};
CPLayer.prototype.setAlpha = function(alpha) {
    this.alpha = alpha;
};
CPLayer.prototype.getAlpha = function() {
    return this.alpha;
};
/**
 * Get the alpha of this layer, or zero if this layer is hidden.
 * 
 * @returns {number}
 */ CPLayer.prototype.getEffectiveAlpha = function() {
    if (this.visible) return this.alpha;
    return 0;
};
/**
 * Get the mask for this layer, or null if the mask is not present or hidden.
 *
 * @returns {?CPGreyBmp}
 */ CPLayer.prototype.getEffectiveMask = function() {
    if (this.maskVisible) return this.mask;
    return null;
};
CPLayer.prototype.setName = function(name) {
    this.name = name;
};
CPLayer.prototype.getName = function() {
    return this.name;
};
CPLayer.prototype.setBlendMode = function(blendMode) {
    this.blendMode = blendMode;
    if (blendMode === (0, _cpblendJsDefault.default).LM_MULTIPLY) /* If the blend mode is ever set to this legacy one, we'll keep this flag set on the layer so that the
         * user can change to a different blending mode, and still be able to change it back to the legacy one.
         */ this.useLegacyMultiply = true;
    else if (blendMode === (0, _cpblendJsDefault.default).LM_MULTIPLY2) this.useLegacyMultiply = false;
};
CPLayer.prototype.getBlendMode = function() {
    return this.blendMode;
};
CPLayer.prototype.getLockAlpha = function() {
    return this.lockAlpha;
};
CPLayer.prototype.setLockAlpha = function(value) {
    this.lockAlpha = value;
};
CPLayer.prototype.setVisible = function(visible) {
    this.visible = visible;
};
CPLayer.prototype.getVisible = function() {
    return this.visible;
};
CPLayer.prototype.isVisible = CPLayer.prototype.getVisible;
CPLayer.prototype.setMaskLinked = function(linked) {
    this.maskLinked = linked;
};
CPLayer.prototype.getMaskLinked = function() {
    return this.maskLinked;
};
CPLayer.prototype.setMaskVisible = function(visible) {
    this.maskVisible = visible;
};
CPLayer.prototype.getMaskVisible = function() {
    return this.maskVisible;
};
CPLayer.prototype.getMemoryUsed = function() {
    return 0;
};
CPLayer.prototype.getDepth = function() {
    if (this.parent == null) return 0;
    return this.parent.getDepth() + 1;
};
CPLayer.prototype.ancestorsAreVisible = function() {
    return this.parent == null || this.parent.visible && this.parent.ancestorsAreVisible();
};
/**
 * Returns true if this layer has the given group as one of its ancestors.
 *
 * @param {CPLayerGroup} group
 * @returns {boolean}
 */ CPLayer.prototype.hasAncestor = function(group) {
    return this.parent == group || this.parent && this.parent.hasAncestor(group);
};
CPLayer.prototype.clone = function() {
    throw "Pure virtual CPLayer.clone() call";
};
/**
 * Get a rectangle that encloses any non-transparent pixels in the layer within the given initialBounds (or an empty
 * rect if the pixels inside the given bounds are 100% transparent).
 *
 * @param {CPRect} initialBounds - The rect to search within
 *
 * @returns {CPRect}
 */ CPLayer.prototype.getNonTransparentBounds = function(initialBounds) {
    return new (0, _cprectJsDefault.default)(0, 0, 0, 0);
};
/**
 * Recreate the image thumbnail for this layer.
 */ CPLayer.prototype.rebuildMaskThumbnail = function() {
    if (this.mask) {
        if (!this.maskThumbnail) {
            var scaleDivider = Math.ceil(Math.max(this.mask.width / CPLayer.LAYER_THUMBNAIL_WIDTH, this.mask.height / CPLayer.LAYER_THUMBNAIL_HEIGHT));
            this.maskThumbnail = new (0, _cpgreyBmpJsDefault.default)(Math.floor(this.mask.width / scaleDivider), Math.floor(this.mask.height / scaleDivider), 8);
        }
        this.maskThumbnail.createThumbnailFrom(this.mask);
    } else this.maskThumbnail = null;
};
/**
 * Get the mask thumbnail for this layer (or build one if one was not already built). If the layer has no mask, null
 * is returned.
 *
 * @returns {?CPGreyBmp}
 */ CPLayer.prototype.getMaskThumbnail = function() {
    if (!this.maskThumbnail && this.mask) this.rebuildMaskThumbnail();
    return this.maskThumbnail;
};
CPLayer.LAYER_THUMBNAIL_WIDTH = 80;
CPLayer.LAYER_THUMBNAIL_HEIGHT = 50;

},{"./CPLayerGroup.js":"k5mD3","./CPBlend.js":"k5HfA","./CPGreyBmp.js":"fGKWG","../util/CPRect.js":"aDqvw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k5mD3":[function(require,module,exports,__globalThis) {
/*
	ChickenPaint

	ChickenPaint is a translation of ChibiPaint from Java to JavaScript
	by Nicholas Sherlock / Chicken Smoothie.

	ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

	ChickenPaint is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	ChickenPaint is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPLayerGroup);
var _cplayerJs = require("./CPLayer.js");
var _cplayerJsDefault = parcelHelpers.interopDefault(_cplayerJs);
var _cprectJs = require("../util/CPRect.js");
var _cprectJsDefault = parcelHelpers.interopDefault(_cprectJs);
function CPLayerGroup(name, blendMode) {
    (0, _cplayerJsDefault.default).call(this, name);
    /**
	 * @type {CPLayer[]}
	 */ this.layers = [];
    this.expanded = true;
    this.blendMode = blendMode;
}
CPLayerGroup.prototype = Object.create((0, _cplayerJsDefault.default).prototype);
CPLayerGroup.prototype.constructor = CPLayerGroup;
/**
 * Returns an array of layers in this group in display order, excluding this group itself.
 *
 * @param {boolean} respectCollapse - Set to true to omit the children of collapsed groups
 * @param {CPLayer[]} list
 * @returns {CPLayer[]}
 */ CPLayerGroup.prototype.getLinearizedLayerList = function(respectCollapse, list) {
    list = list || [];
    for (let layer of this.layers){
        if (layer instanceof CPLayerGroup && (layer.expanded || !respectCollapse)) layer.getLinearizedLayerList(respectCollapse, list);
        list.push(layer);
    }
    return list;
};
CPLayerGroup.prototype.clearLayers = function() {
    this.layers = [];
};
CPLayerGroup.prototype.addLayer = function(layer) {
    layer.parent = this;
    this.layers.push(layer);
};
CPLayerGroup.prototype.insertLayer = function(index, layer) {
    layer.parent = this;
    this.layers.splice(index, 0, layer);
};
CPLayerGroup.prototype.removeLayer = function(layer) {
    var index = this.layers.indexOf(layer);
    if (index > -1) this.layers.splice(index, 1);
};
CPLayerGroup.prototype.removeLayerAtIndex = function(index) {
    var layer = this.layers[index];
    if (layer) this.layers.splice(index, 1);
    return layer;
};
CPLayerGroup.prototype.setLayerAtIndex = function(index, layer) {
    var oldLayer = this.layers[index];
    layer.parent = this;
    this.layers[index] = layer;
    return oldLayer;
};
CPLayerGroup.prototype.setExpanded = function(expanded) {
    this.expanded = expanded;
};
CPLayerGroup.prototype.getExpanded = function() {
    return this.expanded;
};
/**
 * Get the index of the given layer in this group, or -1 if the layer is not in the group.
 * 
 * @param {CPLayer} layer
 * @returns {number}
 */ CPLayerGroup.prototype.indexOf = function(layer) {
    return this.layers.indexOf(layer);
};
function sum(a, b) {
    return a + b;
}
/**
 * Get an approximation of the number of bytes of memory used by this layer.
 *
 * @returns {number}
 */ CPLayerGroup.prototype.getMemoryUsed = function() {
    return this.layers.map((layer)=>layer.getMemoryUsed()).reduce(sum, 0);
};
CPLayerGroup.prototype.clone = function() {
    var result = new CPLayerGroup(this.name, this.blendMode);
    (0, _cplayerJsDefault.default).prototype.copyFrom.call(result, this);
    result.expanded = this.expanded;
    result.layers = this.layers.map((layer)=>layer.clone());
    result.layers.forEach((layer)=>layer.parent = result);
    return result;
};
/**
 * Get a rectangle that encloses any non-transparent pixels in the layer within the given initialBounds (or an empty
 * rect if the pixels inside the given bounds are 100% transparent).
 *
 * @param {CPRect} initialBounds - The rect to search within
 *
 * @returns {CPRect}
 */ CPLayerGroup.prototype.getNonTransparentBounds = function(initialBounds) {
    var nonTransparentRect = new (0, _cprectJsDefault.default)(0, 0, 0, 0);
    this.layers.forEach((layer)=>nonTransparentRect.union(layer.getNonTransparentBounds(initialBounds)));
    return nonTransparentRect;
};

},{"./CPLayer.js":"1fr05","../util/CPRect.js":"aDqvw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k5HfA":[function(require,module,exports,__globalThis) {
// This file is generated, please see codegenerator/BlendGenerator.js!
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPBlend);
var _cpcolorBmpJs = require("./CPColorBmp.js");
var _cpcolorBmpJsDefault = parcelHelpers.interopDefault(_cpcolorBmpJs);
var _cpgreyBmpJs = require("./CPGreyBmp.js");
var _cpgreyBmpJsDefault = parcelHelpers.interopDefault(_cpgreyBmpJs);
var _cplayerJs = require("./CPLayer.js");
var _cplayerJsDefault = parcelHelpers.interopDefault(_cplayerJs);
var _cprectJs = require("../util/CPRect.js");
var _cprectJsDefault = parcelHelpers.interopDefault(_cprectJs);
function CPBlend() {}
const BYTES_PER_PIXEL = 4, ALPHA_BYTE_OFFSET = 3, softLightLUTSquare = new Array(256), softLightLUTSquareRoot = new Array(256);
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.multiplyOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color2;
        if (alpha1) {
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 - ((layer.data[pixIndex] ^ 0xFF) * color2 * alpha1 / 65025 | 0);
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 - ((layer.data[pixIndex + 1] ^ 0xFF) * color2 * alpha1 / 65025 | 0);
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 - ((layer.data[pixIndex + 2] ^ 0xFF) * color2 * alpha1 / 65025 | 0);
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.multiplyOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color2;
        if (alpha1) {
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 - ((layer.data[pixIndex] ^ 0xFF) * color2 * alpha1 / 65025 | 0);
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 - ((layer.data[pixIndex + 1] ^ 0xFF) * color2 * alpha1 / 65025 | 0);
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 - ((layer.data[pixIndex + 2] ^ 0xFF) * color2 * alpha1 / 65025 | 0);
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.multiplyOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.multiplyOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.multiplyOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color2;
        if (alpha1) {
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 - ((layer.data[pixIndex] ^ 0xFF) * color2 * alpha1 / 65025 | 0);
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 - ((layer.data[pixIndex + 1] ^ 0xFF) * color2 * alpha1 / 65025 | 0);
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 - ((layer.data[pixIndex + 2] ^ 0xFF) * color2 * alpha1 / 65025 | 0);
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.multiplyOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color2;
        if (alpha1) {
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 - ((layer.data[pixIndex] ^ 0xFF) * color2 * alpha1 / 65025 | 0);
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 - ((layer.data[pixIndex + 1] ^ 0xFF) * color2 * alpha1 / 65025 | 0);
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 - ((layer.data[pixIndex + 2] ^ 0xFF) * color2 * alpha1 / 65025 | 0);
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.multiplyOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.multiplyOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.multiply2OntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color2;
        if (alpha1) {
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 - Math.ceil((layer.data[pixIndex] ^ 0xFF) * color2 * alpha1 / 65025);
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 - Math.ceil((layer.data[pixIndex + 1] ^ 0xFF) * color2 * alpha1 / 65025);
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 - Math.ceil((layer.data[pixIndex + 2] ^ 0xFF) * color2 * alpha1 / 65025);
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.multiply2OntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color2;
        if (alpha1) {
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 - Math.ceil((layer.data[pixIndex] ^ 0xFF) * color2 * alpha1 / 65025);
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 - Math.ceil((layer.data[pixIndex + 1] ^ 0xFF) * color2 * alpha1 / 65025);
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 - Math.ceil((layer.data[pixIndex + 2] ^ 0xFF) * color2 * alpha1 / 65025);
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.multiply2OntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.multiply2OntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.multiply2OntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color2;
        if (alpha1) {
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 - Math.ceil((layer.data[pixIndex] ^ 0xFF) * color2 * alpha1 / 65025);
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 - Math.ceil((layer.data[pixIndex + 1] ^ 0xFF) * color2 * alpha1 / 65025);
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 - Math.ceil((layer.data[pixIndex + 2] ^ 0xFF) * color2 * alpha1 / 65025);
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.multiply2OntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color2;
        if (alpha1) {
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 - Math.ceil((layer.data[pixIndex] ^ 0xFF) * color2 * alpha1 / 65025);
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 - Math.ceil((layer.data[pixIndex + 1] ^ 0xFF) * color2 * alpha1 / 65025);
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 - Math.ceil((layer.data[pixIndex + 2] ^ 0xFF) * color2 * alpha1 / 65025);
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.multiply2OntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the multiply blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.multiply2OntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + (color1 * color2 * alpha12 / 255 | 0)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the normal blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.normalOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color1;
        if (alpha1) {
            if (alpha1 == 255) {
                fusion.data[pixIndex] = layer.data[pixIndex];
                fusion.data[pixIndex + 1] = layer.data[pixIndex + 1];
                fusion.data[pixIndex + 2] = layer.data[pixIndex + 2];
            } else {
                let invAlpha1 = 255 - alpha1;
                color1 = layer.data[pixIndex];
                fusion.data[pixIndex] = (color1 * alpha1 + fusion.data[pixIndex] * invAlpha1) / 255 | 0;
                color1 = layer.data[pixIndex + 1];
                fusion.data[pixIndex + 1] = (color1 * alpha1 + fusion.data[pixIndex + 1] * invAlpha1) / 255 | 0;
                color1 = layer.data[pixIndex + 2];
                fusion.data[pixIndex + 2] = (color1 * alpha1 + fusion.data[pixIndex + 2] * invAlpha1) / 255 | 0;
            }
        }
    }
};
/**
 * Blend the given layer onto the fusion using the normal blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.normalOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color1;
        if (alpha1) {
            let invAlpha1 = 255 - alpha1;
            color1 = layer.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1 + fusion.data[pixIndex] * invAlpha1) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1 + fusion.data[pixIndex + 1] * invAlpha1) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1 + fusion.data[pixIndex + 2] * invAlpha1) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the normal blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.normalOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, realAlpha = alpha1 * 255 / newAlpha | 0, invAlpha = 255 - realAlpha;
            fusion.data[pixIndex] = (layer.data[pixIndex] * realAlpha + fusion.data[pixIndex] * invAlpha) / 255 | 0;
            fusion.data[pixIndex + 1] = (layer.data[pixIndex + 1] * realAlpha + fusion.data[pixIndex + 1] * invAlpha) / 255 | 0;
            fusion.data[pixIndex + 2] = (layer.data[pixIndex + 2] * realAlpha + fusion.data[pixIndex + 2] * invAlpha) / 255 | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the normal blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.normalOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, realAlpha = alpha1 * 255 / newAlpha | 0, invAlpha = 255 - realAlpha;
            fusion.data[pixIndex] = (layer.data[pixIndex] * realAlpha + fusion.data[pixIndex] * invAlpha) / 255 | 0;
            fusion.data[pixIndex + 1] = (layer.data[pixIndex + 1] * realAlpha + fusion.data[pixIndex + 1] * invAlpha) / 255 | 0;
            fusion.data[pixIndex + 2] = (layer.data[pixIndex + 2] * realAlpha + fusion.data[pixIndex + 2] * invAlpha) / 255 | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the normal blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.normalOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color1;
        if (alpha1) {
            if (alpha1 == 255) {
                fusion.data[pixIndex] = layer.data[pixIndex];
                fusion.data[pixIndex + 1] = layer.data[pixIndex + 1];
                fusion.data[pixIndex + 2] = layer.data[pixIndex + 2];
            } else {
                let invAlpha1 = 255 - alpha1;
                color1 = layer.data[pixIndex];
                fusion.data[pixIndex] = (color1 * alpha1 + fusion.data[pixIndex] * invAlpha1) / 255 | 0;
                color1 = layer.data[pixIndex + 1];
                fusion.data[pixIndex + 1] = (color1 * alpha1 + fusion.data[pixIndex + 1] * invAlpha1) / 255 | 0;
                color1 = layer.data[pixIndex + 2];
                fusion.data[pixIndex + 2] = (color1 * alpha1 + fusion.data[pixIndex + 2] * invAlpha1) / 255 | 0;
            }
        }
    }
};
/**
 * Blend the given layer onto the fusion using the normal blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.normalOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color1;
        if (alpha1) {
            let invAlpha1 = 255 - alpha1;
            color1 = layer.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1 + fusion.data[pixIndex] * invAlpha1) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1 + fusion.data[pixIndex + 1] * invAlpha1) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1 + fusion.data[pixIndex + 2] * invAlpha1) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the normal blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.normalOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, realAlpha = alpha1 * 255 / newAlpha | 0, invAlpha = 255 - realAlpha;
            fusion.data[pixIndex] = (layer.data[pixIndex] * realAlpha + fusion.data[pixIndex] * invAlpha) / 255 | 0;
            fusion.data[pixIndex + 1] = (layer.data[pixIndex + 1] * realAlpha + fusion.data[pixIndex + 1] * invAlpha) / 255 | 0;
            fusion.data[pixIndex + 2] = (layer.data[pixIndex + 2] * realAlpha + fusion.data[pixIndex + 2] * invAlpha) / 255 | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the normal blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.normalOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, realAlpha = alpha1 * 255 / newAlpha | 0, invAlpha = 255 - realAlpha;
            fusion.data[pixIndex] = (layer.data[pixIndex] * realAlpha + fusion.data[pixIndex] * invAlpha) / 255 | 0;
            fusion.data[pixIndex + 1] = (layer.data[pixIndex + 1] * realAlpha + fusion.data[pixIndex + 1] * invAlpha) / 255 | 0;
            fusion.data[pixIndex + 2] = (layer.data[pixIndex + 2] * realAlpha + fusion.data[pixIndex + 2] * invAlpha) / 255 | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the add blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.addOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];
        if (alpha1) {
            fusion.data[pixIndex] = fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] / 255 | 0;
            fusion.data[pixIndex + 1] = fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] / 255 | 0;
            fusion.data[pixIndex + 2] = fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the add blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.addOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0;
        if (alpha1) {
            fusion.data[pixIndex] = fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] / 255 | 0;
            fusion.data[pixIndex + 1] = fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] / 255 | 0;
            fusion.data[pixIndex + 2] = fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the add blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.addOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0;
            // No need to clamp the color to 0...255 since we're writing to a clamped array anyway
            fusion.data[pixIndex] = (alpha2 * fusion.data[pixIndex] + alpha1 * layer.data[pixIndex]) / newAlpha | 0;
            fusion.data[pixIndex + 1] = (alpha2 * fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1]) / newAlpha | 0;
            fusion.data[pixIndex + 2] = (alpha2 * fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2]) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the add blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.addOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0;
            // No need to clamp the color to 0...255 since we're writing to a clamped array anyway
            fusion.data[pixIndex] = (alpha2 * fusion.data[pixIndex] + alpha1 * layer.data[pixIndex]) / newAlpha | 0;
            fusion.data[pixIndex + 1] = (alpha2 * fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1]) / newAlpha | 0;
            fusion.data[pixIndex + 2] = (alpha2 * fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2]) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the add blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.addOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0;
        if (alpha1) {
            fusion.data[pixIndex] = fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] / 255 | 0;
            fusion.data[pixIndex + 1] = fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] / 255 | 0;
            fusion.data[pixIndex + 2] = fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the add blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.addOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0;
        if (alpha1) {
            fusion.data[pixIndex] = fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] / 255 | 0;
            fusion.data[pixIndex + 1] = fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] / 255 | 0;
            fusion.data[pixIndex + 2] = fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the add blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.addOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0;
            // No need to clamp the color to 0...255 since we're writing to a clamped array anyway
            fusion.data[pixIndex] = (alpha2 * fusion.data[pixIndex] + alpha1 * layer.data[pixIndex]) / newAlpha | 0;
            fusion.data[pixIndex + 1] = (alpha2 * fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1]) / newAlpha | 0;
            fusion.data[pixIndex + 2] = (alpha2 * fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2]) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the add blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.addOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0;
            // No need to clamp the color to 0...255 since we're writing to a clamped array anyway
            fusion.data[pixIndex] = (alpha2 * fusion.data[pixIndex] + alpha1 * layer.data[pixIndex]) / newAlpha | 0;
            fusion.data[pixIndex + 1] = (alpha2 * fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1]) / newAlpha | 0;
            fusion.data[pixIndex + 2] = (alpha2 * fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2]) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the subtract blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.subtractOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];
        if (alpha1) {
            fusion.data[pixIndex] = fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] / 255 - alpha1 | 0;
            fusion.data[pixIndex + 1] = fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] / 255 - alpha1 | 0;
            fusion.data[pixIndex + 2] = fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] / 255 - alpha1 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the subtract blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.subtractOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0;
        if (alpha1) {
            fusion.data[pixIndex] = fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] / 255 - alpha1 | 0;
            fusion.data[pixIndex + 1] = fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] / 255 - alpha1 | 0;
            fusion.data[pixIndex + 2] = fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] / 255 - alpha1 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the subtract blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.subtractOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2;
            // No need to clamp the color to 255 since we're writing to a clamped array anyway
            fusion.data[pixIndex] = (alpha2 * fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] - alpha12) / newAlpha | 0;
            fusion.data[pixIndex + 1] = (alpha2 * fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] - alpha12) / newAlpha | 0;
            fusion.data[pixIndex + 2] = (alpha2 * fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] - alpha12) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the subtract blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.subtractOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2;
            // No need to clamp the color to 255 since we're writing to a clamped array anyway
            fusion.data[pixIndex] = (alpha2 * fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] - alpha12) / newAlpha | 0;
            fusion.data[pixIndex + 1] = (alpha2 * fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] - alpha12) / newAlpha | 0;
            fusion.data[pixIndex + 2] = (alpha2 * fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] - alpha12) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the subtract blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.subtractOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0;
        if (alpha1) {
            fusion.data[pixIndex] = fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] / 255 - alpha1 | 0;
            fusion.data[pixIndex + 1] = fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] / 255 - alpha1 | 0;
            fusion.data[pixIndex + 2] = fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] / 255 - alpha1 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the subtract blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.subtractOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0;
        if (alpha1) {
            fusion.data[pixIndex] = fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] / 255 - alpha1 | 0;
            fusion.data[pixIndex + 1] = fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] / 255 - alpha1 | 0;
            fusion.data[pixIndex + 2] = fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] / 255 - alpha1 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the subtract blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.subtractOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2;
            // No need to clamp the color to 255 since we're writing to a clamped array anyway
            fusion.data[pixIndex] = (alpha2 * fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] - alpha12) / newAlpha | 0;
            fusion.data[pixIndex + 1] = (alpha2 * fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] - alpha12) / newAlpha | 0;
            fusion.data[pixIndex + 2] = (alpha2 * fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] - alpha12) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the subtract blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.subtractOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2;
            // No need to clamp the color to 255 since we're writing to a clamped array anyway
            fusion.data[pixIndex] = (alpha2 * fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] - alpha12) / newAlpha | 0;
            fusion.data[pixIndex + 1] = (alpha2 * fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] - alpha12) / newAlpha | 0;
            fusion.data[pixIndex + 2] = (alpha2 * fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] - alpha12) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the screen blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.screenOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex + 1] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex + 2] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the screen blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.screenOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex + 1] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex + 2] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the screen blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.screenOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the screen blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.screenOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the screen blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.screenOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex + 1] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex + 2] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the screen blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.screenOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex + 1] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex + 2] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the screen blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.screenOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the screen blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.screenOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the lighten blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.lightenOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the lighten blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.lightenOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the lighten blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.lightenOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, // This alpha is used when color1 > color2
            alpha12 = alpha2 * (alpha1 ^ 0xFF) / newAlpha | 0, invAlpha12 = alpha12 ^ 0xFF, // This alpha is used when color2 > color1
            alpha21 = alpha1 * (alpha2 ^ 0xFF) / newAlpha | 0, invAlpha21 = alpha21 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the lighten blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.lightenOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, // This alpha is used when color1 > color2
            alpha12 = alpha2 * (alpha1 ^ 0xFF) / newAlpha | 0, invAlpha12 = alpha12 ^ 0xFF, // This alpha is used when color2 > color1
            alpha21 = alpha1 * (alpha2 ^ 0xFF) / newAlpha | 0, invAlpha21 = alpha21 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the lighten blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.lightenOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the lighten blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.lightenOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the lighten blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.lightenOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, // This alpha is used when color1 > color2
            alpha12 = alpha2 * (alpha1 ^ 0xFF) / newAlpha | 0, invAlpha12 = alpha12 ^ 0xFF, // This alpha is used when color2 > color1
            alpha21 = alpha1 * (alpha2 ^ 0xFF) / newAlpha | 0, invAlpha21 = alpha21 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the lighten blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.lightenOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, // This alpha is used when color1 > color2
            alpha12 = alpha2 * (alpha1 ^ 0xFF) / newAlpha | 0, invAlpha12 = alpha12 ^ 0xFF, // This alpha is used when color2 > color1
            alpha21 = alpha1 * (alpha2 ^ 0xFF) / newAlpha | 0, invAlpha21 = alpha21 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the darken blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.darkenOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 | 0 : color2;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 | 0 : color2;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 | 0 : color2;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the darken blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.darkenOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 | 0 : color2;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 | 0 : color2;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 | 0 : color2;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the darken blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.darkenOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, // This alpha is used when color1 > color2
            alpha12 = alpha1 * (alpha2 ^ 0xFF) / newAlpha | 0, invAlpha12 = alpha12 ^ 0xFF, // This alpha is used when color2 > color1
            alpha21 = alpha2 * (alpha1 ^ 0xFF) / newAlpha | 0, invAlpha21 = alpha21 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the darken blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.darkenOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, // This alpha is used when color1 > color2
            alpha12 = alpha1 * (alpha2 ^ 0xFF) / newAlpha | 0, invAlpha12 = alpha12 ^ 0xFF, // This alpha is used when color2 > color1
            alpha21 = alpha2 * (alpha1 ^ 0xFF) / newAlpha | 0, invAlpha21 = alpha21 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the darken blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.darkenOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 | 0 : color2;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 | 0 : color2;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 | 0 : color2;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the darken blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.darkenOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 | 0 : color2;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 | 0 : color2;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 | 0 : color2;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the darken blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.darkenOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, // This alpha is used when color1 > color2
            alpha12 = alpha1 * (alpha2 ^ 0xFF) / newAlpha | 0, invAlpha12 = alpha12 ^ 0xFF, // This alpha is used when color2 > color1
            alpha21 = alpha2 * (alpha1 ^ 0xFF) / newAlpha | 0, invAlpha21 = alpha21 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the darken blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.darkenOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, // This alpha is used when color1 > color2
            alpha12 = alpha1 * (alpha2 ^ 0xFF) / newAlpha | 0, invAlpha12 = alpha12 ^ 0xFF, // This alpha is used when color2 > color1
            alpha21 = alpha2 * (alpha1 ^ 0xFF) / newAlpha | 0, invAlpha21 = alpha21 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the dodge blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.dodgeOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the dodge blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.dodgeOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the dodge blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.dodgeOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the dodge blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.dodgeOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the dodge blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.dodgeOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the dodge blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.dodgeOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the dodge blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.dodgeOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the dodge blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.dodgeOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the burn blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.burnOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the burn blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.burnOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the burn blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.burnOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the burn blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.burnOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the burn blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.burnOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the burn blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.burnOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the burn blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.burnOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the burn blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.burnOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the overlay blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.overlayOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the overlay blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.overlayOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the overlay blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.overlayOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the overlay blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.overlayOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the overlay blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.overlayOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the overlay blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.overlayOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xFF;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the overlay blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.overlayOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the overlay blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.overlayOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the hard light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.hardLightOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the hard light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.hardLightOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the hard light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.hardLightOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the hard light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.hardLightOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the hard light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.hardLightOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the hard light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.hardLightOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the hard light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.hardLightOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the hard light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.hardLightOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the soft light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.softLightOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2 : ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2 : ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2 : ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2)) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the soft light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.softLightOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2 : ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2 : ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2 : ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2)) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the soft light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.softLightOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2) : alpha12 * (((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2) : alpha12 * (((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2) : alpha12 * (((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the soft light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.softLightOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2) : alpha12 * (((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2) : alpha12 * (((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2) : alpha12 * (((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the soft light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.softLightOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2 : ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2 : ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2 : ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2)) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the soft light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.softLightOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2 : ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2 : ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2 : ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2)) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the soft light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.softLightOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2) : alpha12 * (((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2) : alpha12 * (((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2) : alpha12 * (((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the soft light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.softLightOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2) : alpha12 * (((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2) : alpha12 * (((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (((2 * color1 - 255) * softLightLUTSquare[color2] / 255 | 0) + color2) : alpha12 * (((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 | 0) + color2))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the vivid light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.vividLightOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the vivid light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.vividLightOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the vivid light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.vividLightOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the vivid light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.vividLightOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the vivid light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.vividLightOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the vivid light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.vividLightOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the vivid light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.vividLightOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the vivid light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.vividLightOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1) | 0)) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)) | 0)))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the linear light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.linearLightOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex] - 255))) / 255 | 0;
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex + 1] - 255))) / 255 | 0;
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex + 2] - 255))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the linear light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.linearLightOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex] - 255))) / 255 | 0;
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex + 1] - 255))) / 255 | 0;
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex + 2] - 255))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the linear light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.linearLightOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the linear light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.linearLightOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the linear light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.linearLightOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex] - 255))) / 255 | 0;
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex + 1] - 255))) / 255 | 0;
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex + 2] - 255))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the linear light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.linearLightOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex] - 255))) / 255 | 0;
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex + 1] - 255))) / 255 | 0;
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex + 2] - 255))) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the linear light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.linearLightOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the linear light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.linearLightOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the pin light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.pinLightOntoOpaqueFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the pin light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.pinLightOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the pin light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.pinLightOntoTransparentFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the pin light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.pinLightOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the pin light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.pinLightOntoOpaqueFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the pin light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.pinLightOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, color1, color2;
        if (alpha1) {
            let invAlpha1 = alpha1 ^ 0xff;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the pin light blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.pinLightOntoTransparentFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
/**
 * Blend the given layer onto the fusion using the pin light blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.pinLightOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0, alpha2, color1, color2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, alpha12 = alpha1 * alpha2 / 255 | 0, alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0, alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;
            fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
// Blending operations with non-standard variants 
/**
 * Blend the given layer onto the fusion using the passthrough blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.passthroughOntoOpaqueFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2 = 255, alphaMix = layerAlpha / 100, invAlphaMix = 1.0 - alphaMix;
        let realAlpha = alpha1 * alphaMix + alpha2 * invAlphaMix;
        // Effectively use pre-multiplied alpha so that fully transparent colors have no effect on the result
        fusion.data[pixIndex] = (layer.data[pixIndex] * alpha1 * alphaMix + fusion.data[pixIndex] * alpha2 * invAlphaMix) / realAlpha | 0;
        fusion.data[pixIndex + 1] = (layer.data[pixIndex + 1] * alpha1 * alphaMix + fusion.data[pixIndex + 1] * alpha2 * invAlphaMix) / realAlpha | 0;
        fusion.data[pixIndex + 2] = (layer.data[pixIndex + 2] * alpha1 * alphaMix + fusion.data[pixIndex + 2] * alpha2 * invAlphaMix) / realAlpha | 0;
        fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = realAlpha;
    }
};
CPBlend.passthroughOntoOpaqueFusionWithOpaqueLayer = CPBlend.passthroughOntoOpaqueFusionWithTransparentLayer;
/**
 * Blend the given layer onto the fusion using the passthrough blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.passthroughOntoTransparentFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET], alphaMix = layerAlpha / 100, invAlphaMix = 1.0 - alphaMix;
        let realAlpha = alpha1 * alphaMix + alpha2 * invAlphaMix;
        // Effectively use pre-multiplied alpha so that fully transparent colors have no effect on the result
        fusion.data[pixIndex] = (layer.data[pixIndex] * alpha1 * alphaMix + fusion.data[pixIndex] * alpha2 * invAlphaMix) / realAlpha | 0;
        fusion.data[pixIndex + 1] = (layer.data[pixIndex + 1] * alpha1 * alphaMix + fusion.data[pixIndex + 1] * alpha2 * invAlphaMix) / realAlpha | 0;
        fusion.data[pixIndex + 2] = (layer.data[pixIndex + 2] * alpha1 * alphaMix + fusion.data[pixIndex + 2] * alpha2 * invAlphaMix) / realAlpha | 0;
        fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = realAlpha;
    }
};
CPBlend.passthroughOntoTransparentFusionWithOpaqueLayer = CPBlend.passthroughOntoTransparentFusionWithTransparentLayer;
/**
 * Blend the given layer onto the fusion using the passthrough blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.passthroughOntoOpaqueFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2 = 255, alphaMix = mask.data[maskIndex] * layerAlpha / 25500, invAlphaMix = 1.0 - alphaMix;
        let realAlpha = alpha1 * alphaMix + alpha2 * invAlphaMix;
        // Effectively use pre-multiplied alpha so that fully transparent colors have no effect on the result
        fusion.data[pixIndex] = (layer.data[pixIndex] * alpha1 * alphaMix + fusion.data[pixIndex] * alpha2 * invAlphaMix) / realAlpha | 0;
        fusion.data[pixIndex + 1] = (layer.data[pixIndex + 1] * alpha1 * alphaMix + fusion.data[pixIndex + 1] * alpha2 * invAlphaMix) / realAlpha | 0;
        fusion.data[pixIndex + 2] = (layer.data[pixIndex + 2] * alpha1 * alphaMix + fusion.data[pixIndex + 2] * alpha2 * invAlphaMix) / realAlpha | 0;
        fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = realAlpha;
    }
};
CPBlend.passthroughOntoOpaqueFusionWithOpaqueLayerMasked = CPBlend.passthroughOntoOpaqueFusionWithTransparentLayerMasked;
/**
 * Blend the given layer onto the fusion using the passthrough blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.passthroughOntoTransparentFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET], alphaMix = mask.data[maskIndex] * layerAlpha / 25500, invAlphaMix = 1.0 - alphaMix;
        let realAlpha = alpha1 * alphaMix + alpha2 * invAlphaMix;
        // Effectively use pre-multiplied alpha so that fully transparent colors have no effect on the result
        fusion.data[pixIndex] = (layer.data[pixIndex] * alpha1 * alphaMix + fusion.data[pixIndex] * alpha2 * invAlphaMix) / realAlpha | 0;
        fusion.data[pixIndex + 1] = (layer.data[pixIndex + 1] * alpha1 * alphaMix + fusion.data[pixIndex + 1] * alpha2 * invAlphaMix) / realAlpha | 0;
        fusion.data[pixIndex + 2] = (layer.data[pixIndex + 2] * alpha1 * alphaMix + fusion.data[pixIndex + 2] * alpha2 * invAlphaMix) / realAlpha | 0;
        fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = realAlpha;
    }
};
CPBlend.passthroughOntoTransparentFusionWithOpaqueLayerMasked = CPBlend.passthroughOntoTransparentFusionWithTransparentLayerMasked;
// These "replace" routines disregard the original contents of the fusion, so we need not make both an opaque and transparent fusion variant
/**
 * Blend the given layer onto the fusion using the replace blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.replaceOntoFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0;
        fusion.data[pixIndex] = layer.data[pixIndex];
        fusion.data[pixIndex + 1] = layer.data[pixIndex + 1];
        fusion.data[pixIndex + 2] = layer.data[pixIndex + 2];
        fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = alpha1;
    }
};
/**
 * Blend the given layer onto the fusion using the replace blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.replaceOntoFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];
        fusion.data[pixIndex] = layer.data[pixIndex];
        fusion.data[pixIndex + 1] = layer.data[pixIndex + 1];
        fusion.data[pixIndex + 2] = layer.data[pixIndex + 2];
        fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = alpha1;
    }
};
/**
 * Blend the given layer onto the fusion using the replace blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.replaceOntoFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0;
        fusion.data[pixIndex] = layer.data[pixIndex];
        fusion.data[pixIndex + 1] = layer.data[pixIndex + 1];
        fusion.data[pixIndex + 2] = layer.data[pixIndex + 2];
        fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = alpha1;
    }
};
/**
 * Blend the given layer onto the fusion using the replace blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.replaceOntoFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0;
        fusion.data[pixIndex] = layer.data[pixIndex];
        fusion.data[pixIndex + 1] = layer.data[pixIndex + 1];
        fusion.data[pixIndex + 2] = layer.data[pixIndex + 2];
        fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = alpha1;
    }
};
/**
 * Blend the given layer onto the fusion using the replaceAlpha blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.replaceAlphaOntoFusionWithTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0;
        fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = alpha1;
    }
};
/**
 * Blend the given layer onto the fusion using the replaceAlpha blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.replaceAlphaOntoFusionWithTransparentLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] * layerAlpha / 25500 | 0;
        fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = alpha1;
    }
};
/**
 * Blend the given layer onto the fusion using the replaceAlpha blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.replaceAlphaOntoFusionWithOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];
        fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = alpha1;
    }
};
/**
 * Blend the given layer onto the fusion using the replaceAlpha blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * The given alpha mask will be multiplied with the layer alpha before blending.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {CPGreyBmp} mask
 * 
 */ CPBlend.replaceAlphaOntoFusionWithOpaqueLayerMasked = function(fusion, layer, layerAlpha, srcRect, mask) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideMask = mask.width - w | 0, maskIndex = mask.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, maskIndex += yStrideMask)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, maskIndex++){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * mask.data[maskIndex] / 255 | 0;
        fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = alpha1;
    }
};
/**
 * Modify the given layer using the multiplyUpgrade blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.upgradeMultiplyOfOpaqueLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], color1, color2;
        if (alpha1) {
            // Legacy formula: color2 - Math.floor(((color1 ^ 0xFF) * color2 * alpha1) / (255 * 255))
            // New formula:    color2 -  Math.ceil(((color1 ^ 0xFF) * color2 * alpha1) / (255 * 255))
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            layer.data[pixIndex] = color1 + Math.ceil((255 - color1) * color2 * alpha1 % 65025 / (color2 * alpha1));
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            layer.data[pixIndex + 1] = color1 + Math.ceil((255 - color1) * color2 * alpha1 % 65025 / (color2 * alpha1));
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            layer.data[pixIndex + 2] = color1 + Math.ceil((255 - color1) * color2 * alpha1 % 65025 / (color2 * alpha1));
        }
    }
};
/**
 * Modify the given layer using the multiplyUpgrade blending operator.
 * 
 * The layer alpha must be less than 100
 * 
 * Fusion pixels must be opaque.
 * 
 * The destination co-ordinates will be the same as the source ones, so both fusion and layer
 * must be the same dimensions.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * 
 */ CPBlend.upgradeMultiplyOfTransparentLayer = function(fusion, layer, layerAlpha, srcRect) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layerAlpha / 100 | 0, color1, color2;
        if (alpha1) {
            // Legacy formula: color2 - Math.floor(((color1 ^ 0xFF) * color2 * alpha1) / (255 * 255))
            // New formula:    color2 -  Math.ceil(((color1 ^ 0xFF) * color2 * alpha1) / (255 * 255))
            color1 = layer.data[pixIndex];
            color2 = fusion.data[pixIndex];
            layer.data[pixIndex] = color1 + Math.ceil((255 - color1) * color2 * alpha1 % 65025 / (color2 * alpha1));
            color1 = layer.data[pixIndex + 1];
            color2 = fusion.data[pixIndex + 1];
            layer.data[pixIndex + 1] = color1 + Math.ceil((255 - color1) * color2 * alpha1 % 65025 / (color2 * alpha1));
            color1 = layer.data[pixIndex + 2];
            color2 = fusion.data[pixIndex + 2];
            layer.data[pixIndex + 2] = color1 + Math.ceil((255 - color1) * color2 * alpha1 % 65025 / (color2 * alpha1));
        }
    }
};
/**
 * Blend the given layer onto the fusion using the normal blending operator.
 * 
 * The layer must have its layer alpha set to 100
 * 
 * Fusion can contain transparent pixels.
 * 
 * The destination's top left will be at destX, destY. The fusion can be a different size to
 * the layer.
 * 
 * @param {CPColorBmp} fusion
 * @param {CPColorBmp} layer
 * @param {int} layerAlpha
 * @param {CPRect} srcRect
 * @param {int} destX
 * @param {int} destY
 * 
 */ CPBlend._normalFuseImageOntoImageAtPosition = function(fusion, layer, layerAlpha, srcRect, destX, destY) {
    let h = srcRect.getHeight() | 0, w = srcRect.getWidth() | 0, yStride = (layer.width - w) * BYTES_PER_PIXEL | 0, pixIndex = layer.offsetOfPixel(srcRect.left, srcRect.top) | 0, yStrideDest = (fusion.width - w) * BYTES_PER_PIXEL | 0, pixIndexDest = fusion.offsetOfPixel(destX, destY) | 0;
    for(let y = 0; y < h; y++, pixIndex += yStride, pixIndexDest += yStrideDest)for(let x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL, pixIndexDest += BYTES_PER_PIXEL){
        let alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET], alpha2;
        if (alpha1) {
            alpha2 = fusion.data[pixIndexDest + ALPHA_BYTE_OFFSET];
            let newAlpha = alpha1 + alpha2 - (alpha1 * alpha2 / 255 | 0) | 0, realAlpha = alpha1 * 255 / newAlpha | 0, invAlpha = 255 - realAlpha;
            fusion.data[pixIndexDest] = (layer.data[pixIndex] * realAlpha + fusion.data[pixIndexDest] * invAlpha) / 255 | 0;
            fusion.data[pixIndexDest + 1] = (layer.data[pixIndex + 1] * realAlpha + fusion.data[pixIndexDest + 1] * invAlpha) / 255 | 0;
            fusion.data[pixIndexDest + 2] = (layer.data[pixIndex + 2] * realAlpha + fusion.data[pixIndexDest + 2] * invAlpha) / 255 | 0;
            fusion.data[pixIndexDest + ALPHA_BYTE_OFFSET] = newAlpha;
        }
    }
};
function makeLookupTables() {
    // V - V^2 table
    for(let i = 0; i < 256; i++){
        let v = i / 255;
        softLightLUTSquare[i] = (v - v * v) * 255 | 0;
    }
    // sqrt(V) - V table
    for(let i = 0; i < 256; i++){
        let v = i / 255;
        softLightLUTSquareRoot[i] = (Math.sqrt(v) - v) * 255 | 0;
    }
}
CPBlend.LM_NORMAL = 0;
CPBlend.LM_MULTIPLY = 1;
CPBlend.LM_ADD = 2;
CPBlend.LM_SCREEN = 3;
CPBlend.LM_LIGHTEN = 4;
CPBlend.LM_DARKEN = 5;
CPBlend.LM_SUBTRACT = 6;
CPBlend.LM_DODGE = 7;
CPBlend.LM_BURN = 8;
CPBlend.LM_OVERLAY = 9;
CPBlend.LM_HARDLIGHT = 10;
CPBlend.LM_SOFTLIGHT = 11;
CPBlend.LM_VIVIDLIGHT = 12;
CPBlend.LM_LINEARLIGHT = 13;
CPBlend.LM_PINLIGHT = 14;
CPBlend.LM_PASSTHROUGH = 15;
CPBlend.LM_MULTIPLY2 = 16;
CPBlend.LM_FIRST = 0;
CPBlend.LM_LAST = 16;
CPBlend.LM_LAST_CHIBIPAINT = CPBlend.LM_PINLIGHT;
CPBlend.BLEND_MODE_CODENAMES = [
    "normal",
    "multiply",
    "add",
    "screen",
    "lighten",
    "darken",
    "subtract",
    "dodge",
    "burn",
    "overlay",
    "hardLight",
    "softLight",
    "vividLight",
    "linearLight",
    "pinLight",
    "passthrough",
    "multiply2"
];
CPBlend.BLEND_MODE_DISPLAY_NAMES = [
    "Normal",
    "Multiply",
    "Add",
    "Screen",
    "Lighten",
    "Darken",
    "Subtract",
    "Dodge",
    "Burn",
    "Overlay",
    "Hard Light",
    "Soft Light",
    "Vivid Light",
    "Linear Light",
    "Pin Light",
    "Passthrough",
    "Multiply"
];
makeLookupTables();

},{"./CPColorBmp.js":"5rykl","./CPGreyBmp.js":"fGKWG","./CPLayer.js":"1fr05","../util/CPRect.js":"aDqvw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fGKWG":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPGreyBmp);
var _cpbitmapJs = require("./CPBitmap.js");
var _cpbitmapJsDefault = parcelHelpers.interopDefault(_cpbitmapJs);
var _cprectJs = require("../util/CPRect.js");
var _cprectJsDefault = parcelHelpers.interopDefault(_cprectJs);
var _canvasJs = require("../util/Canvas.js");
var _cpcolorBmpJs = require("./CPColorBmp.js");
function CPGreyBmp(width, height, bitDepth) {
    (0, _cpbitmapJsDefault.default).call(this, width, height);
    this.createBitmap(width, height, bitDepth);
}
CPGreyBmp.prototype = Object.create((0, _cpbitmapJsDefault.default).prototype);
CPGreyBmp.prototype.constructor = CPGreyBmp;
CPGreyBmp.prototype.createBitmap = function(width, height, bitDepth) {
    this.bitDepth = bitDepth;
    switch(bitDepth){
        case 32:
            this.data = new Uint32Array(width * height);
            break;
        case 16:
            this.data = new Uint16Array(width * height);
            break;
        case 8:
        default:
            this.data = new Uint8Array(width * height);
    }
};
CPGreyBmp.prototype.clone = function() {
    var result = new CPGreyBmp(this.width, this.height, this.bitDepth);
    result.copyPixelsFrom(this);
    return result;
};
/**
 * Creates a CPGreyBmp from a portion of this bitmap
 *
 * @param {CPRect} rect
 * @returns {CPGreyBmp}
 */ CPGreyBmp.prototype.cloneRect = function(rect) {
    var result = new CPGreyBmp(rect.getWidth(), rect.getHeight(), this.bitDepth);
    result.copyBitmapRect(this, 0, 0, rect);
    return result;
};
/**
 * Pixel access with friendly clipping.
 *
 * @returns {int} Pixel value
 */ CPGreyBmp.prototype.getPixel = function(x, y) {
    x = Math.max(0, Math.min(this.width - 1, x));
    y = Math.max(0, Math.min(this.height - 1, y));
    return this.data[this.offsetOfPixel(x, y)];
};
CPGreyBmp.prototype.clearAll = function(value) {
    this.data.fill(value);
};
/**
 * Fill the given rectangle with the given value
 *
 * @param {CPRect} rect
 * @param {number} value
 */ CPGreyBmp.prototype.clearRect = function(rect, value) {
    rect = this.getBounds().clipTo(rect);
    if (rect.equals(this.getBounds())) this.clearAll(value);
    else {
        let yStride = this.width, fillWidth = rect.right - rect.left, rowStartIndex = this.offsetOfPixel(rect.left, rect.top);
        for(let y = rect.top; y < rect.bottom; y++, rowStartIndex += yStride)this.data.fill(value, rowStartIndex, rowStartIndex + fillWidth);
    }
};
/**
 * Use nearest-neighbor (subsampling) to scale that bitmap to replace the pixels of this one.
 *
 * @param {CPGreyBmp} that
 */ CPGreyBmp.prototype.copyScaledNearestNeighbor = function(that) {
    var destPixIndex = 0, xSkip = that.width / this.width, ySkip = that.height / this.height, srcRowStart;
    for(var y = 0, srcRow = 0; y < this.height; y++, srcRow += ySkip){
        srcRowStart = that.offsetOfPixel(0, Math.round(srcRow));
        for(var x = 0, srcCol = 0; x < this.width; x++, destPixIndex++, srcCol += xSkip){
            var srcPixIndex = srcRowStart + Math.round(srcCol);
            this.data[destPixIndex] = that.data[srcPixIndex];
        }
    }
};
/**
 * Flood fill the given color starting from the given point
 * @param {number} x
 * @param {number} y
 * @param {number} color
 */ CPGreyBmp.prototype.floodFill = function(x, y, color) {
    if (!this.isInside(x, y)) return;
    color = color & 0xFF;
    let oldColor = this.getPixel(x, y), stack = [], clip = this.getBounds(), data = this.data;
    stack.push({
        x1: x,
        x2: x,
        y: y,
        dy: -1
    });
    stack.push({
        x1: x,
        x2: x,
        y: y + 1,
        dy: 1
    });
    if (color == oldColor) return;
    while(stack.length > 0){
        let line = stack.pop();
        if (line.y < clip.top || line.y >= clip.bottom) continue;
        let lineOffset = this.offsetOfPixel(0, line.y), left = line.x1, next;
        while(left >= clip.left && data[left + lineOffset] == oldColor){
            data[left + lineOffset] = color;
            left--;
        }
        if (left >= line.x1) {
            while(left <= line.x2 && data[left + lineOffset] != oldColor)left++;
            next = left + 1;
            if (left > line.x2) continue;
        } else {
            left++;
            if (left < line.x1) stack.push({
                x1: left,
                x2: line.x1 - 1,
                y: line.y - line.dy,
                dy: -line.dy
            });
            next = line.x1 + 1;
        }
        do {
            data[left + lineOffset] = color;
            while(next < clip.right && data[next + lineOffset] == oldColor){
                data[next + lineOffset] = color;
                next++;
            }
            stack.push({
                x1: left,
                x2: next - 1,
                y: line.y + line.dy,
                dy: line.dy
            });
            if (next - 1 > line.x2) stack.push({
                x1: line.x2 + 1,
                x2: next - 1,
                y: line.y - line.dy,
                dy: -line.dy
            });
            left = next + 1;
            while(left <= line.x2 && data[left + lineOffset] != oldColor)left++;
            next = left + 1;
        }while (left <= line.x2);
    }
};
/**
 * Replace the pixels in this image with a scaled down thumbnail of that image.
 *
 * @param {CPGreyBmp} that
 */ CPGreyBmp.prototype.createThumbnailFrom = function(that) {
    const MAX_SAMPLES_PER_OUTPUT_PIXEL = 3, numSamples = Math.min(Math.floor(that.width / this.width), MAX_SAMPLES_PER_OUTPUT_PIXEL);
    if (numSamples < 2) {
        // If we only take one sample per output pixel, there's no need for our filtering strategy
        this.copyScaledNearestNeighbor(that);
        return;
    }
    const rowBuffer = new Uint16Array(this.width), srcRowByteLength = that.width, sourceBytesBetweenOutputCols = Math.floor(that.width / this.width), intersampleXByteSpacing = Math.floor(that.width / this.width / numSamples), /* Due to the floor() in intersampleXByteSkip, it's likely that the gap between the last sample for an output pixel
     * and the start of the sample for the next pixel will be higher than the intersample gap. So we'll add this between
     * pixels if needed.
     */ interpixelXByteSkip = sourceBytesBetweenOutputCols - intersampleXByteSpacing * numSamples, // Now we do the same for rows...
    sourceRowsBetweenOutputRows = Math.floor(that.height / this.height), intersampleYRowsSpacing = Math.floor(that.height / this.height / numSamples), intersampleYByteSkip = intersampleYRowsSpacing * srcRowByteLength - sourceBytesBetweenOutputCols * this.width, interpixelYByteSkip = (sourceRowsBetweenOutputRows - intersampleYRowsSpacing * numSamples) * srcRowByteLength;
    let srcPixIndex = 0, dstPixIndex = 0;
    // For each output thumbnail row...
    for(let y = 0; y < this.height; y++, srcPixIndex += interpixelYByteSkip){
        let bufferIndex = 0;
        rowBuffer.fill(0);
        // Sum the contributions of the input rows that correspond to this output row
        for(let y2 = 0; y2 < numSamples; y2++, srcPixIndex += intersampleYByteSkip){
            bufferIndex = 0;
            for(let x = 0; x < this.width; x++, bufferIndex++, srcPixIndex += interpixelXByteSkip)for(let x2 = 0; x2 < numSamples; x2++, srcPixIndex += intersampleXByteSpacing)rowBuffer[bufferIndex] += that.data[srcPixIndex];
        }
        // Now this thumbnail row is complete and we can write the buffer to the output
        bufferIndex = 0;
        for(let x = 0; x < this.width; x++, bufferIndex++, dstPixIndex++)this.data[dstPixIndex] = rowBuffer[bufferIndex] / (numSamples * numSamples);
    }
};
CPGreyBmp.prototype.mirrorHorizontally = function() {
    let width = this.width, height = this.height, newData = new Uint8Array(width * height), dstOffset = 0, srcOffset = width;
    for(let y = 0; y < height; y++, srcOffset += width + width)for(let x = 0; x < width; x++)newData[dstOffset++] = this.data[--srcOffset];
    this.data = newData;
};
CPGreyBmp.prototype.applyLUT = function(lut) {
    for(var i = 0; i < this.data.length; i++)this.data[i] = lut.table[this.data[i]];
};
/**
 * Get the image as Canvas.
 *
 * @param {int?} imageRotation - 90 degree clockwise rotations to apply to image
 * @returns {HTMLCanvasElement}
 */ CPGreyBmp.prototype.getAsCanvas = function(imageRotation) {
    var imageData = this.getImageData(0, 0, this.width, this.height), canvas = (0, _canvasJs.createCanvas)(this.width, this.height), context = canvas.getContext("2d");
    context.putImageData(imageData, 0, 0);
    return (0, _cpcolorBmpJs.getRotatedCanvas)(canvas, imageRotation || 0);
};
/**
 * Get the image data within the given rectangle as an opaque RGBA ImageData object.
 *
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 *
 * @returns {ImageData}
 */ CPGreyBmp.prototype.getImageData = function(x, y, width, height) {
    let imageData = (0, _canvasJs.createImageData)(width, height), srcIndex = this.offsetOfPixel(x, y), dstIndex = 0, ySkip = this.width - width;
    for(let y = 0; y < height; y++, srcIndex += ySkip)for(let x = 0; x < width; x++, srcIndex++){
        imageData.data[dstIndex++] = this.data[srcIndex];
        imageData.data[dstIndex++] = this.data[srcIndex];
        imageData.data[dstIndex++] = this.data[srcIndex];
        imageData.data[dstIndex++] = 0xFF;
    }
    return imageData;
};
/**
 * Replace the pixels at the given coordinates with the red channel from the given image data.
 *
 * @param {ImageData} imageData
 * @param {number} x
 * @param {number} y
 */ CPGreyBmp.prototype.pasteImageData = function(imageData, x, y) {
    let srcIndex = 0, dstIndex = this.offsetOfPixel(x, y), ySkip = this.width - imageData.width;
    for(let y = 0; y < imageData.height; y++, dstIndex += ySkip)for(let x = 0; x < imageData.width; x++, srcIndex += 4, dstIndex++)this.data[dstIndex] = imageData.data[srcIndex]; // Use the first (red) channel as the intensity
    return imageData;
};
/**
 * Copy pixels from that bitmap.
 *
 * @param {CPGreyBmp} bmp
 */ CPGreyBmp.prototype.copyPixelsFrom = function(bmp) {
    if (bmp.width != this.width || bmp.height != this.height || bmp.bitDepth != this.bitDepth) {
        this.data = bmp.data.slice(0);
        this.width = bmp.width;
        this.height = bmp.height;
        this.bitDepth = bmp.bitDepth;
    } else this.data.set(bmp.data);
};
/**
 * Get a pixel array of the xor of this bitmap and the given one, within the given rectangle
 *
 * @param {CPGreyBmp} bmp
 * @param {CPRect} rect
 *
 * @returns {Uint8Array}
 */ CPGreyBmp.prototype.copyRectXOR = function(bmp, rect) {
    rect = this.getBounds().clipTo(rect);
    var w = rect.getWidth(), h = rect.getHeight(), buffer = new Uint8Array(w * h), outputIndex = 0, bmp1Index = this.offsetOfPixel(rect.left, rect.top), bmp2Index = bmp.offsetOfPixel(rect.left, rect.top), bmp1YSkip = this.width - w, bmp2YSkip = bmp.width - w;
    for(var y = rect.top; y < rect.bottom; y++, bmp1Index += bmp1YSkip, bmp2Index += bmp2YSkip)for(var x = 0; x < w; x++, outputIndex++, bmp1Index++, bmp2Index++)buffer[outputIndex] = this.data[bmp1Index] ^ bmp.data[bmp2Index];
    return buffer;
};
CPGreyBmp.prototype.setRectXOR = function(buffer, rect) {
    rect = this.getBounds().clipTo(rect);
    var w = rect.getWidth(), h = rect.getHeight(), bmp1Index = this.offsetOfPixel(rect.left, rect.top), bufferIndex = 0, bmp1YSkip = this.width - w;
    for(var y = 0; y < h; y++){
        for(var x = 0; x < w; x++)this.data[bmp1Index++] ^= buffer[bufferIndex++];
        bmp1Index += bmp1YSkip;
    }
};
/**
 * Copy the rectangle at srcRect from bmp onto this image at (dstX, dstY).
 *
 * @param {CPGreyBmp} bmp
 * @param {number} dstX
 * @param {number} dstY
 * @param {CPRect} srcRect
 */ CPGreyBmp.prototype.copyBitmapRect = function(bmp, dstX, dstY, srcRect) {
    var dstRect = new (0, _cprectJsDefault.default)(dstX, dstY, 0, 0);
    srcRect = srcRect.clone();
    this.getBounds().clipSourceDest(srcRect, dstRect);
    var w = dstRect.getWidth() | 0, h = dstRect.getHeight() | 0;
    // Are we just trying to duplicate the bitmap?
    if (dstRect.left == 0 && dstRect.top == 0 && w == this.width && h == this.height && w == bmp.width && h == bmp.height) this.copyPixelsFrom(bmp);
    else {
        var dstIndex = this.offsetOfPixel(dstRect.left, dstRect.top), dstYSkip = this.width - w, srcIndex = bmp.offsetOfPixel(srcRect.left, srcRect.top), srcYSkip = bmp.width - w;
        for(var y = 0; y < h; y++, srcIndex += srcYSkip, dstIndex += dstYSkip)for(var x = 0; x < w; x++, srcIndex++, dstIndex++)this.data[dstIndex] = bmp.data[srcIndex];
    }
};
/**
 * @param rect CPRect
 * @param source CPColorBmp
 */ CPGreyBmp.prototype.copyRegionHFlip = function(rect, source) {
    rect = this.getBounds().clipTo(rect);
    for(var y = rect.top; y < rect.bottom; y++){
        var dstOffset = this.offsetOfPixel(rect.left, y), srcOffset = source.offsetOfPixel(rect.right - 1, y);
        for(var x = rect.left; x < rect.right; x++, srcOffset -= 2)this.data[dstOffset++] = source.data[srcOffset++];
    }
};
/**
 * @param rect CPRect
 * @param source CPColorBmp
 */ CPGreyBmp.prototype.copyRegionVFlip = function(rect, source) {
    rect = this.getBounds().clipTo(rect);
    var width = rect.getWidth();
    for(var y = rect.top; y < rect.bottom; y++){
        var dstOffset = this.offsetOfPixel(rect.left, y), srcOffset = source.offsetOfPixel(rect.left, rect.bottom - 1 - (y - rect.top));
        for(var x = 0; x < width; x++)this.data[dstOffset++] = source.data[srcOffset++];
    }
};
/**
 * Blur the first `len` pixels in the src array by `radius` pixels, and store the result in the `dst` array.
 *
 * @param {Uint8Array} src
 * @param {Uint8Array} dst
 * @param {number} len
 * @param {number} radius - Number of pixels that will be averaged either side of a target pixel.
 */ function boxBlurLine(src, dst, len, radius) {
    var pixelCount = 0, pixelSum = 0, dstIndex;
    for(let i = 0; i < radius && i < len; i++){
        pixelSum += src[i];
        pixelCount++;
    }
    dstIndex = 0;
    for(let i = 0; i < len; i++){
        // New pixel joins the window at the right
        if (i + radius < len) {
            pixelSum += src[i + radius];
            pixelCount++;
        }
        dst[dstIndex++] = Math.round(pixelSum / pixelCount);
        // Old pixel leaves the window at the left
        if (i - radius >= 0) {
            pixelSum -= src[i - radius];
            pixelCount--;
        }
    }
}
/**
 * Copy a column of pixels in the bitmap to the given R,G,B,A buffer.
 *
 * @param {number} x X-coordinate of column
 * @param {number} y Y-coordinate of top of column to copy
 * @param {number} len Number of pixels to copy
 * @param {TypedArray} buffer Pixel array
 */ CPGreyBmp.prototype.copyPixelColumnToArray = function(x, y, len, buffer) {
    var yJump = this.width, dstOffset = 0, srcOffset = this.offsetOfPixel(x, y);
    for(var i = 0; i < len; i++){
        buffer[dstOffset] = this.data[srcOffset];
        srcOffset += yJump;
        dstOffset++;
    }
};
/**
 * Copy the pixels from the buffer to a column of pixels in the bitmap.
 *
 * @param {number} x X-coordinate of column
 * @param {number} y Y-coordinate of top of column to copy
 * @param {number} len Number of pixels to copy
 * @param {TypedArray} buffer Pixel array to copy from
 */ CPGreyBmp.prototype.copyArrayToPixelColumn = function(x, y, len, buffer) {
    var yJump = this.width, srcOffset = 0, dstOffset = this.offsetOfPixel(x, y);
    for(var i = 0; i < len; i++){
        this.data[dstOffset] = buffer[srcOffset];
        dstOffset += yJump;
        srcOffset++;
    }
};
CPGreyBmp.prototype.boxBlur = function(rect, radiusX, radiusY) {
    rect = this.getBounds().clipTo(rect);
    let rectWidth = rect.getWidth(), rectHeight = rect.getHeight(), rectLength = Math.max(rectWidth, rectHeight), src = new this.data.constructor(rectLength), dst = new this.data.constructor(rectLength);
    for(let y = rect.top; y < rect.bottom; y++){
        var pixOffset = this.offsetOfPixel(rect.left, y);
        for(let x = 0; x < rectWidth; x++)src[x] = this.data[pixOffset++];
        boxBlurLine(src, dst, rectWidth, radiusX);
        pixOffset = this.offsetOfPixel(rect.left, y);
        for(let x = 0; x < rectWidth; x++)this.data[pixOffset++] = dst[x];
    }
    for(let x = rect.left; x < rect.right; x++){
        this.copyPixelColumnToArray(x, rect.top, rectHeight, src);
        boxBlurLine(src, dst, rectHeight, radiusY);
        this.copyArrayToPixelColumn(x, rect.top, rectHeight, dst);
    }
};
CPGreyBmp.prototype.offsetOfPixel = function(x, y) {
    return y * this.width + x;
};
/**
 * @param {CPRect} rect
 */ CPGreyBmp.prototype.fillWithNoise = function(rect) {
    rect = this.getBounds().clipTo(rect);
    var yStride = this.width - rect.getWidth(), pixIndex = this.offsetOfPixel(rect.left, rect.top);
    for(var y = rect.top; y < rect.bottom; y++, pixIndex += yStride)for(var x = rect.left; x < rect.right; x++, pixIndex++)this.data[pixIndex] = Math.random() * 0x100 | 0; // TODO we might usefully support bitmaps > 8 bits/channel here?
};
/**
 * @param {CPRect} rect
 */ CPGreyBmp.prototype.invert = function(rect) {
    rect = this.getBounds().clipTo(rect);
    var yStride = this.width - rect.getWidth(), pixIndex = this.offsetOfPixel(rect.left, rect.top);
    for(var y = rect.top; y < rect.bottom; y++, pixIndex += yStride)for(var x = rect.left; x < rect.right; x++, pixIndex++)this.data[pixIndex] = ~this.data[pixIndex];
};
/**
 * @param {CPRect} rect
 */ CPGreyBmp.prototype.brightnessToOpacity = function(rect) {
    rect = this.getBounds().clipTo(rect);
    const threshold = 250;
    const yStride = (this.width - rect.getWidth()) * CPGreyBmp.BYTES_PER_PIXEL;
    let pixIndex = this.offsetOfPixel(rect.left, rect.top);
    for(let y = rect.top; y < rect.bottom; y++, pixIndex += yStride)for(let x = rect.left; x < rect.right; x++, pixIndex++){
        // 輝度の計算（グレースケール画像なので直接値を使用）
        const brightness = this.data[pixIndex];
        // 元のアルファ値を取得
        const originalAlpha = this.data[pixIndex + CPGreyBmp.ALPHA_BYTE_OFFSET] / 255;
        // しきい値を基に透明度を設定
        let newAlpha;
        if (brightness > threshold) newAlpha = 0; // 完全に透明
        else // 線形にマッピングして中間の透明度を計算 (輝度が高いほど透明に近づく)
        newAlpha = Math.round((1 - brightness / threshold) * 255);
        // 元のアルファ値を考慮して透明度を更新
        this.data[pixIndex + CPGreyBmp.ALPHA_BYTE_OFFSET] = Math.round(newAlpha * originalAlpha);
        // 不透明な線画の明度を低下させる
        if (newAlpha > 0) this.data[pixIndex] = 0;
    }
};
/**
 * Get a rectangle that encloses pixels in the bitmap which don't match the given value within the given initialBounds
 * (or an empty rect if all pixels inside the given bounds match the value).
 *
 * This can be used to find a rectangle which encloses the non-white pixels of a mask.
 *
 * @param {CPRect} initialBounds - The rect to search within (pass getBounds() to search the whole bitmap)
 * @param {number} value
 *
 * @returns {CPRect}
 */ CPGreyBmp.prototype.getValueBounds = function(initialBounds, value) {
    var pixIndex, result = initialBounds.clone(), x, y, yStride, found;
    // Find the first non-matching row
    yStride = this.width - result.getWidth();
    pixIndex = this.offsetOfPixel(result.left, result.top);
    for(y = result.top; y < result.bottom; y++, pixIndex += yStride){
        found = false;
        for(x = result.left; x < result.right; x++, pixIndex++)if (this.data[pixIndex] != value) {
            found = true;
            break;
        }
        if (found) break;
    }
    result.top = y;
    if (result.top == result.bottom) // Rect is empty, no opaque pixels in the initialBounds
    return result;
    // Now the last non-matching row
    pixIndex = this.offsetOfPixel(result.right - 1, result.bottom - 1);
    for(y = result.bottom - 1; y >= result.top; y--, pixIndex -= yStride){
        found = false;
        for(x = result.right - 1; x >= result.left; x--, pixIndex--)if (this.data[pixIndex] != value) {
            found = true;
            break;
        }
        if (found) break;
    }
    result.bottom = y + 1; /* +1 since the bottom/right edges of the rect are exclusive */ 
    // Now columns from the left
    yStride = this.width;
    for(x = result.left; x < result.right; x++){
        pixIndex = this.offsetOfPixel(x, result.top);
        found = false;
        for(y = result.top; y < result.bottom; y++, pixIndex += yStride)if (this.data[pixIndex] != value) {
            found = true;
            break;
        }
        if (found) break;
    }
    result.left = x;
    // And columns from the right
    for(x = result.right - 1; x >= result.left; x--){
        pixIndex = this.offsetOfPixel(x, result.top);
        found = false;
        for(y = result.top; y < result.bottom; y++, pixIndex += yStride)if (this.data[pixIndex] != value) {
            found = true;
            break;
        }
        if (found) break;
    }
    result.right = x + 1;
    return result;
};
/**
 * Replace the pixels in the given rect with the given horizontal gradient.
 *
 * @param rect CPRect
 * @param fromX int
 * @param toX int
 * @param gradientPoints int[]
 */ CPGreyBmp.prototype.gradientHorzReplace = function(rect, fromX, toX, gradientPoints) {
    var fromColor = gradientPoints[0] & 0xFF, toColor = gradientPoints[1] & 0xFF, yStride = this.width - rect.getWidth(), pixIndex = this.offsetOfPixel(rect.left, rect.top) | 0, h = rect.bottom - rect.top | 0;
    if (toX < fromX) {
        var temp = toX;
        toX = fromX;
        fromX = temp;
        temp = fromColor;
        fromColor = toColor;
        toColor = temp;
    }
    var gradientRange = toX - fromX | 0, colorStep = (toColor - fromColor) / gradientRange, jump = Math.max(rect.left - fromX, 0);
    for(var y = 0; y < h; y++, pixIndex += yStride){
        // The solid color section before the gradient
        var x = rect.left;
        for(var xEnd = Math.min(fromX, rect.right) | 0; x < xEnd; x++, pixIndex++)this.data[pixIndex] = fromColor;
        // In the gradient
        var color1 = fromColor + colorStep * jump;
        for(xEnd = Math.min(toX, rect.right) | 0; x < xEnd; x++, pixIndex++){
            this.data[pixIndex] = color1;
            color1 += colorStep;
        }
        // The section after the end of the gradient
        for(; x < rect.right; x++, pixIndex++)this.data[pixIndex] = toColor;
    }
};
/**
 * Replace the pixels in the given rect with the given vertical gradient.
 *
 * @param {CPRect} rect
 * @param fromY int
 * @param toY int
 * @param gradientPoints int[]
 */ CPGreyBmp.prototype.gradientVertReplace = function(rect, fromY, toY, gradientPoints) {
    let fromColor = gradientPoints[0] & 0xFF, toColor = gradientPoints[1] & 0xFF, yStride = this.width - rect.getWidth(), pixIndex = this.offsetOfPixel(rect.left, rect.top) | 0, w = rect.right - rect.left | 0;
    if (toY < fromY) {
        let temp = toY;
        toY = fromY;
        fromY = temp;
        temp = fromColor;
        fromColor = toColor;
        toColor = temp;
    }
    let y = rect.top;
    // The solid color section before the start of the gradient
    for(let yEnd = Math.min(rect.bottom, fromY) | 0; y < yEnd; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex++)this.data[pixIndex] = fromColor;
    // Inside the gradient
    var gradientRange = toY - fromY | 0, colorStep = (toColor - fromColor) / gradientRange, jump = Math.max(y - fromY, 0), color1 = fromColor + colorStep * jump;
    for(let yEnd = Math.min(rect.bottom, toY) | 0; y < yEnd; y++, pixIndex += yStride){
        for(let x = 0; x < w; x++, pixIndex++)this.data[pixIndex] = color1;
        color1 += colorStep;
    }
    // The section after the end of the gradient
    for(; y < rect.bottom; y++, pixIndex += yStride)for(let x = 0; x < w; x++, pixIndex++)this.data[pixIndex] = toColor;
};
/**
 * Replace the pixels in the given rect with the given gradient.
 *
 * @param rect CPRect
 * @param fromX int
 * @param fromY int
 * @param toX int
 * @param toY int
 * @param gradientPoints int[]
 */ CPGreyBmp.prototype.gradientReplace = function(rect, fromX, fromY, toX, toY, gradientPoints) {
    var yStride = this.width - rect.getWidth(), pixIndex = this.offsetOfPixel(rect.left, rect.top) | 0, w = rect.right - rect.left | 0, fromColor = gradientPoints[0] & 0xFF, toColor = gradientPoints[1] & 0xFF, // How many pixels vertically does the gradient sequence complete over (+infinity for horizontal gradients!)
    vertRange = toY - fromY + (toX - fromX) * (toX - fromX) / (toY - fromY), // Same for horizontal
    horzRange = toX - fromX + (toY - fromY) * (toY - fromY) / (toX - fromX), horzStep = 1 / horzRange;
    for(var y = rect.top; y < rect.bottom; y++, pixIndex += yStride){
        var // The position the row starts at in the gradient [0.0 ... 1.0)
        prop = (rect.left - fromX) / horzRange + (y - fromY) / vertRange;
        for(var x = 0; x < w; x++, pixIndex++){
            var propClamped = Math.min(Math.max(prop, 0.0), 1.0), invPropClamped = 1 - propClamped;
            this.data[pixIndex] = fromColor * invPropClamped + toColor * propClamped;
            prop += horzStep;
        }
    }
};
/**
 * Alpha blend the given gradient onto the pixels in the given rect.
 *
 * @param rect CPRect
 * @param fromX int
 * @param fromY int
 * @param toX int
 * @param toY int
 * @param gradientPoints int[]
 */ CPGreyBmp.prototype.gradientAlpha = function(rect, fromX, fromY, toX, toY, gradientPoints) {
    var yStride = this.width - rect.getWidth(), pixIndex = this.offsetOfPixel(rect.left, rect.top) | 0, w = rect.right - rect.left | 0, fromColor = {
        c: gradientPoints[0] & 0xFF,
        a: gradientPoints[0] >> 24 & 0xFF
    }, toColor = {
        c: gradientPoints[1] & 0xFF,
        a: gradientPoints[1] >> 24 & 0xFF
    }, // How many pixels vertically does the gradient sequence complete over (+infinity for horizontal gradients!)
    vertRange = toY - fromY + (toX - fromX) * (toX - fromX) / (toY - fromY), // Same for horizontal
    horzRange = toX - fromX + (toY - fromY) * (toY - fromY) / (toX - fromX), horzStep = 1 / horzRange;
    for(var y = rect.top; y < rect.bottom; y++, pixIndex += yStride){
        var // The position the row starts at in the gradient [0.0 ... 1.0)
        prop = (rect.left - fromX) / horzRange + (y - fromY) / vertRange;
        for(var x = 0; x < w; x++, pixIndex++){
            var propClamped = Math.min(Math.max(prop, 0.0), 1.0), invPropClamped = 1 - propClamped, // The gradient color to draw
            color1 = fromColor.c * invPropClamped + toColor.c * propClamped, alpha1 = fromColor.a * invPropClamped + toColor.a * propClamped;
            var invAlpha = 255 - alpha1;
            this.data[pixIndex] = (color1 * alpha1 + this.data[pixIndex] * invAlpha) / 255 | 0;
            prop += horzStep;
        }
    }
};
/**
 * Draw a gradient which begins at fromX, fromY and ends at toX, toY, clipped to the given rect, on top of the
 * pixels in the bitmap.
 *
 * @param {CPRect} rect
 * @param {Object[]} gradientPoints Array with gradient colors (ARGB integers)
 * @param {number} fromX
 * @param {number} fromY
 * @param {number} toX
 * @param {number} toY
 * @param {boolean} replace - True if the contents of the destination should be ignored (opaque blend)
 */ CPGreyBmp.prototype.gradient = function(rect, fromX, fromY, toX, toY, gradientPoints, replace) {
    rect = this.getBounds().clipTo(rect);
    // Degenerate case
    if (fromX == toX && fromY == toY) return;
    // Opaque blend if possible
    if (replace || gradientPoints[0] >>> 24 == 255 && gradientPoints[1] >>> 24 == 255) {
        if (fromX == toX) this.gradientVertReplace(rect, fromY, toY, gradientPoints);
        else if (fromY == toY) this.gradientHorzReplace(rect, fromX, toX, gradientPoints);
        else this.gradientReplace(rect, fromX, fromY, toX, toY, gradientPoints);
    } else this.gradientAlpha(rect, fromX, fromY, toX, toY, gradientPoints);
};
CPGreyBmp.prototype.equals = function(that) {
    if (this.width != that.width || this.height != that.height) return false;
    for(let pixIndex = 0; pixIndex < this.data.length; pixIndex++){
        if (this.data[pixIndex] != that.data[pixIndex]) return false;
    }
    return true;
};

},{"./CPBitmap.js":"ibRmc","../util/CPRect.js":"aDqvw","../util/Canvas.js":"bniay","./CPColorBmp.js":"5rykl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dA7oJ":[function(require,module,exports,__globalThis) {
/*
	ChickenPaint

	ChickenPaint is a translation of ChibiPaint from Java to JavaScript
	by Nicholas Sherlock / Chicken Smoothie.

	ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

	ChickenPaint is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	ChickenPaint is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ /**
 * Extra functions for CPBlend that don't need to be generated dynamically.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _cpblendJs = require("./CPBlend.js");
var _cpblendJsDefault = parcelHelpers.interopDefault(_cpblendJs);
var _cprectJs = require("../util/CPRect.js");
var _cprectJsDefault = parcelHelpers.interopDefault(_cprectJs);
var _cpcolorBmpJs = require("./CPColorBmp.js");
var _cpcolorBmpJsDefault = parcelHelpers.interopDefault(_cpcolorBmpJs);
var _cpgreyBmpJs = require("./CPGreyBmp.js");
var _cpgreyBmpJsDefault = parcelHelpers.interopDefault(_cpgreyBmpJs);
const BYTES_PER_PIXEL = 4, ALPHA_BYTE_OFFSET = 3;
(0, _cpblendJsDefault.default).blendFunctionNameForParameters = function(fusionHasTransparency, imageAlpha, imageBlendMode, hasMask) {
    var funcName = (0, _cpblendJsDefault.default).BLEND_MODE_CODENAMES[imageBlendMode] + "Onto";
    if (fusionHasTransparency) funcName += "TransparentFusion";
    else funcName += "OpaqueFusion";
    if (imageAlpha == 100) funcName += "WithOpaqueLayer";
    else funcName += "WithTransparentLayer";
    if (hasMask) funcName += "Masked";
    return funcName;
};
/**
 * Blends the given image on top of the fusion.
 *
 * @param {CPColorBmp} fusion - Image to fuse on top of
 * @param {boolean} fusionHasTransparency - True if the fusion layer has alpha < 100, or any transparent pixels.
 * @param {CPColorBmp} image - Image that should be drawn on top of the fusion
 * @param {number} imageAlpha - Alpha [0...100] to apply to the image
 * @param {number} imageBlendMode - Blending mode (CPBlend.LM_*) to apply to the image
 * @param {CPRect} rect - The rectangle of pixels that should be fused.
 * @param {?CPGreyBmp} mask - An optional mask to apply to the image
 */ (0, _cpblendJsDefault.default).fuseImageOntoImage = function(fusion, fusionHasTransparency, image, imageAlpha, imageBlendMode, rect, mask) {
    if (imageAlpha <= 0) return;
    let funcName = (0, _cpblendJsDefault.default).blendFunctionNameForParameters(fusionHasTransparency, imageAlpha, imageBlendMode, mask != null);
    rect = fusion.getBounds().clipTo(rect);
    this[funcName](fusion, image, imageAlpha, rect, mask);
};
(0, _cpblendJsDefault.default).normalFuseImageOntoImageAtPosition = function(fusion, image, destX, destY, sourceRect) {
    var sourceRectCopy = sourceRect.clone(), destRect = new (0, _cprectJsDefault.default)(destX, destY, 0, 0);
    fusion.getBounds().clipSourceDest(sourceRectCopy, destRect);
    this._normalFuseImageOntoImageAtPosition(fusion, image, 100, sourceRectCopy, destRect.left, destRect.top);
};
/**
 * Multiplies the given alpha into the alpha of the individual pixels of the image.
 *
 * @param {CPColorBmp} image
 * @param {number} alpha - [0...100] alpha to apply
 */ (0, _cpblendJsDefault.default).multiplyAlphaBy = function(image, alpha) {
    if (alpha < 100) {
        if (alpha == 0) image.clearAll(0);
        else {
            var imageData = image.data;
            for(var pixIndex = ALPHA_BYTE_OFFSET; pixIndex < imageData.length; pixIndex += BYTES_PER_PIXEL)imageData[pixIndex] = Math.round(imageData[pixIndex] * alpha / 100);
        }
    }
};
/**
 * Multiplies the values from the mask, and the given overall alpha, into the alpha channel of the image.
 *
 * @param {CPColorBmp} image
 * @param {number} alpha
 * @param {CPGreyBmp} mask
 */ (0, _cpblendJsDefault.default).multiplyAlphaByMask = function(image, alpha, mask) {
    var scale = alpha / 25500;
    for(var dstIndex = (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET, srcIndex = 0; dstIndex < image.data.length; dstIndex += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL, srcIndex++)image.data[dstIndex] = Math.round(image.data[dstIndex] * mask.data[srcIndex] * scale);
};
/**
 * Multiplies the given alpha into the alpha of the individual pixels of the image and stores the
 * resulting pixels into the specified image.
 *
 * @param {CPColorBmp} dest
 * @param {CPColorBmp} image
 * @param {number} alpha - [0...100] alpha to apply
 * @param {CPRect} rect
 */ (0, _cpblendJsDefault.default).copyAndMultiplyAlphaBy = function(dest, image, alpha, rect) {
    if (alpha == 100) dest.copyBitmapRect(image, rect.left, rect.top, rect);
    else if (alpha == 0) dest.clearRect(rect, 0);
    else {
        var imageData = image.data;
        for(var pixIndex = 0; pixIndex < imageData.length; pixIndex += BYTES_PER_PIXEL){
            imageData[pixIndex] = imageData[pixIndex];
            imageData[pixIndex + 1] = imageData[pixIndex + 1];
            imageData[pixIndex + 2] = imageData[pixIndex + 2];
            imageData[pixIndex + ALPHA_BYTE_OFFSET] = Math.round(imageData[pixIndex + ALPHA_BYTE_OFFSET] * alpha / 100);
        }
    }
};

},{"./CPBlend.js":"k5HfA","../util/CPRect.js":"aDqvw","./CPColorBmp.js":"5rykl","./CPGreyBmp.js":"fGKWG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"92wgz":[function(require,module,exports,__globalThis) {
/*
	ChickenPaint

	ChickenPaint is a translation of ChibiPaint from Java to JavaScript
	by Nicholas Sherlock / Chicken Smoothie.

	ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

	ChickenPaint is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	ChickenPaint is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPBlendTree);
var _cpblendJs = require("./CPBlend.js");
var _cpblendJsDefault = parcelHelpers.interopDefault(_cpblendJs);
var _cpblendAdditionalJs = require("./CPBlendAdditional.js");
var _cplayerJs = require("./CPLayer.js");
var _cplayerJsDefault = parcelHelpers.interopDefault(_cplayerJs);
var _cplayerGroupJs = require("./CPLayerGroup.js");
var _cplayerGroupJsDefault = parcelHelpers.interopDefault(_cplayerGroupJs);
var _cpcolorBmpJs = require("./CPColorBmp.js");
var _cpcolorBmpJsDefault = parcelHelpers.interopDefault(_cpcolorBmpJs);
var _cpimageLayerJs = require("./CPImageLayer.js");
var _cpimageLayerJsDefault = parcelHelpers.interopDefault(_cpimageLayerJs);
var _cprectJs = require("../util/CPRect.js");
var _cprectJsDefault = parcelHelpers.interopDefault(_cprectJs);
/**
 *
 * @param {number} width
 * @param {number} height
 * @param {(CPLayer|CPLayerGroup)} layer
 * @constructor
 */ function CPBlendNode(width, height, layer) {
    if (layer) {
        this.isGroup = layer instanceof (0, _cplayerGroupJsDefault.default);
        this.image = layer.image;
        this.mask = layer.getEffectiveMask();
        this.layer = layer;
        this.blendMode = layer.blendMode;
        this.alpha = layer.alpha;
        this.visible = layer.visible;
    } else {
        this.isGroup = true;
        this.image = null;
        this.mask = null;
        this.layer = null;
        this.blendMode = (0, _cpblendJsDefault.default).LM_PASSTHROUGH;
        this.alpha = 100;
        this.visible = true;
    }
    /**
	 * For group nodes, this is the rectangle of data which is dirty (due to changes in child nodes) and needs to be re-merged
	 *
	 * @type {CPRect}
	 */ this.dirtyRect = new (0, _cprectJsDefault.default)(0, 0, width, height);
    /**
	 *
	 * @type {CPBlendNode[]}
	 */ this.layers = [];
    /**
	 * @type {?CPBlendNode}
	 */ this.parent = null;
    /**
	 * When true, we should clip the layers in this group to the bottom layer of the stack
	 *
	 * @type {boolean}
	 */ this.clip = false;
}
/**
 * Add zero (null), one (CPBlendNode) or more (CPBlendNode[]) children to this node.
 *
 * @param {(?CPBlendNode|CPBlendNode[])} children
 */ CPBlendNode.prototype.addChildren = function(children) {
    if (children != null) {
        if (Array.isArray(children)) {
            children.forEach((child)=>child.parent = this);
            this.layers = this.layers.concat(children);
        } else {
            let child = children;
            child.parent = this;
            this.layers.push(child);
        }
    }
};
function CPBlendTree(drawingRootGroup, width, height, requireSimpleFusion) {
    const DEBUG = false;
    let /**
		 * @type {CPBlendNode}
		 */ drawTree, /**
		 * Unused buffers we could re-use instead of allocating more memory.
		 *
 		 * @type {CPColorBmp[]}
		 */ spareBuffers = [], /**
		 * @type {Map}
		 */ nodeForLayer = new Map();
    function allocateBuffer() {
        if (spareBuffers.length > 0) return spareBuffers.pop();
        return new (0, _cpcolorBmpJsDefault.default)(width, height);
    }
    /**
	 *
	 * @param {CPBlendNode} groupNode
	 * @returns {?CPBlendNode|CPBlendNode[]}
	 */ function optimizeGroupNode(groupNode) {
        if (groupNode.layers.length == 0) // Group was empty, so omit it
        return null;
        if (groupNode.layers.length == 1 && (groupNode.mask == null || groupNode.layers[0].mask == null)) {
            /*
			 * Replace this group with the layer it contains (combine the alpha of the two layers)
			 * At most one of the two layers may have a mask, so that we can use that mask for both of them.
			 */ let flattenedNode = groupNode.layers[0];
            flattenedNode.alpha = Math.round(groupNode.alpha * flattenedNode.alpha / 100);
            if (groupNode.blendMode != (0, _cpblendJsDefault.default).LM_PASSTHROUGH) flattenedNode.blendMode = groupNode.blendMode;
            flattenedNode.mask = groupNode.mask || flattenedNode.mask;
            /* However, make sure that if someone invalidates the group node (i.e. draws on its mask) we invalidate this
			 * new merged node too.
			 */ if (groupNode.layer) nodeForLayer.set(groupNode.layer, flattenedNode);
            return flattenedNode;
        }
        // Replace logically-transparent pass-through groups with their contents
        if (groupNode.blendMode == (0, _cpblendJsDefault.default).LM_PASSTHROUGH && groupNode.alpha == 100 && groupNode.mask == null) return groupNode.layers;
        // Since we didn't fall into any of the optimized cases, our group must need a temporary buffer to merge its children into
        groupNode.image = allocateBuffer();
        return groupNode;
    }
    /**
	 *
	 * @param {CPLayer} layer
	 * @returns {CPBlendNode}
	 */ function createNodeForLayer(layer) {
        let node = new CPBlendNode(width, height, layer);
        nodeForLayer.set(layer, node);
        return node;
    }
    /**
	 * Build a CPBlendNode for this CPLayerGroup and return it, or null if this group doesn't draw anything.
	 *
	 * @param {CPLayerGroup} layerGroup
	 * @returns {?CPBlendNode|CPBlendNode[]}
	 */ function buildTreeInternal(layerGroup) {
        if (layerGroup.getEffectiveAlpha() == 0) return null;
        let treeNode = createNodeForLayer(layerGroup);
        for(let i = 0; i < layerGroup.layers.length; i++){
            let childLayer = layerGroup.layers[i], nextChild = layerGroup.layers[i + 1];
            // Do we need to create a clipping group?
            if (childLayer instanceof (0, _cpimageLayerJsDefault.default) && nextChild && nextChild.clip) {
                let clippingGroupNode = new CPBlendNode(width, height, null), j;
                clippingGroupNode.blendMode = childLayer.blendMode;
                clippingGroupNode.alpha = 100;
                clippingGroupNode.clip = true;
                clippingGroupNode.addChildren(createNodeForLayer(childLayer));
                // All the contiguous layers above us with "clip" set will become the children of the new group
                for(j = i + 1; j < layerGroup.layers.length; j++){
                    if (layerGroup.layers[j].clip) {
                        if (layerGroup.layers[j].getEffectiveAlpha() > 0) clippingGroupNode.addChildren(createNodeForLayer(layerGroup.layers[j]));
                    } else break;
                }
                // If the clipping base is invisible, so will the children be (so drop them here by not adding them anywhere)
                if (childLayer.getEffectiveAlpha() > 0) treeNode.addChildren(optimizeGroupNode(clippingGroupNode));
                // Skip the layers we just added
                i = j - 1;
            } else if (childLayer instanceof (0, _cplayerGroupJsDefault.default)) treeNode.addChildren(buildTreeInternal(childLayer));
            else if (childLayer.getEffectiveAlpha() > 0) treeNode.addChildren(createNodeForLayer(childLayer));
        }
        return optimizeGroupNode(treeNode);
    }
    /**
	 * @param {CPBlendNode} node
	 * @param {CPRect} rect
	 */ function invalidateNodeRect(node, rect) {
        if (node) {
            node.dirtyRect.union(rect);
            invalidateNodeRect(node.parent, rect);
        }
    }
    /**
	 * Mark an area of a layer as updated (so next time fusion is called, it must be redrawn).
	 *
	 * @param {CPLayer} layer
	 * @param {CPRect} rect
	 */ this.invalidateLayerRect = function(layer, rect) {
        let node = nodeForLayer.get(layer);
        invalidateNodeRect(node, rect);
    };
    /**
	 * Build and optimize the blend tree if it was not already built.
	 */ this.buildTree = function() {
        if (!drawTree) {
            drawTree = buildTreeInternal(drawingRootGroup);
            if (!drawTree) {
                /*
				 * No layers in the image to draw, so clear a buffer to transparent and use that.
				 * This doesn't need to be fast because documents with no visible layers are not useful at all.
				 */ drawTree = new CPBlendNode(width, height, {
                    image: allocateBuffer(),
                    blendMode: (0, _cpblendJsDefault.default).LM_NORMAL,
                    alpha: 100,
                    getEffectiveMask: ()=>null,
                    visible: true
                });
                drawTree.image.clearAll(0);
            } else /*
				 * Caller wants fusion to be a single opaque node, so add a group node as a wrapper if needed (to hold
				 * a buffer for the merged children).
				 */ if (Array.isArray(drawTree) || requireSimpleFusion && (drawTree.alpha < 100 || drawTree.mask)) {
                let oldNode = drawTree;
                drawTree = new CPBlendNode(width, height);
                drawTree.blendMode = Array.isArray(oldNode) ? (0, _cpblendJsDefault.default).LM_NORMAL : oldNode.blendMode;
                drawTree.alpha = 100;
                drawTree.image = allocateBuffer();
                drawTree.addChildren(oldNode);
            }
            /* Assume we'll have re-used most of the buffers we were ever going to, so we can trim our memory usage
			 * to fit now.
			 */ spareBuffers = [];
        }
    };
    /**
	 * Give back temporary merge buffers to our buffer pool.
	 *
	 * @param {CPBlendNode} root
	 */ function resetTreeInternal(root) {
        if (root.isGroup) {
            if (root.image) spareBuffers.push(root.image);
            for (let child of root.layers)resetTreeInternal(child);
        }
    }
    /**
	 * Clear the blend tree (so it can be re-built to reflect changes in the layer structure)
	 */ this.resetTree = function() {
        if (drawTree) {
            resetTreeInternal(drawTree);
            drawTree = null;
            nodeForLayer.clear();
        }
    };
    /**
	 * Call when a property of the layer has changed (opacity, blendMode, visibility)
	 *
	 * @param {CPLayer} layer
	 * @param {string} propertyName
	 */ this.layerPropertyChanged = function(layer, propertyName) {
        let layerNode = nodeForLayer.get(layer);
        /*
		 * If only the blendMode changed, we won't have to reconstruct our blend tree, since none of our
		 * tree structure depends on this (as long as it isn't "passthrough").
		 */ if (!layerNode || layerNode.visible != layer.visible || layerNode.alpha != layer.alpha || layerNode.mask == null != (layer.getEffectiveMask() == null) || layerNode.blendMode == (0, _cpblendJsDefault.default).LM_PASSTHROUGH != (layer.blendMode == (0, _cpblendJsDefault.default).LM_PASSTHROUGH) || propertyName === "clip") this.resetTree();
        else {
            layerNode.blendMode = layer.blendMode;
            invalidateNodeRect(layerNode, new (0, _cprectJsDefault.default)(0, 0, width, height));
        }
    };
    /**
	 *
	 * @param {CPColorBmp} dest
	 * @param {CPColorBmp} source
	 * @param {CPRect} rect
	 */ function copyOpaqueImageRect(dest, source, rect) {
        if (rect.getWidth() == dest.width && rect.getHeight() == dest.height) {
            /*
			 * If we're copying the whole image at alpha 100, we're just doing a linear byte copy.
			 * We have a fast version for that!
			 */ if (DEBUG) console.log("CPColorBmp.copyDataFrom(source);");
            dest.copyPixelsFrom(source);
        } else {
            // Otherwise use the CPBlend version which only blends the specified rectangle
            if (DEBUG) console.log(`CPBlend.replaceOntoFusionWithOpaqueLayer(dest, source, 100, ${rect});`);
            (0, _cpblendJsDefault.default).replaceOntoFusionWithOpaqueLayer(dest, source, 100, rect);
        }
    }
    /**
	 *
	 * @param {CPColorBmp} dest
	 * @param {CPColorBmp} source
	 * @param {number} sourceAlpha
	 * @param {CPRect} rect
	 * @param {?CPGreyBmp} mask
	 */ function copyImageRect(dest, source, sourceAlpha, rect, mask) {
        // Use a plain copy if possible
        if (sourceAlpha == 100 && !mask && rect.getWidth() == dest.width && rect.getHeight() == dest.height) {
            if (DEBUG) console.log("CPColorBmp.copyDataFrom(source);");
            dest.copyPixelsFrom(source);
        } else {
            // Otherwise do some blending
            let routineName = "replaceOntoFusionWith";
            if (sourceAlpha == 100) routineName += "OpaqueLayer";
            else routineName += "TransparentLayer";
            if (mask) routineName += "Masked";
            if (DEBUG) console.log(`CPBlend.${routineName}(dest, source, sourceAlpha = ${sourceAlpha}, rect = ${rect}, mask = ${mask});`);
            (0, _cpblendJsDefault.default)[routineName](dest, source, sourceAlpha, rect, mask);
        }
    }
    /**
	 * Blend the given tree node and return the tree node that contains the resulting blend, or null if the tree is empty.
	 * 
	 * @param {?CPBlendNode} treeNode
	 */ function blendTreeInternal(treeNode) {
        if (!treeNode || !treeNode.isGroup) // Tree is empty, or it's just a layer and doesn't need further blending
        return treeNode;
        let blendArea = treeNode.dirtyRect, groupIsEmpty = true, fusionHasTransparency = true;
        if (treeNode.blendMode == (0, _cpblendJsDefault.default).LM_PASSTHROUGH && treeNode.parent) /* With passthrough blending, the contents of the group are also dependent on the fusion it sits on top of,
			 * so invalidating the parent must invalidate the passthrough child.
			 */ blendArea.union(treeNode.parent.dirtyRect);
        if (blendArea.isEmpty()) // Nothing to draw!
        return treeNode;
        if (treeNode.blendMode == (0, _cpblendJsDefault.default).LM_PASSTHROUGH && treeNode.parent) {
            // We need to fuse our children layers onto a copy of our parents fusion, so make that copy now
            groupIsEmpty = false;
            copyOpaqueImageRect(treeNode.image, treeNode.parent.image, blendArea);
        }
        // Avoid using an iterator here because Chrome refuses to optimize when a "finally" clause is present (caused by Babel iterator codegen)
        for(let i = 0; i < treeNode.layers.length; i++){
            let child = treeNode.layers[i], childNode = blendTreeInternal(child);
            if (groupIsEmpty) {
                // If the fusion is currently empty then there's nothing to blend, replace the fusion with the contents of the bottom layer instead
                copyImageRect(treeNode.image, childNode.image, childNode.alpha, blendArea, childNode.mask);
                groupIsEmpty = false;
            } else {
                fusionHasTransparency = fusionHasTransparency && treeNode.image.hasAlphaInRect(blendArea);
                if (DEBUG) console.log(`CPBlend.fuseImageOntoImage(treeNode.image, fusionHasTransparency == ${fusionHasTransparency}, childNode.image, childNode.alpha == ${childNode.alpha}, childNode.blendMode == ${childNode.blendMode}, ${blendArea}, ${childNode.mask});`);
                (0, _cpblendJsDefault.default).fuseImageOntoImage(treeNode.image, fusionHasTransparency, childNode.image, childNode.alpha, childNode.blendMode, blendArea, childNode.mask);
            }
        }
        if (treeNode.clip) {
            // Need to restore the original alpha from the base layer we're clipping onto
            let baseLayer = treeNode.layers[0];
            if (baseLayer.alpha < 100) {
                if (baseLayer.mask) {
                    if (DEBUG) console.log(`CPBlend.replaceAlphaOntoFusionWithTransparentLayerMasked(treeNode.image, baseLayer.image, treeNode.layers[0].alpha == ${treeNode.layers[0].alpha}, ${blendArea});`);
                    (0, _cpblendJsDefault.default).replaceAlphaOntoFusionWithTransparentLayerMasked(treeNode.image, baseLayer.image, baseLayer.alpha, blendArea, baseLayer.mask);
                } else {
                    if (DEBUG) console.log(`CPBlend.replaceAlphaOntoFusionWithTransparentLayer(treeNode.image, baseLayer.image, treeNode.layers[0].alpha == ${treeNode.layers[0].alpha}, ${blendArea});`);
                    (0, _cpblendJsDefault.default).replaceAlphaOntoFusionWithTransparentLayer(treeNode.image, baseLayer.image, baseLayer.alpha, blendArea);
                }
            } else if (baseLayer.mask) {
                if (DEBUG) console.log(`CPBlend.replaceAlphaOntoFusionWithOpaqueLayerMasked(treeNode.image, baseLayer.image, 100, ${blendArea});`);
                (0, _cpblendJsDefault.default).replaceAlphaOntoFusionWithOpaqueLayerMasked(treeNode.image, baseLayer.image, 100, blendArea, baseLayer.mask);
            } else {
                if (DEBUG) console.log(`CPBlend.replaceAlphaOntoFusionWithOpaqueLayer(treeNode.image, baseLayer.image, 100, ${blendArea});`);
                (0, _cpblendJsDefault.default).replaceAlphaOntoFusionWithOpaqueLayer(treeNode.image, baseLayer.image, 100, blendArea);
            }
        }
        treeNode.dirtyRect.makeEmpty();
        return treeNode;
    }
    /**
	 * Blend the layers in the tree and return the resulting image.
	 * 
	 * @returns An object with blendMode, alpha and image (CPColorBmp) properties.
	 */ this.blendTree = function() {
        if (DEBUG) console.log("Fusing layers...");
        return blendTreeInternal(drawTree);
    };
}

},{"./CPBlend.js":"k5HfA","./CPBlendAdditional.js":"dA7oJ","./CPLayer.js":"1fr05","./CPLayerGroup.js":"k5mD3","./CPColorBmp.js":"5rykl","./CPImageLayer.js":"93gOf","../util/CPRect.js":"aDqvw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iy9lO":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint

    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.

    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cprectJs = require("../util/CPRect.js");
var _cprectJsDefault = parcelHelpers.interopDefault(_cprectJs);
var _cpcolorBmpJs = require("./CPColorBmp.js");
var _cpcolorBmpJsDefault = parcelHelpers.interopDefault(_cpcolorBmpJs);
var _cpgreyBmpJs = require("./CPGreyBmp.js");
var _cpgreyBmpJsDefault = parcelHelpers.interopDefault(_cpgreyBmpJs);
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
/**
 * Copy the rectangle from the single-channel `greyscale` to the RGBA `imageData` as greyscale pixels with full alpha.
 * Both images must be the same size.
 *
 * @param {ImageData} imageData
 * @param {CPGreyBmp} greyscale
 * @param {CPRect} rect
 */ function copyGreyscaleRectToImageData(imageData, greyscale, rect) {
    var srcIndex = rect.top * greyscale.width + rect.left, dstIndex = srcIndex * (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL, width = rect.getWidth(), height = rect.getHeight(), srcYSkip = greyscale.width - width, dstYSkip = srcYSkip * (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL;
    for(let y = 0; y < height; y++, srcIndex += srcYSkip, dstIndex += dstYSkip)for(let x = 0; x < width; x++, srcIndex++, dstIndex += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL){
        imageData.data[dstIndex + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET] = greyscale.data[srcIndex];
        imageData.data[dstIndex + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET] = greyscale.data[srcIndex];
        imageData.data[dstIndex + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET] = greyscale.data[srcIndex];
        imageData.data[dstIndex + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET] = 0xFF;
    }
}
class CPMaskView extends (0, _wolfy87EventemitterDefault.default) {
    /**
	 * @param {CPLayer} layer
	 * @param {function} prepareMask
	 */ constructor(layer, prepareMask){
        super();
        this.layer = layer;
        this.buffer = layer.mask.getImageData(0, 0, layer.mask.width, layer.mask.height);
        this.invalidRect = new (0, _cprectJsDefault.default)(0, 0, 0, 0); // Buffer starts off valid
        /**
		 * Routine that must be called before the pixels in the mask will be valid.
		 *
		 * @type {Function}
		 */ this.prepareMask = prepareMask;
    }
    close() {
        this.buffer = null;
        this.layer = null;
        this.emitEvent("changeLayer");
    }
    setLayer(layer) {
        this.layer = layer;
        this.invalidRect = layer.getBounds();
        this.emitEvent("changeLayer");
    }
    isOpen() {
        return this.layer != null;
    }
    /**
	 * Mark a rectangle as changed (the mask has been painted on)
	 *
	 * @param {CPRect} rect
	 */ invalidateRect(rect) {
        this.invalidRect.union(rect);
    }
    /**
	 * Get the pixels of the mask as an ImageData object, or null if this view has already been closed.
	 *
	 * @returns {ImageData}
	 */ getImageData() {
        this.prepareMask();
        if (!this.invalidRect.isEmpty() && this.layer && this.layer.mask) {
            copyGreyscaleRectToImageData(this.buffer, this.layer.mask, this.invalidRect);
            this.invalidRect.makeEmpty();
        }
        return this.buffer;
    }
}
exports.default = CPMaskView;

},{"../util/CPRect.js":"aDqvw","./CPColorBmp.js":"5rykl","./CPGreyBmp.js":"fGKWG","wolfy87-eventemitter":"gPUo0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gPUo0":[function(require,module,exports,__globalThis) {
/*!
 * EventEmitter v5.2.9 - git.io/ee
 * Unlicense - http://unlicense.org/
 * Oliver Caldwell - https://oli.me.uk/
 * @preserve
 */ (function(exports) {
    'use strict';
    /**
     * Class for managing events.
     * Can be extended to provide event functionality in other classes.
     *
     * @class EventEmitter Manages event registering and emitting.
     */ function EventEmitter() {}
    // Shortcuts to improve speed and size
    var proto = EventEmitter.prototype;
    var originalGlobalValue = exports.EventEmitter;
    /**
     * Finds the index of the listener for the event in its storage array.
     *
     * @param {Function[]} listeners Array of listeners to search through.
     * @param {Function} listener Method to look for.
     * @return {Number} Index of the specified listener, -1 if not found
     * @api private
     */ function indexOfListener(listeners, listener) {
        var i = listeners.length;
        while(i--){
            if (listeners[i].listener === listener) return i;
        }
        return -1;
    }
    /**
     * Alias a method while keeping the context correct, to allow for overwriting of target method.
     *
     * @param {String} name The name of the target method.
     * @return {Function} The aliased method
     * @api private
     */ function alias(name) {
        return function aliasClosure() {
            return this[name].apply(this, arguments);
        };
    }
    /**
     * Returns the listener array for the specified event.
     * Will initialise the event object and listener arrays if required.
     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
     * Each property in the object response is an array of listener functions.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Function[]|Object} All listener functions for the event.
     */ proto.getListeners = function getListeners(evt) {
        var events = this._getEvents();
        var response;
        var key;
        // Return a concatenated array of all matching events if
        // the selector is a regular expression.
        if (evt instanceof RegExp) {
            response = {};
            for(key in events)if (events.hasOwnProperty(key) && evt.test(key)) response[key] = events[key];
        } else response = events[evt] || (events[evt] = []);
        return response;
    };
    /**
     * Takes a list of listener objects and flattens it into a list of listener functions.
     *
     * @param {Object[]} listeners Raw listener objects.
     * @return {Function[]} Just the listener functions.
     */ proto.flattenListeners = function flattenListeners(listeners) {
        var flatListeners = [];
        var i;
        for(i = 0; i < listeners.length; i += 1)flatListeners.push(listeners[i].listener);
        return flatListeners;
    };
    /**
     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Object} All listener functions for an event in an object.
     */ proto.getListenersAsObject = function getListenersAsObject(evt) {
        var listeners = this.getListeners(evt);
        var response;
        if (listeners instanceof Array) {
            response = {};
            response[evt] = listeners;
        }
        return response || listeners;
    };
    function isValidListener(listener) {
        if (typeof listener === 'function' || listener instanceof RegExp) return true;
        else if (listener && typeof listener === 'object') return isValidListener(listener.listener);
        else return false;
    }
    /**
     * Adds a listener function to the specified event.
     * The listener will not be added if it is a duplicate.
     * If the listener returns true then it will be removed after it is called.
     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */ proto.addListener = function addListener(evt, listener) {
        if (!isValidListener(listener)) throw new TypeError('listener must be a function');
        var listeners = this.getListenersAsObject(evt);
        var listenerIsWrapped = typeof listener === 'object';
        var key;
        for(key in listeners)if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) listeners[key].push(listenerIsWrapped ? listener : {
            listener: listener,
            once: false
        });
        return this;
    };
    /**
     * Alias of addListener
     */ proto.on = alias('addListener');
    /**
     * Semi-alias of addListener. It will add a listener that will be
     * automatically removed after its first execution.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */ proto.addOnceListener = function addOnceListener(evt, listener) {
        return this.addListener(evt, {
            listener: listener,
            once: true
        });
    };
    /**
     * Alias of addOnceListener.
     */ proto.once = alias('addOnceListener');
    /**
     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
     * You need to tell it what event names should be matched by a regex.
     *
     * @param {String} evt Name of the event to create.
     * @return {Object} Current instance of EventEmitter for chaining.
     */ proto.defineEvent = function defineEvent(evt) {
        this.getListeners(evt);
        return this;
    };
    /**
     * Uses defineEvent to define multiple events.
     *
     * @param {String[]} evts An array of event names to define.
     * @return {Object} Current instance of EventEmitter for chaining.
     */ proto.defineEvents = function defineEvents(evts) {
        for(var i = 0; i < evts.length; i += 1)this.defineEvent(evts[i]);
        return this;
    };
    /**
     * Removes a listener function from the specified event.
     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to remove the listener from.
     * @param {Function} listener Method to remove from the event.
     * @return {Object} Current instance of EventEmitter for chaining.
     */ proto.removeListener = function removeListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var index;
        var key;
        for(key in listeners)if (listeners.hasOwnProperty(key)) {
            index = indexOfListener(listeners[key], listener);
            if (index !== -1) listeners[key].splice(index, 1);
        }
        return this;
    };
    /**
     * Alias of removeListener
     */ proto.off = alias('removeListener');
    /**
     * Adds listeners in bulk using the manipulateListeners method.
     * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
     * You can also pass it a regular expression to add the array of listeners to all events that match it.
     * Yeah, this function does quite a bit. That's probably a bad thing.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add.
     * @return {Object} Current instance of EventEmitter for chaining.
     */ proto.addListeners = function addListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(false, evt, listeners);
    };
    /**
     * Removes listeners in bulk using the manipulateListeners method.
     * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be removed.
     * You can also pass it a regular expression to remove the listeners from all events that match it.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */ proto.removeListeners = function removeListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(true, evt, listeners);
    };
    /**
     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
     * The first argument will determine if the listeners are removed (true) or added (false).
     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be added/removed.
     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
     *
     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */ proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
        var i;
        var value;
        var single = remove ? this.removeListener : this.addListener;
        var multiple = remove ? this.removeListeners : this.addListeners;
        // If evt is an object then pass each of its properties to this method
        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
            for(i in evt)if (evt.hasOwnProperty(i) && (value = evt[i])) {
                // Pass the single listener straight through to the singular method
                if (typeof value === 'function') single.call(this, i, value);
                else // Otherwise pass back to the multiple function
                multiple.call(this, i, value);
            }
        } else {
            // So evt must be a string
            // And listeners must be an array of listeners
            // Loop over it and pass each one to the multiple method
            i = listeners.length;
            while(i--)single.call(this, evt, listeners[i]);
        }
        return this;
    };
    /**
     * Removes all listeners from a specified event.
     * If you do not specify an event then all listeners will be removed.
     * That means every event will be emptied.
     * You can also pass a regex to remove all events that match it.
     *
     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
     * @return {Object} Current instance of EventEmitter for chaining.
     */ proto.removeEvent = function removeEvent(evt) {
        var type = typeof evt;
        var events = this._getEvents();
        var key;
        // Remove different things depending on the state of evt
        if (type === 'string') // Remove all listeners for the specified event
        delete events[evt];
        else if (evt instanceof RegExp) {
            // Remove all events matching the regex.
            for(key in events)if (events.hasOwnProperty(key) && evt.test(key)) delete events[key];
        } else // Remove all listeners in all events
        delete this._events;
        return this;
    };
    /**
     * Alias of removeEvent.
     *
     * Added to mirror the node API.
     */ proto.removeAllListeners = alias('removeEvent');
    /**
     * Emits an event of your choice.
     * When emitted, every listener attached to that event will be executed.
     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
     * So they will not arrive within the array on the other side, they will be separate.
     * You can also pass a regular expression to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {Array} [args] Optional array of arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */ proto.emitEvent = function emitEvent(evt, args) {
        var listenersMap = this.getListenersAsObject(evt);
        var listeners;
        var listener;
        var i;
        var key;
        var response;
        for(key in listenersMap)if (listenersMap.hasOwnProperty(key)) {
            listeners = listenersMap[key].slice(0);
            for(i = 0; i < listeners.length; i++){
                // If the listener returns true then it shall be removed from the event
                // The function is executed either with a basic call or an apply if there is an args array
                listener = listeners[i];
                if (listener.once === true) this.removeListener(evt, listener.listener);
                response = listener.listener.apply(this, args || []);
                if (response === this._getOnceReturnValue()) this.removeListener(evt, listener.listener);
            }
        }
        return this;
    };
    /**
     * Alias of emitEvent
     */ proto.trigger = alias('emitEvent');
    /**
     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {...*} Optional additional arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */ proto.emit = function emit(evt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(evt, args);
    };
    /**
     * Sets the current value to check against when executing listeners. If a
     * listeners return value matches the one set here then it will be removed
     * after execution. This value defaults to true.
     *
     * @param {*} value The new value to check for when executing listeners.
     * @return {Object} Current instance of EventEmitter for chaining.
     */ proto.setOnceReturnValue = function setOnceReturnValue(value) {
        this._onceReturnValue = value;
        return this;
    };
    /**
     * Fetches the current value to check against when executing listeners. If
     * the listeners return value matches this one then it should be removed
     * automatically. It will return true by default.
     *
     * @return {*|Boolean} The current value to check for or the default, true.
     * @api private
     */ proto._getOnceReturnValue = function _getOnceReturnValue() {
        if (this.hasOwnProperty('_onceReturnValue')) return this._onceReturnValue;
        else return true;
    };
    /**
     * Fetches the events object and creates one if required.
     *
     * @return {Object} The events storage object.
     * @api private
     */ proto._getEvents = function _getEvents() {
        return this._events || (this._events = {});
    };
    /**
     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
     *
     * @return {Function} Non conflicting EventEmitter class.
     */ EventEmitter.noConflict = function noConflict() {
        exports.EventEmitter = originalGlobalValue;
        return EventEmitter;
    };
    // Expose the class either via AMD, CommonJS or the global object
    if (typeof define === 'function' && define.amd) define(function() {
        return EventEmitter;
    });
    else if (module.exports) module.exports = EventEmitter;
    else exports.EventEmitter = EventEmitter;
})(typeof window !== 'undefined' ? window : this || {});

},{}],"ebcUl":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPBrushManager);
var _cpbrushInfoJs = require("./CPBrushInfo.js");
var _cpbrushInfoJsDefault = parcelHelpers.interopDefault(_cpbrushInfoJs);
const MAX_SQUEEZE = 10;
/**
 *
 * @param {Uint8Array} brush
 * @param {CPBrushInfo} brushInfo
 */ function buildBrush(brush, brushInfo) {
    let intSize = Math.ceil(brushInfo.curSize), center = intSize / 2.0, sqrRadius = brushInfo.curSize / 2 * (brushInfo.curSize / 2), xFactor = 1.0 + brushInfo.curSqueeze * MAX_SQUEEZE, cosA = Math.cos(brushInfo.curAngle), sinA = Math.sin(brushInfo.curAngle), offset = 0;
    for(let j = 0; j < intSize; j++)for(let i = 0; i < intSize; i++){
        let x = i + 0.5 - center, y = j + 0.5 - center, dx = (x * cosA - y * sinA) * xFactor, dy = y * cosA + x * sinA, sqrDist = dx * dx + dy * dy;
        if (sqrDist <= sqrRadius) brush[offset++] = 0xFF;
        else brush[offset++] = 0;
    }
}
/**
 * @param {Uint8Array} brush
 * @param {CPBrushInfo} brushInfo
 */ function buildBrushAA(brush, brushInfo) {
    let intSize = Math.ceil(brushInfo.curSize), center = intSize / 2.0, sqrRadius = brushInfo.curSize / 2 * (brushInfo.curSize / 2), sqrRadiusInner = (brushInfo.curSize - 2) / 2 * ((brushInfo.curSize - 2) / 2), sqrRadiusOuter = (brushInfo.curSize + 2) / 2 * ((brushInfo.curSize + 2) / 2), xFactor = 1.0 + brushInfo.curSqueeze * MAX_SQUEEZE, cosA = Math.cos(brushInfo.curAngle), sinA = Math.sin(brushInfo.curAngle), offset = 0;
    for(let j = 0; j < intSize; j++)for(let i = 0; i < intSize; i++){
        let x = i + 0.5 - center, y = j + 0.5 - center, dx = (x * cosA - y * sinA) * xFactor, dy = y * cosA + x * sinA, sqrDist = dx * dx + dy * dy;
        if (sqrDist <= sqrRadiusInner) brush[offset++] = 0xFF;
        else if (sqrDist > sqrRadiusOuter) brush[offset++] = 0;
        else {
            let count = 0;
            for(let oy = 0; oy < 4; oy++)for(let ox = 0; ox < 4; ox++){
                x = i + ox * 0.25 - center;
                y = j + oy * 0.25 - center;
                dx = (x * cosA - y * sinA) * xFactor;
                dy = y * cosA + x * sinA;
                sqrDist = dx * dx + dy * dy;
                if (sqrDist <= sqrRadius) count += 1;
            }
            brush[offset++] = Math.min(count * 16, 255);
        }
    }
}
/**
 * @param {Uint8Array} brush
 * @param {CPBrushInfo} brushInfo
 */ function buildBrushSquare(brush, brushInfo) {
    let intSize = Math.ceil(brushInfo.curSize), center = intSize / 2.0, size = brushInfo.curSize * Math.sin(Math.PI / 4), sizeX = size / 2 / (1.0 + brushInfo.curSqueeze * MAX_SQUEEZE), sizeY = size / 2, cosA = Math.cos(brushInfo.curAngle), sinA = Math.sin(brushInfo.curAngle), offset = 0;
    for(let j = 0; j < intSize; j++)for(let i = 0; i < intSize; i++){
        let x = i + 0.5 - center, y = j + 0.5 - center, dx = Math.abs(x * cosA - y * sinA), dy = Math.abs(y * cosA + x * sinA);
        if (dx <= sizeX && dy <= sizeY) brush[offset++] = 0xFF;
        else brush[offset++] = 0;
    }
}
/**
 * @param {Uint8Array} brush
 * @param {CPBrushInfo} brushInfo
 */ function buildBrushSquareAA(brush, brushInfo) {
    let intSize = Math.ceil(brushInfo.curSize), center = intSize / 2.0, size = brushInfo.curSize * Math.sin(Math.PI / 4), sizeX = size / 2 / (1.0 + brushInfo.curSqueeze * MAX_SQUEEZE), sizeY = size / 2, sizeXInner = sizeX - 1, sizeYInner = sizeY - 1, sizeXOuter = sizeX + 1, sizeYOuter = sizeY + 1, cosA = Math.cos(brushInfo.curAngle), sinA = Math.sin(brushInfo.curAngle), offset = 0;
    for(let j = 0; j < intSize; j++)for(let i = 0; i < intSize; i++){
        let x = i + 0.5 - center, y = j + 0.5 - center, dx = Math.abs(x * cosA - y * sinA), dy = Math.abs(y * cosA + x * sinA);
        if (dx <= sizeXInner && dy <= sizeYInner) brush[offset++] = 0xFF;
        else if (dx > sizeXOuter || dy > sizeYOuter) brush[offset++] = 0;
        else {
            let count = 0;
            for(let oy = 0; oy < 4; oy++)for(let ox = 0; ox < 4; ox++){
                x = i + ox * 0.25 - center;
                y = j + oy * 0.25 - center;
                dx = Math.abs(x * cosA - y * sinA);
                dy = Math.abs(y * cosA + x * sinA);
                if (dx <= sizeX && dy <= sizeY) count++;
            }
            brush[offset++] = Math.min(count * 16, 255);
        }
    }
}
/**
 *
 * @param {Uint8Array} brush
 * @param {CPBrushInfo} brushInfo
 */ function buildBrushSoft(brush, brushInfo) {
    let intSize = Math.ceil(brushInfo.curSize), center = intSize / 2.0, sqrRadius = brushInfo.curSize / 2 * (brushInfo.curSize / 2), xFactor = 1.0 + brushInfo.curSqueeze * MAX_SQUEEZE, cosA = Math.cos(brushInfo.curAngle), sinA = Math.sin(brushInfo.curAngle), offset = 0;
    for(let j = 0; j < intSize; j++)for(let i = 0; i < intSize; i++){
        let x = i + 0.5 - center, y = j + 0.5 - center, dx = (x * cosA - y * sinA) * xFactor, dy = y * cosA + x * sinA, sqrDist = dx * dx + dy * dy;
        if (sqrDist <= sqrRadius) brush[offset++] = ~~(255 * (1 - sqrDist / sqrRadius));
        else brush[offset++] = 0;
    }
}
function CPBrushManager() {
    const BRUSH_MAX_DIM = 401, BRUSH_AA_MAX_DIM = 402;
    let brush = new Uint8Array(BRUSH_MAX_DIM * BRUSH_MAX_DIM), brushAA = new Uint8Array(BRUSH_AA_MAX_DIM * BRUSH_AA_MAX_DIM), brushAARows = [
        new Float32Array(BRUSH_AA_MAX_DIM),
        new Float32Array(BRUSH_AA_MAX_DIM)
    ], cacheBrush = null, cacheSize, cacheSqueeze, cacheAngle, cacheTip, that = this;
    /**
     * Shift a brush by a positive sub-pixel amount (dx, dy) [0..1), and return the new brush.
     *
     * The resulting brush array is 1 pixel larger than the original one in both dimensions.
     *
     * @param {CPBrushInfo} brushInfo
     * @param {number} dx
     * @param {number} dy
     *
     * @returns {Uint8Array}
     */ function createSubpixelShiftedBrush(brushInfo, dx, dy) {
        let nonAABrush = getBrush(brushInfo), intSize = Math.ceil(brushInfo.curSize), intSizeAA = Math.ceil(brushInfo.curSize) + 1;
        let invdx_invdy = (1 - dx) * (1 - dy), dx_invdy = dx * (1 - dy), dx_dy = dx * dy, invdx_dy = (1 - dx) * dy, srcIndex = 0, dstIndex = 0, curRow = brushAARows[0], nextRow = brushAARows[1], swap;
        curRow.fill(0); // Since it will be dirty from a previous call
        for(let y = 0; y < intSize; y++){
            let x;
            nextRow[0] = 0; // We overwrite all the subsequent values in the loop, but we do need to clear this one for the first iteration's benefit
            // For all the source pixels in the row:
            for(x = 0; x < intSize; x++, srcIndex++, dstIndex++){
                let brushAlpha = nonAABrush[srcIndex];
                /*
                 * Use a weighted sum to shift the source pixels's position by a sub-pixel amount dx, dy and accumulate
                 * it into the final brushAA array.
                 */ // We have the contribution from our previous 3 neighbours now so we can complete this output pixel
                brushAA[dstIndex] = curRow[x] + brushAlpha * invdx_invdy + 0.5 | 0;
                curRow[x + 1] += brushAlpha * dx_invdy;
                nextRow[x] += brushAlpha * invdx_dy;
                nextRow[x + 1] = brushAlpha * dx_dy; // We're the first iteration that writes to this pixel so we needn't +=
            }
            // The final output pixel of the row doesn't have a source pixel of its own (it just gets the contribution from the previous ones)
            brushAA[dstIndex++] = curRow[x] + 0.5 | 0;
            swap = curRow;
            curRow = nextRow;
            nextRow = swap;
        }
        // Output final residual row
        for(let x = 0; x < intSizeAA; x++, dstIndex++)brushAA[dstIndex] = curRow[x] + 0.5 | 0;
        return brushAA;
    }
    /**
     * Build and return a brush that conforms to the given brush settings.
     *
     * @param {CPBrushInfo} brushInfo
     *
     * @returns {Uint8Array}
     */ function getBrush(brushInfo) {
        if (cacheBrush != null && brushInfo.curSize == cacheSize && brushInfo.curSqueeze == cacheSqueeze && brushInfo.curAngle == cacheAngle && brushInfo.tip == cacheTip) return cacheBrush;
        switch(brushInfo.tip){
            case (0, _cpbrushInfoJsDefault.default).TIP_ROUND_AIRBRUSH:
                buildBrushSoft(brush, brushInfo);
                break;
            case (0, _cpbrushInfoJsDefault.default).TIP_ROUND_AA:
                buildBrushAA(brush, brushInfo);
                break;
            case (0, _cpbrushInfoJsDefault.default).TIP_ROUND_PIXEL:
                buildBrush(brush, brushInfo);
                break;
            case (0, _cpbrushInfoJsDefault.default).TIP_SQUARE_AA:
                buildBrushSquareAA(brush, brushInfo);
                break;
            case (0, _cpbrushInfoJsDefault.default).TIP_SQUARE_PIXEL:
                buildBrushSquare(brush, brushInfo);
                break;
        }
        cacheBrush = brush;
        cacheSize = brushInfo.curSize;
        cacheTip = brushInfo.tip;
        cacheSqueeze = brushInfo.curSqueeze;
        cacheAngle = brushInfo.curAngle;
        return brush;
    }
    /**
     *
     * @param {CPBrushDab} dab
     * @param {number} textureAmount
     */ function applyTexture(dab, textureAmount) {
        let amount = Math.floor(textureAmount * 255), texture = that.texture, textureX = dab.x % texture.width, textureY = dab.y % texture.height, brushPos = 0, texturePos, textureEOL;
        if (textureX < 0) textureX += texture.width;
        if (textureY < 0) textureY += texture.height;
        for(let y = 0; y < dab.height; y++){
            texturePos = textureY * texture.width + textureX;
            textureEOL = textureY * texture.width + texture.width;
            for(let x = 0; x < dab.width; x++){
                let brushValue = dab.brush[brushPos], textureValue = texture.data[texturePos];
                dab.brush[brushPos] = ~~(brushValue * (textureValue * amount / 255 ^ 0xff) / 255);
                brushPos++;
                texturePos++;
                if (texturePos == textureEOL) // Wrap to left side of texture
                texturePos -= texture.width;
            }
            textureY++;
            if (textureY == texture.height) textureY = 0;
        }
    }
    /**
     * Create a paint dab using the given brush at the given image co-ordinates.
     *
     * @param {number} x - Image coordinate of center of brush dab
     * @param {number} y - Image coordinate of center of brush dab
     * @param {CPBrushInfo} brushInfo - Brush appearance parameters
     *
     * @returns {CPBrushDab}
     */ this.getDab = function(x, y, brushInfo) {
        let dab = {
            alpha: brushInfo.curAlpha,
            width: Math.ceil(brushInfo.curSize),
            height: Math.ceil(brushInfo.curSize)
        };
        // FIXME: I don't like this special case for ROUND_PIXEL
        // it would be better to have brush presets for working with pixels
        let useSubpixelShift = brushInfo.isAA && brushInfo.tip != (0, _cpbrushInfoJsDefault.default).TIP_ROUND_PIXEL;
        if (useSubpixelShift) {
            dab.width++;
            dab.height++;
        }
        let // The top left corner of the brush dab
        dabX = x - dab.width / 2.0 + 0.5, dabY = y - dab.height / 2.0 + 0.5, // The pixel the top left corner lies in
        dabXInt = Math.floor(dabX), dabYInt = Math.floor(dabY);
        if (useSubpixelShift) {
            let subpixelX = dabX - dabXInt, subpixelY = dabY - dabYInt;
            dab.brush = createSubpixelShiftedBrush(brushInfo, subpixelX, subpixelY);
        } else dab.brush = getBrush(brushInfo);
        dab.x = dabXInt;
        dab.y = dabYInt;
        if (brushInfo.texture > 0.0 && this.texture != null) {
            // we need a brush bitmap that can be modified everytime
            // the one in "brush" can be kept in cache so if we are using it, make a copy
            if (dab.brush == brush) {
                brushAA.set(brush);
                dab.brush = brushAA;
            }
            applyTexture(dab, brushInfo.texture);
        }
        return dab;
    };
    this.setTexture = function(texture) {
        this.texture = texture;
    };
}

},{"./CPBrushInfo.js":"b7K5Z","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iYRR9":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class CPUndo {
    /**
     * Attempt to merge the given undo into this one, and return true if successful.
     *
     * @param undo
     * @returns {boolean}
     */ merge(undo) {
        return false;
    }
    /**
     * Return true if this undo didn't modify the document.
     *
     * @returns {boolean}
     */ noChange() {
        return false;
    }
    /**
     * Return the number of bytes of memory used by this undo, or 0 if it cannot be estimated.
     *
     * @param undone
     * @param param
     * @returns {number}
     */ getMemoryUsed(undone, param) {
        return 0;
    }
    /**
     * Call when this undo is no longer on the top of the stack, so it can optimize its memory usage.
     */ compact() {}
}
exports.default = CPUndo;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8PjxN":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint

    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.

    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ /**
 *
 * @param {(CPColorBmp|CPGreyBmp)} bmp
 * @param int x - Position of the clipboard bmp within the document
 * @param int y
 * @constructor
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPClip);
function CPClip(bmp, x, y) {
    this.bmp = bmp;
    this.x = x;
    this.y = y;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ioCeM":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ /**
 *
 * @param {number} rgb
 * @param {Object} hsv
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPColor);
function convertRgbToHsv(rgb, hsv) {
    var r = rgb >> 16 & 0xff, g = rgb >> 8 & 0xff, b = rgb & 0xff;
    // Value
    hsv.value = Math.max(r, Math.max(g, b));
    // Saturation
    var mini = Math.min(r, Math.min(g, b));
    if (hsv.value == 0) hsv.saturation = 0;
    else hsv.saturation = ~~((hsv.value - mini) / hsv.value * 255);
    // Hue
    if (hsv.saturation == 0) hsv.hue = 0;
    else {
        var cr = (hsv.value - r) / (hsv.value - mini), cg = (hsv.value - g) / (hsv.value - mini), cb = (hsv.value - b) / (hsv.value - mini);
        var _hue = 0;
        if (hsv.value == r) _hue = cb - cg;
        if (hsv.value == g) _hue = 2 + cr - cb;
        if (hsv.value == b) _hue = 4 + cg - cr;
        _hue *= 60;
        if (_hue < 0) _hue += 360;
        hsv.hue = ~~_hue;
    }
}
/**
 *
 * @param {Object} hsv
 * @returns {int}
 */ function convertHsvToRgb(hsv) {
    // no saturation means it's just a shade of grey
    if (hsv.saturation == 0) return hsv.value << 16 | hsv.value << 8 | hsv.value;
    else {
        var f = hsv.hue / 60;
        f = f - Math.floor(f);
        var s = hsv.saturation / 255, m = ~~(hsv.value * (1 - s)), n = ~~(hsv.value * (1 - s * f)), k = ~~(hsv.value * (1 - s * (1 - f)));
        switch(~~(hsv.hue / 60)){
            case 0:
                return hsv.value << 16 | k << 8 | m;
            case 1:
                return n << 16 | hsv.value << 8 | m;
            case 2:
                return m << 16 | hsv.value << 8 | k;
            case 3:
                return m << 16 | n << 8 | hsv.value;
            case 4:
                return k << 16 | m << 8 | hsv.value;
            case 5:
                return hsv.value << 16 | m << 8 | n;
            default:
                return 0; // invalid hue
        }
    }
}
function CPColor(rgb) {
    /**
     * Color in RGB byte order (no alpha component)
     *
     * @type {int}
     */ this.rgb = 0;
    /**
     * Hue 0-359 degrees
     *
     * @type {int}
     */ this.hue = 0;
    /**
     * Color saturation 0 - 255
     * @type {int}
     */ this.saturation = 0;
    /**
     * Brightness 0 - 255
     *
     * @type {int}
     */ this.value = 0;
    this.setRgb(rgb || 0);
}
CPColor.prototype.getRgb = function() {
    return this.rgb;
};
CPColor.prototype.getSaturation = function() {
    return this.saturation;
};
CPColor.prototype.getHue = function() {
    return this.hue;
};
CPColor.prototype.getValue = function() {
    return this.value;
};
CPColor.prototype.setRgbComponents = function(r, g, b) {
    this.setRgb(r << 16 | g << 8 | b);
};
CPColor.prototype.setRgb = function(rgb) {
    this.rgb = rgb;
    convertRgbToHsv(rgb, this);
};
CPColor.prototype.setHsv = function(hue, saturation, value) {
    this.hue = hue;
    this.saturation = saturation;
    this.value = value;
    this.rgb = convertHsvToRgb(this);
};
CPColor.prototype.setHue = function(hue) {
    this.hue = hue;
    this.rgb = convertHsvToRgb(this);
};
CPColor.prototype.setSaturation = function(saturation) {
    this.saturation = saturation;
    this.rgb = convertHsvToRgb(this);
};
CPColor.prototype.setValue = function(value) {
    this.value = value;
    this.rgb = convertHsvToRgb(this);
};
CPColor.prototype.setGreyscale = function(value) {
    this.rgb = CPColor.greyToRGB(value);
    this.hue = 0;
    this.saturation = 0;
    this.value = value;
};
CPColor.prototype.clone = function() {
    var result = new CPColor(0);
    result.copyFrom(this);
    return result;
};
/**
 *
 * @param {CPColor} that
 */ CPColor.prototype.copyFrom = function(that) {
    this.rgb = that.rgb;
    this.hue = that.hue;
    this.saturation = that.saturation;
    this.value = that.value;
};
/**
 *
 * @param {CPColor} color
 * @returns {boolean}
 */ CPColor.prototype.isEqual = function(color) {
    return this.rgb == color.rgb && this.hue == color.hue && this.saturation == color.saturation && this.value == color.value;
};
CPColor.greyToRGB = function(grey) {
    return grey | grey << 8 | grey << 16;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hX4pE":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPRandom);
function CPRandom() {
    var nextNextGaussian, haveNextNextGaussian = false;
    /**
     * Definition from Java, mean of 0.0 and standard deviation 1.0.
     */ this.nextGaussian = function() {
        if (haveNextNextGaussian) {
            haveNextNextGaussian = false;
            return nextNextGaussian;
        } else {
            var v1, v2, s;
            do {
                v1 = 2 * Math.random() - 1; // between -1.0 and 1.0
                v2 = 2 * Math.random() - 1; // between -1.0 and 1.0
                s = v1 * v1 + v2 * v2;
            }while (s >= 1 || s == 0);
            var multiplier = Math.sqrt(-2 * Math.log(s) / s);
            nextNextGaussian = v2 * multiplier;
            haveNextNextGaussian = true;
            return v1 * multiplier;
        }
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hM3oc":[function(require,module,exports,__globalThis) {
// Modifications by Nicholas Sherlock. Original docs below:
// Last updated November 2011
// By Simon Sarris
// www.simonsarris.com
// sarris@acm.org
//
// Free to use and distribute at will
// So long as you are nice to people, etc
// Simple class for keeping track of the current transformation matrix
// For instance:
//    var t = new Transform();
//    t.rotate(5);
//    var m = t.m;
//    ctx.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);
// Is equivalent to:
//    ctx.rotate(5);
// But now you can retrieve it :)
// Remember that this does not account for any CSS transforms applied to the canvas
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPTransform);
function CPTransform() {
    this.setToIdentity();
}
CPTransform.prototype.setToIdentity = function() {
    /* Matrix components are stored in this order in 'm':
     * [0 2 4]
     * [1 3 5]
     * [x x x]
     *
     * Last row is always 0, 0, 1 so we don't store it.
     */ this.m = [
        1,
        0,
        0,
        1,
        0,
        0
    ];
};
/**
 * Multiply this matrix with the given transformation one like so:
 *
 * [this] = [this] * [matrix]
 *
 * @param {CPTransform} matrix
 */ CPTransform.prototype.multiply = function(matrix) {
    var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1], m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1], m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3], m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3], dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4], dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
    this.m[4] = dx;
    this.m[5] = dy;
};
/**
 * Multiply this matrix with the given transformation one like so:
 *
 * [this] = [matrix] * [this]
 *
 * @param {CPTransform} matrix
 */ CPTransform.prototype.preMultiply = function(matrix) {
    var m11 = matrix.m[0] * this.m[0] + matrix.m[2] * this.m[1], m12 = matrix.m[1] * this.m[0] + matrix.m[3] * this.m[1], m21 = matrix.m[0] * this.m[2] + matrix.m[2] * this.m[3], m22 = matrix.m[1] * this.m[2] + matrix.m[3] * this.m[3], dx = matrix.m[0] * this.m[4] + matrix.m[2] * this.m[5] + matrix.m[4], dy = matrix.m[1] * this.m[4] + matrix.m[3] * this.m[5] + matrix.m[5];
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
    this.m[4] = dx;
    this.m[5] = dy;
};
CPTransform.prototype.invert = function() {
    var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]), m0 = this.m[3] * d, m1 = -this.m[1] * d, m2 = -this.m[2] * d, m3 = this.m[0] * d, m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]), m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
    this.m[0] = m0;
    this.m[1] = m1;
    this.m[2] = m2;
    this.m[3] = m3;
    this.m[4] = m4;
    this.m[5] = m5;
};
CPTransform.prototype.getInverted = function() {
    var result = new CPTransform();
    result.m[0] = this.m[0];
    result.m[1] = this.m[1];
    result.m[2] = this.m[2];
    result.m[3] = this.m[3];
    result.m[4] = this.m[4];
    result.m[5] = this.m[5];
    result.invert();
    return result;
};
/**
 * Multiply this transform by a rotation matrix for the given angle:
 *
 * [ cos(a) -sin(a) 0]
 * [ sin(a)  cos(a) 0]
 * [   0       0    1]
 */ CPTransform.prototype.rotate = function(rad) {
    var c = Math.cos(rad), s = Math.sin(rad), m11 = this.m[0] * c + this.m[2] * s, m12 = this.m[1] * c + this.m[3] * s, m21 = this.m[0] * -s + this.m[2] * c, m22 = this.m[1] * -s + this.m[3] * c;
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
};
CPTransform.prototype.rotateAroundPoint = function(rad, x, y) {
    this.translate(x, y);
    this.rotate(rad);
    this.translate(-x, -y);
};
/**
 * Multiply this transform by a translation matrix:
 *
 * [1  0  x]
 * [0  1  y]
 * [0  0  1]
 *
 * @param x
 * @param y
 */ CPTransform.prototype.translate = function(x, y) {
    this.m[4] += this.m[0] * x + this.m[2] * y;
    this.m[5] += this.m[1] * x + this.m[3] * y;
};
/**
 * Multiply this transform by a scale matrix:
 *
 * [sx 0  0]
 * [0  sy 0]
 * [0  0  1]
 *
 * @param sx
 * @param sy
 */ CPTransform.prototype.scale = function(sx, sy) {
    this.m[0] *= sx;
    this.m[1] *= sx;
    this.m[2] *= sy;
    this.m[3] *= sy;
};
CPTransform.prototype.scaleAroundPoint = function(sx, sy, px, py) {
    this.translate(px, py);
    this.scale(sx, sy);
    this.translate(-px, -py);
};
/**
 * Multiply this transform by a shear matrix:
 *
 * [1  sx 0]
 * [sy 1  0]
 * [0  0  1]
 *
 * @param {number} x
 * @param {number} y
 */ CPTransform.prototype.shear = function(x, y) {
    var m11 = this.m[0] + this.m[2] * y, m12 = this.m[1] + this.m[3] * y, m21 = this.m[2] + this.m[0] * x, m22 = this.m[3] + this.m[1] * x;
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
};
CPTransform.prototype.getTransformedPoint = function(p) {
    return {
        x: p.x * this.m[0] + p.y * this.m[2] + this.m[4],
        y: p.x * this.m[1] + p.y * this.m[3] + this.m[5]
    };
};
CPTransform.prototype.transformPoints = function(points) {
    for(var i = 0; i < points.length; i++)points[i] = this.getTransformedPoint(points[i]);
};
CPTransform.prototype.getTranslateX = function() {
    return this.m[4];
};
CPTransform.prototype.getTranslateY = function() {
    return this.m[5];
};
CPTransform.prototype.clone = function() {
    var result = new CPTransform();
    result.m[0] = this.m[0];
    result.m[1] = this.m[1];
    result.m[2] = this.m[2];
    result.m[3] = this.m[3];
    result.m[4] = this.m[4];
    result.m[5] = this.m[5];
    return result;
};
CPTransform.prototype.getDeterminant = function() {
    return this.m[0] * this.m[3] - this.m[1] * this.m[2];
};
/**
 * Break down the matrix into a translation, scale, rotation, then shear operation.
 *
 * x or y scale must not be zero.
 *
 * http://www.maths-informatique-jeux.com/blog/frederic/?post/2013/12/01/Decomposition-of-2D-transform-matrices
 */ CPTransform.prototype.decompose = function() {
    var determinant = this.getDeterminant(), r = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);
    return {
        translate: {
            x: this.m[4],
            y: this.m[5]
        },
        rotate: Math.sign(this.m[1]) * Math.acos(this.m[0] / r),
        scale: {
            x: r,
            y: determinant / r
        },
        shear: {
            x: Math.atan((this.m[0] * this.m[2] + this.m[1] * this.m[3]) / (r * r)),
            y: 0
        }
    };
};
CPTransform.prototype.toString = function() {
    const PLACES = 2;
    return "[" + this.m[0].toFixed(PLACES) + " " + this.m[2].toFixed(PLACES) + " " + this.m[4].toFixed(PLACES) + "]\n" + "[" + this.m[1].toFixed(PLACES) + " " + this.m[3].toFixed(PLACES) + " " + this.m[5].toFixed(PLACES) + "]\n" + "[0.00 0.00 1.00]";
};
Math.sign = Math.sign || function(x) {
    x = +x; // convert to a number
    if (x === 0 || isNaN(x)) return x;
    return x > 0 ? 1 : -1;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"89GR9":[function(require,module,exports,__globalThis) {
/*
	ChickenPaint

	ChickenPaint is a translation of ChibiPaint from Java to JavaScript
	by Nicholas Sherlock / Chicken Smoothie.

	ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

	ChickenPaint is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	ChickenPaint is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isCanvasInterpolationSupported", ()=>isCanvasInterpolationSupported);
parcelHelpers.export(exports, "setCanvasInterpolation", ()=>setCanvasInterpolation);
var _canvasJs = require("./Canvas.js");
function getCanvasInterpolationPropName(canvasContext) {
    var browserProperties = [
        "imageSmoothingEnabled",
        "mozImageSmoothingEnabled",
        "webkitImageSmoothingEnabled",
        "msImageSmoothingEnabled"
    ];
    for(var i = 0; i < browserProperties.length; i++){
        if (browserProperties[i] in canvasContext) return browserProperties[i];
    }
    return null;
}
function isCanvasInterpolationSupported() {
    var canvas = (0, _canvasJs.createCanvas)(0, 0), canvasContext = canvas.getContext("2d");
    return !!getCanvasInterpolationPropName(canvasContext);
}
function setCanvasInterpolation(canvasContext, enabled) {
    var propName = getCanvasInterpolationPropName(canvasContext);
    if (propName) canvasContext[propName] = enabled;
}

},{"./Canvas.js":"bniay","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ak7pj":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint

    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.

    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CPBrushTool", ()=>CPBrushTool);
parcelHelpers.export(exports, "CPBrushToolEraser", ()=>CPBrushToolEraser);
parcelHelpers.export(exports, "CPBrushToolDodge", ()=>CPBrushToolDodge);
parcelHelpers.export(exports, "CPBrushToolBurn", ()=>CPBrushToolBurn);
/**
 * Blends a pixel with its nearest 4 neighbors using a weighted sum. The opacity accumulated in the stroke buffer decides
 * how much weight the central pixel should have in the sum (higher opacities cause the central pixel to have lower weight,
 * increasing the contribution of those on the edges)
 */ parcelHelpers.export(exports, "CPBrushToolBlur", ()=>CPBrushToolBlur);
parcelHelpers.export(exports, "CPBrushToolWatercolor", ()=>CPBrushToolWatercolor);
parcelHelpers.export(exports, "CPBrushToolOil", ()=>CPBrushToolOil);
parcelHelpers.export(exports, "CPBrushToolSmudge", ()=>CPBrushToolSmudge);
var _cpcolorBmpJs = require("./CPColorBmp.js");
var _cpcolorBmpJsDefault = parcelHelpers.interopDefault(_cpcolorBmpJs);
var _cpgreyBmpJs = require("./CPGreyBmp.js");
var _cpgreyBmpJsDefault = parcelHelpers.interopDefault(_cpgreyBmpJs);
var _cpbrushInfoJs = require("./CPBrushInfo.js");
var _cpbrushInfoJsDefault = parcelHelpers.interopDefault(_cpbrushInfoJs);
var _cpcolorFloatJs = require("../util/CPColorFloat.js");
var _cpcolorFloatJsDefault = parcelHelpers.interopDefault(_cpcolorFloatJs);
/**
 * @param {number[]} array
 * @returns {number}
 */ function average(array) {
    let accumulator = 0;
    for(let i = 0; i < array.length; i++)accumulator += array[i];
    return accumulator / array.length;
}
/**
 * @param {CPColorFloat[]} array
 * @returns {CPColorFloat}
 */ function averageColorFloat(array) {
    let average = new (0, _cpcolorFloatJsDefault.default)(0, 0, 0);
    for(let i = 0; i < array.length; i++){
        let sample = array[i];
        average.r += sample.r;
        average.g += sample.g;
        average.b += sample.b;
    }
    average.r /= array.length;
    average.g /= array.length;
    average.b /= array.length;
    return average;
}
function lerp(from, to, prop) {
    return from * (1 - prop) + to * prop;
}
class CPBrushTool {
    /**
	 * @param {CPGreyBmp} strokeBuffer - A 32-bit image we can use for buffering paint operations to be merged later.
	 * @param {CPRect} strokedRegion - The area of the strokeBuffer we've painted on.
	 */ constructor(strokeBuffer, strokedRegion){
        this._strokeBuffer = strokeBuffer;
        this._strokedRegion = strokedRegion;
        /**
		 * Set to true if the brush wants to be able to sample its output
		 * from the layer as input for its next drawing operation (i.e. please merge the stroke buffer through to the
		 * layer before the next call).
		 *
		 * @type {boolean}
		 */ this.wantsOutputAsInput = true;
    }
    /**
	 * @param {CPColorBmp|CPGreyBmp} destImage - Image to paint to (for those brushes not using the strokeBuffer)
	 * @param {CPRect} imageRect - The area on the canvas that will be painted to
	 * @param {CPBrushInfo} brushConfig - The current brush tip configuration
	 * @param {CPRect} brushRect - The rectangle from the dab which will be painted to the canvas
	 * @param {CPBrushDab} dab
	 * @param {CPColorBmp|CPGreyBmp} sampleImage - Image to sample from (either the current layer/mask or the fusion depending on user's
	 * choice of "sample all layers"
	 * @param {number} color - RGB current brush color
	 */ paintDab(destImage, imageRect, sampleImage, brushConfig, brushRect, dab, color) {
        let alpha = Math.max(1, Math.ceil(dab.alpha * brushConfig.alphaScale));
        switch(brushConfig.paintMode){
            case (0, _cpbrushInfoJsDefault.default).PAINT_MODE_FLOW:
                this._paintFlow(brushRect, imageRect, dab.brush, dab.width, alpha);
                break;
            case (0, _cpbrushInfoJsDefault.default).PAINT_MODE_OPACITY:
                this._paintOpacity(brushRect, imageRect, dab.brush, dab.width, alpha);
                break;
        }
    }
    /**
	 * Blends the brush data from the current stroke (strokeBuffer, strokedRegion) onto the original (pre-stroke)
	 * image data (from undoData) and stores the result in destImage.
	 *
	 * @param {CPColorBmp} destImage - The layer to draw onto
	 * @param {CPColorBmp} undoImage - The original pixels for the layer before the stroke began
	 * @param {number} color - RGB color of the current brush
	 */ mergeOntoImage(destImage, undoImage, color) {
        let strokeData = this._strokeBuffer.data, strokedRegion = this._strokedRegion, undoData = undoImage.data, destData = destImage.data, red = color >> 16 & 0xFF, green = color >> 8 & 0xFF, blue = color & 0xFF, width = strokedRegion.getWidth() | 0, height = strokedRegion.getHeight() | 0, srcOffset = this._strokeBuffer.offsetOfPixel(strokedRegion.left, strokedRegion.top), dstOffset = destImage.offsetOfPixel(strokedRegion.left, strokedRegion.top), srcYStride = this._strokeBuffer.width - width | 0, dstYStride = (destImage.width - width) * (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL | 0;
        for(let y = 0; y < height; y++, srcOffset += srcYStride, dstOffset += dstYStride)for(let x = 0; x < width; x++, srcOffset++, dstOffset += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL){
            let strokeAlpha = strokeData[srcOffset] / 255 + 0.5 | 0; // Round nearest so it's easier to achieve 255 opacity
            if (strokeAlpha > 0) {
                let destAlpha = undoData[dstOffset + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET], newLayerAlpha = strokeAlpha + destAlpha * (255 - strokeAlpha) / 255 | 0, realAlpha = 255 * strokeAlpha / newLayerAlpha | 0, invAlpha = 255 - realAlpha;
                destData[dstOffset] = (red * realAlpha + undoData[dstOffset] * invAlpha) / 255 & 0xff;
                destData[dstOffset + 1] = (green * realAlpha + undoData[dstOffset + 1] * invAlpha) / 255 & 0xff;
                destData[dstOffset + 2] = (blue * realAlpha + undoData[dstOffset + 2] * invAlpha) / 255 & 0xff;
                destData[dstOffset + 3] = newLayerAlpha;
            }
        }
    }
    /**
	 * Uses the strokeBuffer as an alpha mask to paint the given color onto the original (pre-stroke) mask data (undoMask)
	 * and stores the result in destMask.
	 *
	 * @param {CPGreyBmp} destMask - The destination to write to
	 * @param {CPGreyBmp} undoMask - The original contents of the mask
	 * @param {number} color - Intensity to paint (0-255)
	 */ mergeOntoMask(destMask, undoMask, color) {
        let strokeData = this._strokeBuffer.data, strokedRegion = this._strokedRegion, undoMaskData = undoMask.data, destMaskData = destMask.data, width = strokedRegion.getWidth() | 0, height = strokedRegion.getHeight() | 0, dstOffset = destMask.offsetOfPixel(strokedRegion.left, strokedRegion.top), srcOffset = this._strokeBuffer.offsetOfPixel(strokedRegion.left, strokedRegion.top), srcYStride = this._strokeBuffer.width - width | 0, dstYStride = destMask.width - width | 0;
        for(let y = 0; y < height; y++, srcOffset += srcYStride, dstOffset += dstYStride)for(let x = 0; x < width; x++, srcOffset++, dstOffset++){
            let strokeAlpha = strokeData[srcOffset] / 255 | 0;
            if (strokeAlpha > 0) {
                let invAlpha = 255 - strokeAlpha;
                destMaskData[dstOffset] = (color * strokeAlpha + undoMaskData[dstOffset] * invAlpha) / 255;
            }
        }
    }
    /**
	 * Paint the brush into the strokeBuffer at the given position.
	 *
	 * If the brush covers the same area multiple times, ink builds up until the area becomes opaque.
	 *
	 * @param {CPRect} brushRect - Rectangle from brushShape array to paint
	 * @param {CPRect} imageRect - Rectangle of the destination image that corresponds to brushRect
	 * @param {Uint8Array} brushShape - An opacity mask for the brush tip shape
	 * @param {number} brushWidth - Width of the brush buffer (bytes per row)
	 * @param {number} alpha - Alpha to apply to the brush (0-255)
	 */ _paintFlow(brushRect, imageRect, brushShape, brushWidth, alpha) {
        let strokeData = this._strokeBuffer.data, brushOffset = brushRect.left + brushRect.top * brushWidth, strokeOffset = this._strokeBuffer.offsetOfPixel(imageRect.left, imageRect.top), dstHeight = imageRect.getHeight(), dstWidth = imageRect.getWidth(), srcYStride = brushWidth - dstWidth, dstYStride = this._strokeBuffer.width - dstWidth;
        this._strokedRegion.union(imageRect);
        for(let y = 0; y < dstHeight; y++, brushOffset += srcYStride, strokeOffset += dstYStride)for(let x = 0; x < dstWidth; x++, brushOffset++, strokeOffset++){
            let brushAlpha = brushShape[brushOffset] * alpha;
            if (brushAlpha != 0) strokeData[strokeOffset] = Math.min(65025, strokeData[strokeOffset] + (255 - strokeData[strokeOffset] / 255) * brushAlpha / 255);
        }
    }
    /**
	 * The shape of the brush is combined with the alpha in the strokeBuffer with a simple max()
	 * operation. Effectively, the brush just sets the opacity of the buffer.
	 *
	 * Painting the same area multiple times during a single stroke does not increase the opacity.
	 *
	 * @param {CPRect} brushRect
	 * @param {CPRect} imageRect
	 * @param {Uint8Array} brush
	 * @param {number} brushWidth
	 * @param {number} alpha
	 */ _paintOpacity(brushRect, imageRect, brush, brushWidth, alpha) {
        let strokeData = this._strokeBuffer.data, brushOffset = brushRect.left + brushRect.top * brushWidth, imageOffset = this._strokeBuffer.offsetOfPixel(imageRect.left, imageRect.top), imageWidth = imageRect.getWidth(), srcYStride = brushWidth - imageWidth, dstYStride = this._strokeBuffer.width - imageWidth;
        alpha = Math.min(255, alpha);
        this._strokedRegion.union(imageRect);
        for(let y = imageRect.top; y < imageRect.bottom; y++, brushOffset += srcYStride, imageOffset += dstYStride)for(let x = 0; x < imageWidth; x++, brushOffset++, imageOffset++)strokeData[imageOffset] = Math.max(brush[brushOffset] * alpha, strokeData[imageOffset]);
    }
    /**
	 * Allows setup to be performed when a stroke begins
	 */ beginStroke() {}
    /**
	 * Allows teardown to be performed when a stroke ends
	 */ endStroke() {}
}
class CPBrushToolEraser extends CPBrushTool {
    /**
	 * @override
	 */ mergeOntoImage(destImage, undoImage, color) {
        let strokeData = this._strokeBuffer.data, strokedRegion = this._strokedRegion, undoData = undoImage.data, destData = destImage.data;
        for(let y = strokedRegion.top; y < strokedRegion.bottom; y++){
            let dstOffset = destImage.offsetOfPixel(strokedRegion.left, y) + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET, srcOffset = this._strokeBuffer.offsetOfPixel(strokedRegion.left, y);
            for(let x = strokedRegion.left; x < strokedRegion.right; x++, dstOffset += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL){
                let strokeAlpha = strokeData[srcOffset++] / 255 | 0;
                if (strokeAlpha > 0) {
                    let destAlpha = undoData[dstOffset];
                    destData[dstOffset] = destAlpha * (255 - strokeAlpha) / 255;
                }
            }
        }
    }
}
class CPBrushToolDodge extends CPBrushTool {
    /**
	 * Uses the opacity data in the strokeBuffer to brighten non-transparent pixels from the original image.
	 *
	 * @override
	 */ mergeOntoImage(destImage, undoImage, color) {
        let strokeData = this._strokeBuffer.data, strokedRegion = this._strokedRegion, width = strokedRegion.getWidth(), height = strokedRegion.getHeight(), dstOffset = destImage.offsetOfPixel(strokedRegion.left, strokedRegion.top), srcOffset = this._strokeBuffer.offsetOfPixel(strokedRegion.left, strokedRegion.top), dstYSkip = (destImage.width - width) * (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL, srcYSkip = this._strokeBuffer.width - width, undoData = undoImage.data, destImageData = destImage.data;
        for(let y = 0; y < height; y++, srcOffset += srcYSkip, dstOffset += dstYSkip)for(let x = 0; x < width; x++, srcOffset++, dstOffset += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL){
            let strokeAlpha = strokeData[srcOffset] / 255 | 0;
            if (strokeAlpha > 0 && undoData[dstOffset + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET] != 0) {
                let scale = (strokeAlpha + 255) / 255;
                destImageData[dstOffset + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET] = undoData[dstOffset + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET] * scale;
                destImageData[dstOffset + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET] = undoData[dstOffset + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET] * scale;
                destImageData[dstOffset + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET] = undoData[dstOffset + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET] * scale;
            }
        }
    }
    /**
	 * @override
	 */ mergeOntoMask(destMask, undoMask, color) {
        let strokeData = this._strokeBuffer.data, strokedRegion = this._strokedRegion, width = strokedRegion.getWidth(), height = strokedRegion.getHeight(), dstOffset = destMask.offsetOfPixel(strokedRegion.left, strokedRegion.top), srcOffset = this._strokeBuffer.offsetOfPixel(strokedRegion.left, strokedRegion.top), dstYSkip = destMask.width - width, srcYSkip = this._strokeBuffer.width - width, undoMaskData = undoMask.data, destMaskData = destMask.data;
        for(let y = 0; y < height; y++, srcOffset += srcYSkip, dstOffset += dstYSkip)for(let x = 0; x < width; x++, srcOffset++, dstOffset++){
            let strokeAlpha = strokeData[srcOffset] / 255 | 0;
            if (strokeAlpha > 0) {
                let scale = (strokeAlpha + 255) / 255;
                destMaskData[dstOffset] = Math.min(undoMaskData[dstOffset] * scale, 255);
            }
        }
    }
}
const BURN_CONSTANT = 260;
class CPBrushToolBurn extends CPBrushTool {
    /**
	 * Uses the opacity data in the strokeBuffer to brighten non-transparent pixels from the original image.
	 *
	 * @override
	 */ mergeOntoImage(destImage, undoImage, color) {
        let strokeData = this._strokeBuffer.data, strokedRegion = this._strokedRegion, width = strokedRegion.getWidth(), height = strokedRegion.getHeight(), dstOffset = destImage.offsetOfPixel(strokedRegion.left, strokedRegion.top), srcOffset = this._strokeBuffer.offsetOfPixel(strokedRegion.left, strokedRegion.top), dstYSkip = (destImage.width - width) * (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL, srcYSkip = this._strokeBuffer.width - width, undoData = undoImage.data, destImageData = destImage.data;
        for(let y = 0; y < height; y++, srcOffset += srcYSkip, dstOffset += dstYSkip)for(let x = 0; x < width; x++, srcOffset++, dstOffset += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL){
            let strokeAlpha = strokeData[srcOffset] / 255 | 0;
            if (strokeAlpha > 0 && undoData[dstOffset + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET] != 0) {
                destImageData[dstOffset + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET] = undoData[dstOffset + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET] - (BURN_CONSTANT - undoData[dstOffset + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET]) * strokeAlpha / 255 | 0;
                destImageData[dstOffset + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET] = undoData[dstOffset + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET] - (BURN_CONSTANT - undoData[dstOffset + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET]) * strokeAlpha / 255 | 0;
                destImageData[dstOffset + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET] = undoData[dstOffset + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET] - (BURN_CONSTANT - undoData[dstOffset + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET]) * strokeAlpha / 255 | 0;
            }
        }
    }
    /**
	 * @override
	 */ mergeOntoMask(destMask, undoMask, color) {
        let strokeData = this._strokeBuffer.data, strokedRegion = this._strokedRegion, width = strokedRegion.getWidth(), height = strokedRegion.getHeight(), dstOffset = destMask.offsetOfPixel(strokedRegion.left, strokedRegion.top), srcOffset = this._strokeBuffer.offsetOfPixel(strokedRegion.left, strokedRegion.top), dstYSkip = destMask.width - width, srcYSkip = this._strokeBuffer.width - width, undoMaskData = undoMask.data, destMaskData = destMask.data;
        for(let y = 0; y < height; y++, srcOffset += srcYSkip, dstOffset += dstYSkip)for(let x = 0; x < width; x++, srcOffset++, dstOffset++){
            let strokeAlpha = strokeData[srcOffset] / 255 | 0;
            if (strokeAlpha > 0) destMaskData[dstOffset] = Math.max(undoMaskData[dstOffset] - (BURN_CONSTANT - undoMaskData[dstOffset]) * strokeAlpha / 255, 0);
        }
    }
}
const BLUR_MIN = 64, BLUR_MAX = 1;
class CPBrushToolBlur extends CPBrushTool {
    /**
	 * @override
	 */ mergeOntoImage(destImage, undoImage, color) {
        let strokeData = this._strokeBuffer.data, strokedRegion = this._strokedRegion, undoData = undoImage.data, destImageData = destImage.data, width = strokedRegion.getWidth(), destYStride = undoImage.width * (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL, destOffset = undoImage.offsetOfPixel(strokedRegion.left, strokedRegion.top), srcOffset = this._strokeBuffer.offsetOfPixel(strokedRegion.left, strokedRegion.top), destYSkip = (undoImage.width - width) * (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL, srcYSkip = this._strokeBuffer.width - width, r, g, b, a, addSample = function(sampleOffset) {
            r += undoData[sampleOffset + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET];
            g += undoData[sampleOffset + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET];
            b += undoData[sampleOffset + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET];
            a += undoData[sampleOffset + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET];
        };
        for(let y = strokedRegion.top; y < strokedRegion.bottom; y++, destOffset += destYSkip, srcOffset += srcYSkip)for(let x = strokedRegion.left; x < strokedRegion.right; x++, destOffset += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL, srcOffset++){
            let strokeAlpha = strokeData[srcOffset] / 255 | 0;
            if (strokeAlpha > 0) {
                let centralSampleWeight = BLUR_MIN + (BLUR_MAX - BLUR_MIN) * strokeAlpha / 255 | 0, weightSum = centralSampleWeight + 4;
                // Center pixel has a custom weighting
                r = centralSampleWeight * undoData[destOffset + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET];
                g = centralSampleWeight * undoData[destOffset + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET];
                b = centralSampleWeight * undoData[destOffset + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET];
                a = centralSampleWeight * undoData[destOffset + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET];
                // The other pixels have a unit weighting
                // x, y - 1
                addSample(y > 0 ? destOffset - destYStride : destOffset);
                // x, y + 1
                addSample(y < undoImage.height - 1 ? destOffset + destYStride : destOffset);
                // x - 1, y
                addSample(x > 0 ? destOffset - (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL : destOffset);
                // x + 1, y
                addSample(x < undoImage.width - 1 ? destOffset + (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL : destOffset);
                a /= weightSum;
                r /= weightSum;
                g /= weightSum;
                b /= weightSum;
                destImageData[destOffset + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET] = r | 0;
                destImageData[destOffset + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET] = g | 0;
                destImageData[destOffset + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET] = b | 0;
                destImageData[destOffset + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET] = a | 0;
            }
        }
    }
    /**
	 * @override
	 */ mergeOntoMask(destMask, undoMask, color) {
        let strokeData = this._strokeBuffer.data, strokedRegion = this._strokedRegion, undoMaskData = undoMask.data, destMaskData = destMask.data, width = strokedRegion.getWidth(), destYStride = undoMask.width, destOffset = undoMask.offsetOfPixel(strokedRegion.left, strokedRegion.top), srcOffset = this._strokeBuffer.offsetOfPixel(strokedRegion.left, strokedRegion.top), destYSkip = undoMask.width - width, srcYSkip = this._strokeBuffer.width - width, sampleSum;
        for(let y = strokedRegion.top; y < strokedRegion.bottom; y++, destOffset += destYSkip, srcOffset += srcYSkip)for(let x = strokedRegion.left; x < strokedRegion.right; x++, destOffset++, srcOffset++){
            let strokeAlpha = strokeData[srcOffset] / 255 | 0;
            if (strokeAlpha > 0) {
                let centralSampleWeight = BLUR_MIN + (BLUR_MAX - BLUR_MIN) * strokeAlpha / 255 | 0, weightSum = centralSampleWeight + 4;
                // Center pixel has a custom weighting
                sampleSum = centralSampleWeight * undoMaskData[destOffset];
                // The other pixels have a unit weighting
                // x, y - 1
                sampleSum += undoMaskData[y > 0 ? destOffset - destYStride : destOffset];
                // x, y + 1
                sampleSum += undoMaskData[y < undoMask.height - 1 ? destOffset + destYStride : destOffset];
                // x - 1, y
                sampleSum += undoMaskData[x > 0 ? destOffset - 1 : destOffset];
                // x + 1, y
                sampleSum += undoMaskData[x < undoMask.width - 1 ? destOffset + 1 : destOffset];
                destMaskData[destOffset] = sampleSum / weightSum | 0;
            }
        }
    }
}
/**
 * Brushes derived from this class use the strokeBuffer as a ARGB or AG (greyscale) layer.
 *
 * The undoBuffer (pre-stroke image data) is restored to the layer, then the pixels from strokeBuffer are blended
 * on top of that.
 */ class CPBrushToolDirectBrush extends CPBrushTool {
    /**
	 * @override
	 */ mergeOntoImage(destImage, undoImage, color) {
        let strokeData = this._strokeBuffer.data, strokedRegion = this._strokedRegion, undoData = undoImage.data, destImageData = destImage.data, srcOffset = this._strokeBuffer.offsetOfPixel(strokedRegion.left, strokedRegion.top), dstOffset = destImage.offsetOfPixel(strokedRegion.left, strokedRegion.top), width = strokedRegion.getWidth() | 0, height = strokedRegion.getHeight() | 0, srcYStride = this._strokeBuffer.width - width | 0, dstYStride = (destImage.width - width) * (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL | 0;
        for(let y = 0; y < height; y++, srcOffset += srcYStride, dstOffset += dstYStride)for(let x = 0; x < width; x++, srcOffset++, dstOffset += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL){
            let color1 = strokeData[srcOffset], alpha1 = color1 >>> 24;
            if (alpha1 > 0) {
                let alpha2 = undoData[dstOffset + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET], newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0, realAlpha = alpha1 * 255 / newAlpha | 0, invAlpha = 255 - realAlpha;
                destImageData[dstOffset] = ((color1 >> 16 & 0xFF) * realAlpha + undoData[dstOffset] * invAlpha) / 255 | 0;
                destImageData[dstOffset + 1] = ((color1 >> 8 & 0xFF) * realAlpha + undoData[dstOffset + 1] * invAlpha) / 255 | 0;
                destImageData[dstOffset + 2] = ((color1 & 0xFF) * realAlpha + undoData[dstOffset + 2] * invAlpha) / 255 | 0;
                destImageData[dstOffset + 3] = newAlpha;
            }
        }
    }
    /**
	 * @override
	 */ mergeOntoMask(destMask, undoMask, color) {
        let strokeData = this._strokeBuffer.data, strokedRegion = this._strokedRegion, undoMaskData = undoMask.data, destMaskData = destMask.data, srcOffset = this._strokeBuffer.offsetOfPixel(strokedRegion.left, strokedRegion.top), dstOffset = destMask.offsetOfPixel(strokedRegion.left, strokedRegion.top), width = strokedRegion.getWidth() | 0, height = strokedRegion.getHeight() | 0, srcYStride = this._strokeBuffer.width - width | 0, dstYStride = destMask.width - width | 0;
        for(let y = 0; y < height; y++, srcOffset += srcYStride, dstOffset += dstYStride)for(let x = 0; x < width; x++, srcOffset++, dstOffset++){
            let color1 = strokeData[srcOffset], alpha1 = color1 >> 8;
            if (alpha1 > 0) {
                let invAlpha = 255 - alpha1;
                destMaskData[dstOffset] = ((color1 & 0xFF) * alpha1 + undoMaskData[dstOffset] * invAlpha) / 255 | 0;
            }
        }
    }
}
const WATERCOLOR_NUM_SAMPLES = 50, WATERCOLOR_SAMPLE_RADIUS = 64, WATERCOLOR_SPREAD_FACTOR = 2 / 6;
class CPBrushToolWatercolor extends CPBrushToolDirectBrush {
    constructor(strokeBuffer, strokedRegion){
        super(strokeBuffer, strokedRegion);
        this.wantsOutputAsInput = true;
    }
    /**
	 * Average out a bunch of samples from around the given pixel.
	 *
	 * @param {CPGreyBmp} mask
	 * @param {number} x - Center of sample
	 * @param {number} y
	 * @param {number} dx - Spread of samples from center
	 * @param {number} dy
	 *
	 * @returns {number}
	 */ static _sampleGrey(mask, x, y, dx, dy) {
        x = x | 0;
        y = y | 0;
        let samples = [
            {
                x: x,
                y: y
            }
        ];
        for(let r = 0.25; r < 1.001; r += .25)Array.prototype.push.apply(samples, [
            {
                x: ~~(x + r * dx),
                y: y
            },
            {
                x: ~~(x - r * dx),
                y: y
            },
            {
                x: x,
                y: ~~(y + r * dy)
            },
            {
                x: x,
                y: ~~(y - r * dy)
            },
            {
                x: ~~(x + r * 0.7 * dx),
                y: ~~(y + r * 0.7 * dy)
            },
            {
                x: ~~(x + r * 0.7 * dx),
                y: ~~(y - r * 0.7 * dy)
            },
            {
                x: ~~(x - r * 0.7 * dx),
                y: ~~(y + r * 0.7 * dy)
            },
            {
                x: ~~(x - r * 0.7 * dx),
                y: ~~(y - r * 0.7 * dy)
            }
        ]);
        return average(samples.map((coord)=>mask.getPixel(coord.x, coord.y)));
    }
    /**
	 * Average out a bunch of samples from around the given pixel.
	 *
	 * @param {CPColorBmp} image
	 * @param {number} x - Center of sample
	 * @param {number} y
	 * @param {number} dx - Spread of samples from center
	 * @param {number} dy
	 *
	 * @returns {CPColorFloat}
	 */ static _sampleRGB(image, x, y, dx, dy) {
        x = x | 0;
        y = y | 0;
        let samples = [
            {
                x: x,
                y: y
            }
        ];
        for(let r = 0.25; r < 1.001; r += .25)Array.prototype.push.apply(samples, [
            {
                x: ~~(x + r * dx),
                y: y
            },
            {
                x: ~~(x - r * dx),
                y: y
            },
            {
                x: x,
                y: ~~(y + r * dy)
            },
            {
                x: x,
                y: ~~(y - r * dy)
            },
            {
                x: ~~(x + r * 0.7 * dx),
                y: ~~(y + r * 0.7 * dy)
            },
            {
                x: ~~(x + r * 0.7 * dx),
                y: ~~(y - r * 0.7 * dy)
            },
            {
                x: ~~(x - r * 0.7 * dx),
                y: ~~(y + r * 0.7 * dy)
            },
            {
                x: ~~(x - r * 0.7 * dx),
                y: ~~(y - r * 0.7 * dy)
            }
        ]);
        return averageColorFloat(samples.map((coord)=>(0, _cpcolorFloatJsDefault.default).createFromInt(image.getPixel(coord.x, coord.y))));
    }
    /**
	 * Blend the brush stroke with full color into the strokeBuffer
	 *
	 * @param {CPRect} brushRect
	 * @param {CPRect} imageRect
	 * @param {Uint8Array} brushShape
	 * @param {number} brushWidth
	 * @param {number} alpha
	 * @param {number} color1 - RGB brush color
	 */ _paintToColorStrokeBuffer(brushRect, imageRect, brushShape, brushWidth, alpha, color1) {
        let strokeData = this._strokeBuffer.data, width = imageRect.getWidth(), height = imageRect.getHeight(), imageYSkip = this._strokeBuffer.width - width, brushYSkip = brushWidth - width, brushOffset = brushRect.left + brushRect.top * brushWidth, imageOffset = this._strokeBuffer.offsetOfPixel(imageRect.left, imageRect.top);
        this._strokedRegion.union(imageRect);
        for(let y = 0; y < height; y++, brushOffset += brushYSkip, imageOffset += imageYSkip)for(let x = 0; x < width; x++, brushOffset++, imageOffset++){
            let alpha1 = brushShape[brushOffset] * alpha / 255 | 0;
            if (alpha1 > 0) {
                let color2 = strokeData[imageOffset], alpha2 = color2 >>> 24, newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0, realAlpha = alpha1 * 255 / newAlpha | 0, invAlpha = 255 - realAlpha;
                // The usual alpha blending formula C = A * alpha + B * (1 - alpha)
                // has to rewritten in the form C = A + (1 - alpha) * B - (1 - alpha) *A
                // that way the rounding up errors won't cause problems
                strokeData[imageOffset] = newAlpha << 24 | (color1 >> 16 & 0xff) + ((color2 >> 16 & 0xff) * invAlpha - (color1 >> 16 & 0xff) * invAlpha) / 255 << 16 | (color1 >> 8 & 0xff) + ((color2 >> 8 & 0xff) * invAlpha - (color1 >> 8 & 0xff) * invAlpha) / 255 << 8 | (color1 & 0xff) + ((color2 & 0xff) * invAlpha - (color1 & 0xff) * invAlpha) / 255;
            }
        }
    }
    /**
	 * Blend a brush stroke into the strokeBuffer
	 *
	 * @param {CPRect} brushRect
	 * @param {CPRect} imageRect
	 * @param {Uint8Array} brushShape - Defines the shape of the brush tip
	 * @param {number} brushWidth - Width of the brushShape array
	 * @param {number} alpha - 0 - 255 alpha of the brush stroke
	 * @param {number} color1 - Greyscale intensity (0 - 255)
	 */ _paintToGreyscaleStrokeBuffer(brushRect, imageRect, brushShape, brushWidth, alpha, color1) {
        let strokeData = this._strokeBuffer.data;
        this._strokedRegion.union(imageRect);
        for(let destY = imageRect.top, brushY = brushRect.top; destY < imageRect.bottom; destY++, brushY++){
            let srcOffset = brushRect.left + brushY * brushWidth, dstOffset = this._strokeBuffer.offsetOfPixel(imageRect.left, destY);
            for(let destX = imageRect.left; destX < imageRect.right; destX++, srcOffset++, dstOffset++){
                let alpha1 = brushShape[srcOffset] * alpha / 255 | 0;
                if (alpha1 <= 0) continue;
                let color2 = strokeData[dstOffset], alpha2 = color2 >> 8, newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0;
                if (newAlpha > 0) {
                    let realAlpha = alpha1 * 255 / newAlpha | 0, invAlpha = 255 - realAlpha;
                    // The usual alpha blending formula C = A * alpha + B * (1 - alpha)
                    // has to rewritten in the form C = A + (1 - alpha) * B - (1 - alpha) *A
                    // that way the rounding up errors won't cause problems
                    strokeData[dstOffset] = newAlpha << 8 | color1 + ((color2 & 0xFF) * invAlpha - color1 * invAlpha) / 255;
                }
            }
        }
    }
    /**
	 * @override
	 */ beginStroke() {
        this._previousSamples = null;
    }
    /**
	 * @override
	 */ paintDab(destImage, imageRect, sampleImage, brushConfig, brushRect, dab, color) {
        var paintAlpha = Math.max(1, dab.alpha / 4), sampleX = (imageRect.left + imageRect.right) / 2, sampleY = (imageRect.top + imageRect.bottom) / 2, dx = Math.max(1, Math.min(WATERCOLOR_SAMPLE_RADIUS, imageRect.getWidth() * WATERCOLOR_SPREAD_FACTOR)), dy = Math.max(1, Math.min(WATERCOLOR_SAMPLE_RADIUS, imageRect.getHeight() * WATERCOLOR_SPREAD_FACTOR));
        if (sampleImage instanceof (0, _cpgreyBmpJsDefault.default)) {
            // Mask editing
            if (this._previousSamples == null) {
                // Seed the previousSamples list to capacity with a bunch of copies of one sample to get us started
                this._previousSamples = new Array(WATERCOLOR_NUM_SAMPLES);
                this._previousSamples.fill(CPBrushToolWatercolor._sampleGrey(sampleImage, sampleX, sampleY, dx, dy));
            }
            let wcColor = average(this._previousSamples), newColor;
            // resaturation
            wcColor = lerp(wcColor, color & 0xFF, brushConfig.resat * brushConfig.resat);
            newColor = wcColor;
            // bleed
            wcColor = lerp(wcColor, CPBrushToolWatercolor._sampleGrey(sampleImage, sampleX, sampleY, dx, dy), brushConfig.bleed);
            this._previousSamples.push(wcColor);
            this._previousSamples.shift();
            this._paintToGreyscaleStrokeBuffer(brushRect, imageRect, dab.brush, dab.width, paintAlpha, Math.round(newColor));
        } else {
            if (this._previousSamples == null) {
                // Seed the previousSamples list to capacity with a bunch of copies of one sample to get us started
                this._previousSamples = new Array(WATERCOLOR_NUM_SAMPLES);
                this._previousSamples.fill(CPBrushToolWatercolor._sampleRGB(sampleImage, sampleX, sampleY, dx, dy));
            }
            let wcColor = averageColorFloat(this._previousSamples);
            // resaturation - add the brush's color to the mixture
            wcColor.mixWith((0, _cpcolorFloatJsDefault.default).createFromInt(color), brushConfig.resat * brushConfig.resat);
            let newColor = wcColor.toInt();
            // bleed
            wcColor.mixWith(CPBrushToolWatercolor._sampleRGB(sampleImage, sampleX, sampleY, dx, dy), brushConfig.bleed);
            this._previousSamples.push(wcColor);
            this._previousSamples.shift();
            this._paintToColorStrokeBuffer(brushRect, imageRect, dab.brush, dab.width, paintAlpha, newColor);
        }
    }
}
class CPBrushToolOil extends CPBrushToolDirectBrush {
    constructor(strokeBuffer, strokedRegion){
        super(strokeBuffer, strokedRegion);
        this.wantsOutputAsInput = true;
    }
    /**
	 * Sample intensities from the image and mix them into the brush.
	 *
	 * @param {CPColorBmp} maskToSample
	 * @param {CPRect} brushRect
	 * @param {CPRect} imageRect
	 * @param {number} alpha1 - 0-255 controls how much paint is picked up from the image
	 */ _accumulatePaintFromMask(maskToSample, brushRect, imageRect, alpha1) {
        let brushData = this._brushBuffer.data, sampleData = maskToSample.data, width = imageRect.getWidth(), height = imageRect.getHeight(), srcOffset = brushRect.left + brushRect.top * this._brushBuffer.width, dstOffset = maskToSample.offsetOfPixel(imageRect.left, imageRect.top), srcYSkip = this._brushBuffer.width - width, dstYSkip = maskToSample.width - width;
        if (alpha1 <= 0) return;
        for(let y = 0; y < height; y++, srcOffset += srcYSkip, dstOffset += dstYSkip)for(let x = 0; x < width; x++, srcOffset++, dstOffset++){
            let grey1 = sampleData[dstOffset], grey2 = brushData[srcOffset], alpha2 = grey2 >> 8, newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0, realAlpha = alpha1 * 255 / newAlpha | 0, invAlpha = 255 - realAlpha;
            brushData[srcOffset] = newAlpha << 8 | grey1 + ((grey2 & 0xff) * invAlpha - grey1 * invAlpha) / 255;
        }
    }
    /**
	 * Add some of the given grey value back into the brush.
	 *
	 * @param {CPRect} brushRect
	 * @param {number} alpha1 - Strength of resaturation (0-255)
	 * @param {number} grey1 - Intensity to resaturate brush tip with
	 */ _resaturateBrushWithGrey(brushRect, alpha1, grey1) {
        if (alpha1 <= 0) return;
        let brushData = this._brushBuffer.data, width = brushRect.getWidth(), height = brushRect.getHeight(), brushOffset = brushRect.left + brushRect.top * this._brushBuffer.width, brushYSkip = this._brushBuffer.width - width;
        for(let y = 0; y < height; y++, brushOffset += brushYSkip)for(let x = 0; x < width; x++, brushOffset++){
            let grey2 = brushData[brushOffset], alpha2 = grey2 >> 8, newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0, realAlpha = alpha1 * 255 / newAlpha | 0, invAlpha = 255 - realAlpha;
            brushData[brushOffset] = newAlpha << 8 | grey1 + ((grey2 & 0xff) * invAlpha - grey1 * invAlpha) / 255;
        }
    }
    /**
	 * Mixes the paint on the current brush with the pixels of the layer, and writes the result into the
	 * AG strokeBuffer.
	 *
	 * @param {CPGreyBmp} destImage - Image that is being drawn onto
	 * @param {CPRect} brushRect
	 * @param {CPRect} imageRect
	 * @param {Uint8Array} brushShape - Brush opacity map which defines its shape, of the same width as brushBuffer
	 * @param {number} alpha 0-255 brush alpha
	 */ _paintToGreyscaleStrokeBuffer(destImage, brushRect, imageRect, brushShape, alpha) {
        let strokeData = this._strokeBuffer.data, brushData = this._brushBuffer.data, destImageData = destImage.data;
        this._strokedRegion.union(imageRect);
        for(let y = imageRect.top, brushY = brushRect.top; y < imageRect.bottom; y++, brushY++){
            let bufferOffset = this._brushBuffer.offsetOfPixel(brushRect.left, brushY), strokeOffset = this._strokeBuffer.offsetOfPixel(imageRect.left, y), layerOffset = destImage.offsetOfPixel(imageRect.left, y);
            for(let x = imageRect.left; x < imageRect.right; x++, bufferOffset++, layerOffset++, strokeOffset++){
                let grey1 = brushData[bufferOffset], alpha1 = (grey1 >> 8) * brushShape[bufferOffset] * alpha / 65025 | 0;
                if (alpha1 > 0) {
                    let grey2 = destImageData[layerOffset], invAlpha = 255 - alpha1;
                    strokeData[strokeOffset] = 65280 | (grey1 & 0xff) + (grey2 * invAlpha - (grey1 & 0xff) * invAlpha) / 255;
                }
            }
        }
    }
    /**
	 * Sample colors from the image and mix them into the brush.
	 *
	 * @param {CPColorBmp} imageToSample
	 * @param {CPRect} brushRect
	 * @param {CPRect} imageRect
	 * @param {number} alpha - 0-255 controls how much paint is picked up from the image
	 */ _accumulatePaintFromImage(imageToSample, brushRect, imageRect, alpha) {
        let brushData = this._brushBuffer.data, sampleData = imageToSample.data, width = imageRect.getWidth(), height = imageRect.getHeight(), srcOffset = brushRect.left + brushRect.top * this._brushBuffer.width, dstOffset = imageToSample.offsetOfPixel(imageRect.left, imageRect.top), srcYSkip = this._brushBuffer.width - width, dstYSkip = (imageToSample.width - width) * (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL;
        for(let y = 0; y < height; y++, srcOffset += srcYSkip, dstOffset += dstYSkip)for(let x = 0; x < width; x++, srcOffset++, dstOffset += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL){
            let alpha1 = sampleData[dstOffset + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET] * alpha / 255 | 0;
            if (alpha1 > 0) {
                let color2 = brushData[srcOffset], alpha2 = color2 >>> 24, newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0, realAlpha = alpha1 * 255 / newAlpha | 0, invAlpha = 255 - realAlpha, color1Red = sampleData[dstOffset + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET], color1Green = sampleData[dstOffset + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET], color1Blue = sampleData[dstOffset + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET];
                brushData[srcOffset] = newAlpha << 24 | color1Red + ((color2 >> 16 & 0xff) * invAlpha - color1Red * invAlpha) / 255 << 16 | color1Green + ((color2 >> 8 & 0xff) * invAlpha - color1Green * invAlpha) / 255 << 8 | color1Blue + ((color2 & 0xff) * invAlpha - color1Blue * invAlpha) / 255;
            }
        }
    }
    /**
	 * Add some of the given color back into the brush.
	 *
	 * @param {CPRect} brushRect
	 * @param {number} alpha1 - Strength of resaturation (0-255)
	 * @param {number} color1 - RGB color to resaturate brush tip with
	 */ _resaturateBrushWithColor(brushRect, alpha1, color1) {
        if (alpha1 <= 0) return;
        let brushData = this._brushBuffer.data, width = brushRect.getWidth(), height = brushRect.getHeight(), brushOffset = brushRect.left + brushRect.top * this._brushBuffer.width, brushYSkip = this._brushBuffer.width - width;
        for(let y = 0; y < height; y++, brushOffset += brushYSkip)for(let x = 0; x < width; x++, brushOffset++){
            let color2 = brushData[brushOffset], alpha2 = color2 >>> 24, newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0, realAlpha = alpha1 * 255 / newAlpha | 0, invAlpha = 255 - realAlpha;
            brushData[brushOffset] = newAlpha << 24 | (color1 >>> 16 & 0xff) + ((color2 >>> 16 & 0xff) * invAlpha - (color1 >>> 16 & 0xff) * invAlpha) / 255 << 16 | (color1 >>> 8 & 0xff) + ((color2 >>> 8 & 0xff) * invAlpha - (color1 >>> 8 & 0xff) * invAlpha) / 255 << 8 | (color1 & 0xff) + ((color2 & 0xff) * invAlpha - (color1 & 0xff) * invAlpha) / 255;
        }
    }
    /**
	 * Mixes the paint on the current brush with the pixels of the layer, and writes the result into the
	 * strokeBuffer.
	 *
	 * @param {CPColorBmp} destImage - Image that is being drawn onto
	 * @param {CPRect} brushRect
	 * @param {CPRect} imageRect
	 * @param {Uint8Array} brushShape - Brush opacity map which defines its shape, of the same width as brushBuffer
	 * @param {number} alpha 0-255 brush alpha
	 */ _paintToColorStrokeBuffer(destImage, brushRect, imageRect, brushShape, alpha) {
        let strokeData = this._strokeBuffer.data, brushData = this._brushBuffer.data, destImageData = destImage.data;
        this._strokedRegion.union(imageRect);
        for(let y = imageRect.top, brushY = brushRect.top; y < imageRect.bottom; y++, brushY++){
            let bufferOffset = this._brushBuffer.offsetOfPixel(brushRect.left, brushY), strokeOffset = this._strokeBuffer.offsetOfPixel(imageRect.left, y), layerOffset = destImage.offsetOfPixel(imageRect.left, y);
            for(let x = imageRect.left; x < imageRect.right; x++, bufferOffset++, layerOffset += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL, strokeOffset++){
                let color1 = brushData[bufferOffset], alpha1 = (color1 >>> 24) * brushShape[bufferOffset] * alpha / 65025 | 0;
                if (alpha1 > 0) {
                    let alpha2 = destImageData[layerOffset + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET], newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0, color2Red = destImageData[layerOffset + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET], color2Green = destImageData[layerOffset + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET], color2Blue = destImageData[layerOffset + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET], realAlpha = alpha1 * 255 / newAlpha | 0, invAlpha = 255 - realAlpha;
                    strokeData[strokeOffset] = newAlpha << 24 | (color1 >> 16 & 0xff) + (color2Red * invAlpha - (color1 >> 16 & 0xff) * invAlpha) / 255 << 16 | (color1 >> 8 & 0xff) + (color2Green * invAlpha - (color1 >> 8 & 0xff) * invAlpha) / 255 << 8 | (color1 & 0xff) + (color2Blue * invAlpha - (color1 & 0xff) * invAlpha) / 255;
                }
            }
        }
    }
    /**
	 * @override
	 */ paintDab(destImage, imageRect, sampleImage, brushConfig, brushRect, dab, color) {
        if (destImage instanceof (0, _cpcolorBmpJsDefault.default)) {
            if (this._brushBuffer == null) {
                // TODO this means we can't have pressure sensitive tip sizes for Oil (see CPBrushInfo.applyPressure)
                this._brushBuffer = new (0, _cpgreyBmpJsDefault.default)(dab.width, dab.height, 32); // Initialized to 0 for us by the browser
                this._accumulatePaintFromImage(sampleImage, brushRect, imageRect, 255);
            } else {
                this._resaturateBrushWithColor(brushRect, ~~(brushConfig.resat <= 0.0 ? 0 : Math.max(1, brushConfig.resat * brushConfig.resat * 255)), color & 0xFFFFFF);
                this._paintToColorStrokeBuffer(destImage, brushRect, imageRect, dab.brush, dab.alpha);
                this._accumulatePaintFromImage(sampleImage, brushRect, imageRect, ~~(brushConfig.bleed * 255));
            }
        } else if (this._brushBuffer == null) {
            this._brushBuffer = new (0, _cpgreyBmpJsDefault.default)(dab.width, dab.height, 16); // Initialized to 0 for us by the browser
            this._accumulatePaintFromMask(sampleImage, brushRect, imageRect, 255);
        } else {
            this._resaturateBrushWithGrey(brushRect, ~~(brushConfig.resat <= 0.0 ? 0 : Math.max(1, brushConfig.resat * brushConfig.resat * 255)), color & 0xFF);
            this._paintToGreyscaleStrokeBuffer(destImage, brushRect, imageRect, dab.brush, dab.alpha);
            this._accumulatePaintFromMask(sampleImage, brushRect, imageRect, ~~(brushConfig.bleed * 255));
        }
    }
    endStroke() {
        this._brushBuffer = null;
    }
}
/**
 * Spread the image pixels within the given rectangle outwards to fill the image with pixels.
 *
 * @param {CPGreyBmp} image
 * @param {CPRect} rect
 */ function stretchRectToFillBuffer(image, rect) {
    const imageData = image.data;
    // First stretch the source rect pixels out horizontally to fill W and E areas
    if (rect.left > 0) for(let y = rect.top; y < rect.bottom; y++){
        let rowStartOffset = y * image.width, dstOffset = rowStartOffset, fillColor = imageData[rowStartOffset + rect.left];
        for(let x = 0; x < rect.left; x++, dstOffset++)imageData[dstOffset] = fillColor;
    }
    if (rect.right < image.width) for(let y = rect.top; y < rect.bottom; y++){
        let rowStartOffset = y * image.width, dstOffset = rowStartOffset + rect.right, fillColor = imageData[dstOffset - 1];
        for(let x = rect.right; x < image.width; x++, dstOffset++)imageData[dstOffset] = fillColor;
    }
    // Then stretch those rows upwards and downwards (to fill NW, N, NE, SW, S, SE areas)
    let dstOffset = 0;
    for(let y = 0; y < rect.top; y++){
        let srcOffset = rect.top * image.width;
        for(let x = 0; x < image.width; x++, srcOffset++, dstOffset++)imageData[dstOffset] = imageData[srcOffset];
    }
    dstOffset = rect.bottom * image.width;
    for(let y = rect.bottom; y < image.width; y++){
        let srcOffset = (rect.bottom - 1) * image.width;
        for(let x = 0; x < image.width; x++, srcOffset++, dstOffset++)imageData[dstOffset] = imageData[srcOffset];
    }
}
class CPBrushToolSmudge extends CPBrushToolDirectBrush {
    constructor(strokeBuffer, strokedRegion){
        super(strokeBuffer, strokedRegion);
        this._brushBuffer = null;
        this.wantsOutputAsInput = true;
        this.noMergePhase = true;
    }
    /**
	 * Pick up paint from the given image and store into the AG brush buffer.
	 *
	 * @param {CPGreyBmp} sampleMask - Mask to sample from
	 * @param {CPRect} maskRect - Rectangle of the canvas that our brush covers
	 * @param {CPRect} brushRect - The corresponding rectangle within the brush buffer
	 * @param {number} alpha - Alpha of brush (0-255)
	 */ _sampleFromMask(sampleMask, brushRect, maskRect, alpha) {
        let brushData = this._brushBuffer.data, width = brushRect.getWidth(), height = brushRect.getHeight(), brushOffset = this._brushBuffer.offsetOfPixel(brushRect.left, brushRect.top), maskOffset = sampleMask.offsetOfPixel(maskRect.left, maskRect.top), brushYSkip = this._brushBuffer.width - width, maskYSkip = sampleMask.width - width, invAlpha = 255 - alpha;
        if (alpha == 255) // Brush doesn't sample from the image
        return;
        // Blend pixels (in the area where the brush overlaps the canvas) into the brush buffer
        for(let y = 0; y < height; y++, brushOffset += brushYSkip, maskOffset += maskYSkip)for(let x = 0; x < width; x++, brushOffset++, maskOffset++){
            let sampleGrey = sampleMask.data[maskOffset], oldBrushColor = brushData[brushOffset], newBrushGrey = (sampleGrey * invAlpha + (oldBrushColor & 0xff) * alpha) / 255, newBrushColor = (255 * invAlpha + (oldBrushColor >> 8) * alpha) / 255 << 8 | newBrushGrey;
            /* If low-alpha rounding caused us to not even update the brush color, take a 1-unit step
				 * in the direction of the sample color.
				 */ if (newBrushColor == oldBrushColor) {
                if (sampleGrey > newBrushGrey) newBrushColor++;
                else if (sampleGrey < newBrushGrey) newBrushColor--;
            }
            brushData[brushOffset] = newBrushColor;
        }
        /*
		 * The areas of the brush buffer that lay outside the canvas haven't been filled yet. Stretch the pixels
		 * around the edge of the area we did sample to fill in the gaps.
		 */ stretchRectToFillBuffer(this._brushBuffer, brushRect);
    }
    /**
	 * Replace the destination mask with the smudge buffer within the shape of the brush tip.
	 *
	 * @param {CPGreyBmp} destMask
	 * @param {CPRect} brushRect
	 * @param {CPRect} imageRect
	 * @param {Uint8Array} brushShape - Of the same width as this._brushBuffer
	 */ _paintToMask(destMask, brushRect, imageRect, brushShape) {
        let width = brushRect.getWidth(), height = brushRect.getHeight(), srcOffset = this._brushBuffer.offsetOfPixel(brushRect.left, brushRect.top), dstOffset = destMask.offsetOfPixel(imageRect.left, imageRect.top), srcYSkip = this._brushBuffer.width - width, dstYSkip = destMask.width - width, destMaskData = destMask.data, brushPaintData = this._brushBuffer.data;
        for(let y = 0; y < height; y++, dstOffset += dstYSkip, srcOffset += srcYSkip)for(let x = 0; x < width; x++, srcOffset++, dstOffset++){
            let paintValue = brushPaintData[srcOffset], strokeAlpha = (paintValue >> 8) * brushShape[srcOffset] / 255 | 0, strokeColor = paintValue & 0xff;
            if (strokeAlpha > 0) destMaskData[dstOffset] = strokeColor;
        }
    }
    /**
	 * Pick up paint from the given image and store into the brush buffer.
	 *
	 * @param {CPColorBmp} sampleImage - Image to sample from
	 * @param {CPRect} imageRect - Rectangle of the canvas that our brush covers
	 * @param {CPRect} brushRect - The corresponding rectangle within the brush buffer
	 * @param {number} alpha - Alpha of brush (0-255)
	 */ _sampleFromImage(sampleImage, brushRect, imageRect, alpha) {
        let brushData = this._brushBuffer.data, width = brushRect.getWidth(), height = brushRect.getHeight(), brushOffset = this._brushBuffer.offsetOfPixel(brushRect.left, brushRect.top), imageOffset = sampleImage.offsetOfPixel(imageRect.left, imageRect.top), brushYSkip = this._brushBuffer.width - width, imageYSkip = (sampleImage.width - width) * (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL, invAlpha = 255 - alpha;
        if (alpha == 255) // Brush doesn't sample from the image
        return;
        // Blend pixels (in the area where the brush overlaps the canvas) into the brush buffer
        for(let y = 0; y < height; y++, brushOffset += brushYSkip, imageOffset += imageYSkip)for(let x = 0; x < width; x++, brushOffset++, imageOffset += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL){
            let sampleRed = sampleImage.data[imageOffset + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET], sampleGreen = sampleImage.data[imageOffset + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET], sampleBlue = sampleImage.data[imageOffset + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET], sampleAlpha = sampleImage.data[imageOffset + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET], oldBrushColor = brushData[brushOffset], newBrushColor = (sampleAlpha * invAlpha + (oldBrushColor >> 24 & 0xff) * alpha) / 255 << 24 & 0xff000000 | (sampleRed * invAlpha + (oldBrushColor >> 16 & 0xff) * alpha) / 255 << 16 & 0xff0000 | (sampleGreen * invAlpha + (oldBrushColor >> 8 & 0xff) * alpha) / 255 << 8 & 0xff00 | (sampleBlue * invAlpha + (oldBrushColor & 0xff) * alpha) / 255 & 0xff;
            /* If low-alpha rounding caused us to not even update the brush color, take a 1-unit step
				 * in the direction of the sample color.
				 */ if (newBrushColor == oldBrushColor) {
                let newBrushRed = (newBrushColor & 0xff0000) >> 16, newBrushGreen = (newBrushColor & 0x00ff00) >> 8, newBrushBlue = newBrushColor & 0x0000ff;
                if (sampleRed > newBrushRed) newBrushColor += 65536;
                else if (sampleRed < newBrushRed) newBrushColor -= 65536;
                if (sampleGreen > newBrushGreen) newBrushColor += 256;
                else if (sampleGreen < newBrushGreen) newBrushColor -= 256;
                if (sampleBlue > newBrushBlue) newBrushColor += 1;
                else if (sampleBlue < newBrushBlue) newBrushColor -= 1;
            }
            brushData[brushOffset] = newBrushColor;
        }
        /*
		 * The areas of the brush buffer that lay outside the canvas haven't been filled yet. Stretch the pixels
		 * around the edge of the area we did sample to fill in the gaps.
		 */ stretchRectToFillBuffer(this._brushBuffer, brushRect);
    }
    /**
	 * Replace the layer's image with the smudge buffer within the shape of the brush tip.
	 *
	 * @param {CPColorBmp} destImage
	 * @param {CPRect} brushRect
	 * @param {CPRect} imageRect
	 * @param {Uint8Array} brushShape - Of the same width as this._brushBuffer
	 */ _paintToImage(destImage, brushRect, imageRect, brushShape) {
        let width = brushRect.getWidth(), height = brushRect.getHeight(), srcOffset = this._brushBuffer.offsetOfPixel(brushRect.left, brushRect.top), dstOffset = destImage.offsetOfPixel(imageRect.left, imageRect.top), srcYSkip = this._brushBuffer.width - width, dstYSkip = (destImage.width - width) * (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL, destImageData = destImage.data, brushPaintData = this._brushBuffer.data;
        for(let y = 0; y < height; y++, dstOffset += dstYSkip, srcOffset += srcYSkip)for(let x = 0; x < width; x++, srcOffset++, dstOffset += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL){
            let paintColor = brushPaintData[srcOffset], strokeAlpha = (paintColor >>> 24) * brushShape[srcOffset] / 255 | 0;
            if (strokeAlpha > 0) {
                destImageData[dstOffset + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET] = paintColor >> 16 & 0xff;
                destImageData[dstOffset + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET] = paintColor >> 8 & 0xff;
                destImageData[dstOffset + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET] = paintColor & 0xff;
                destImageData[dstOffset + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET] = paintColor >> 24 & 0xff;
            }
        }
    }
    /**
	 * @override
	 */ paintDab(destImage, imageRect, sampleImage, brushConfig, brushRect, dab, color) {
        if (destImage instanceof (0, _cpcolorBmpJsDefault.default)) {
            if (this._brushBuffer == null) {
                this._brushBuffer = new (0, _cpgreyBmpJsDefault.default)(dab.width, dab.height, 32);
                this._sampleFromImage(sampleImage, brushRect, imageRect, 0);
            } else {
                this._sampleFromImage(sampleImage, brushRect, imageRect, dab.alpha);
                this._paintToImage(destImage, brushRect, imageRect, dab.brush);
            }
        } else if (this._brushBuffer == null) {
            this._brushBuffer = new (0, _cpgreyBmpJsDefault.default)(dab.width, dab.height, 16);
            this._sampleFromMask(sampleImage, brushRect, imageRect, 0);
        } else {
            this._sampleFromMask(sampleImage, brushRect, imageRect, dab.alpha);
            this._paintToMask(destImage, brushRect, imageRect, dab.brush);
        }
    }
    /**
	 * A no-op since our paint implementation paints directly to the underlying image during the stroke.
	 *
	 * @override
	 */ mergeOntoImage(destImage, undoImage, color) {}
    mergeOntoMask(destMask, undoMask, color) {}
    /**
	 * @override
	 */ beginStroke() {
        this._brushBuffer = null;
    }
    /**
	 * @override
	 */ endStroke() {
        this._brushBuffer = null;
    }
}

},{"./CPColorBmp.js":"5rykl","./CPGreyBmp.js":"fGKWG","./CPBrushInfo.js":"b7K5Z","../util/CPColorFloat.js":"10ANI","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"10ANI":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ /**
 * An RGB color with floating point values for each channel (between 0.0 and 1.0)
 *
 * @param {number} r
 * @param {number} g
 * @param {number} b
 *
 * @constructor
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPColorFloat);
function CPColorFloat(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
}
CPColorFloat.prototype.toInt = function() {
    return Math.max(0, Math.min(255, Math.round(this.r * 255))) << 16 | Math.max(0, Math.min(255, Math.round(this.g * 255))) << 8 | Math.max(0, Math.min(255, Math.round(this.b * 255)));
};
CPColorFloat.prototype.mixWith = function(color, alpha) {
    this.r = this.r * (1.0 - alpha) + color.r * alpha;
    this.g = this.g * (1.0 - alpha) + color.g * alpha;
    this.b = this.b * (1.0 - alpha) + color.b * alpha;
};
CPColorFloat.prototype.clone = function() {
    return new CPColorFloat(this.r, this.g, this.b);
};
CPColorFloat.createFromInt = function(color) {
    return new CPColorFloat((color >>> 16 & 0xff) / 255, (color >>> 8 & 0xff) / 255, (color & 0xff) / 255);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gCU6E":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPResourceLoader);
var _cpchibiFileJs = require("./CPChibiFile.js");
var _cpartworkJs = require("./CPArtwork.js");
var _cpartworkJsDefault = parcelHelpers.interopDefault(_cpartworkJs);
var _cpcolorBmpJs = require("./CPColorBmp.js");
var _cpcolorBmpJsDefault = parcelHelpers.interopDefault(_cpcolorBmpJs);
var _cpimageLayerJs = require("./CPImageLayer.js");
var _cpimageLayerJsDefault = parcelHelpers.interopDefault(_cpimageLayerJs);
var _adobeColorTableJs = require("../util/AdobeColorTable.js");
var _adobeColorTableJsDefault = parcelHelpers.interopDefault(_adobeColorTableJs);
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
function CPResourceLoader(options) {
    var resources = [], completed = {}, that = this;
    if (options.loadChibiFileUrl && ("" + options.loadChibiFileUrl).length > 0) resources.push({
        url: options.loadChibiFileUrl,
        friendly: "drawing layers",
        name: "layers",
        required: true
    });
    else if (options.loadImageUrl && ("" + options.loadImageUrl).length > 0) resources.push({
        url: options.loadImageUrl,
        friendly: "drawing",
        name: "flat",
        required: true
    });
    if (options.loadSwatchesUrl) resources.push({
        url: options.loadSwatchesUrl,
        friendly: "color swatches",
        name: "swatches",
        required: false,
        noProgress: true // So short that we may as well keep the smoothie drained
    });
    /**
     *
     * @param resource
     * @param resourceData
     * @returns {Promise}
     */ function decodeResource(resource, resourceData) {
        switch(resource.name){
            case "flat":
                return new Promise(function(resolve, reject) {
                    let blob = new Blob([
                        resourceData
                    ], {
                        type: "image/png"
                    }), imageUrl = window.URL.createObjectURL(blob);
                    if (imageUrl) {
                        let image = new Image();
                        image.onload = function() {
                            let artwork = new (0, _cpartworkJsDefault.default)(this.width, this.height), layer = new (0, _cpimageLayerJsDefault.default)(0, 0, "Layer 1");
                            layer.image = (0, _cpcolorBmpJsDefault.default).createFromImage(image);
                            artwork.addLayerObject(artwork.getLayersRoot(), layer);
                            image = null;
                            window.URL.revokeObjectURL(imageUrl);
                            resolve(artwork);
                        };
                        image.src = imageUrl;
                    } else reject(null);
                });
            case "swatches":
                let reader = new (0, _adobeColorTableJsDefault.default)(), colors = reader.read(resourceData);
                if (colors) return Promise.resolve(colors);
                else return Promise.reject(null);
            case "layers":
                return (0, _cpchibiFileJs.load)(resourceData);
            default:
                return Promise.reject("Unexpected resource type '" + resource.name + "'");
        }
    }
    function reportProgress(resource, progress) {
        if (progress === null) that.emitEvent("loadingProgress", [
            1.0,
            "Loading your " + resource.friendly + "..."
        ]);
        else that.emitEvent("loadingProgress", [
            progress,
            "Loading your " + resource.friendly + " (" + Math.round(progress * 100) + "%)..."
        ]);
    }
    this.load = function() {
        if (resources.length == 0) {
            that.emitEvent("loadingComplete", [
                completed
            ]);
            return;
        }
        var resource = resources.shift(), xhr = new XMLHttpRequest();
        xhr.addEventListener("progress", function(evt) {
            var progress;
            if (evt.lengthComputable && !resource.noProgress) progress = evt.loaded / evt.total;
            else progress = null;
            reportProgress(resource, progress);
        }, false);
        function handleFatal() {
            if (resource.required) that.emitEvent("loadingFailure", [
                "Failed to load your " + resource.friendly + ", please try again later."
            ]);
            else // Skip unimportant resources
            that.load();
        }
        xhr.addEventListener("load", function(evt) {
            if (this.status == 200) {
                let response = this.response;
                that.emitEvent("loadingProgress", [
                    1.0,
                    "Starting ChickenPaint..."
                ]);
                // Yield to the DOM to give it a chance to paint the loaded message before we begin decoding
                setTimeout(function() {
                    decodeResource(resource, response).then(function(decoded) {
                        completed[resource.name] = decoded;
                        // Move on to the next file
                        that.load();
                    }, function() {
                        that.emitEvent("loadingFailure", [
                            "Failed to read your " + resource.friendly
                        ]);
                    });
                }, 0);
            } else handleFatal();
        }, false);
        xhr.addEventListener("error", handleFatal);
        reportProgress(resource, resource.noProgress ? null : 0.0);
        xhr.open("GET", resource.url, true);
        xhr.responseType = 'arraybuffer';
        xhr.send();
    };
}
CPResourceLoader.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
CPResourceLoader.prototype.constructor = CPResourceLoader;

},{"./CPChibiFile.js":"2P1CH","./CPArtwork.js":"3AbfY","./CPColorBmp.js":"5rykl","./CPImageLayer.js":"93gOf","../util/AdobeColorTable.js":"lWtyz","wolfy87-eventemitter":"gPUo0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2P1CH":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint

    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.

    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {Object} SerializeResult
 * @property {(Blob|Uint8Array)} SerializeResult.bytes - A Blob when called in the browser, or a Uint8Array in Node.
 * @property {String} SerializeResult.version - Version string of created artwork, "ChibiPaint v0.0" or "ChickenPaint v0.10"
 */ /**
 * Serialize the given artwork to Chibifile format.
 *
 * @param {CPArtwork} artwork
 * @param {?Object} options
 * @param {boolean} options.forceOldVersion - Mark this as a version 0.0 (ChibiPaint) drawing even if it uses new features
 *
 * @returns {Promise.<SerializeResult>}
 */ parcelHelpers.export(exports, "save", ()=>save);
/**
 * Attempt to load a chibifile from the given source.
 *
 * @param {ArrayBuffer|Blob} source
 * @param {?Object}        options
 * @param {boolean|string} options.upgradeMultiplyLayers - false to leave all multiply layers alone, "bake" to modify
 *                                                         pixel values to use LM_MULTIPLY2 blending. Anything else to
 *                                                         set blendMode to LM_MULTIPLY or LM_MULTIPLY2 as needed.
 *
 * @returns {Promise.<CPArtwork>}
 */ parcelHelpers.export(exports, "load", ()=>load);
var _cpartworkJs = require("./CPArtwork.js");
var _cpartworkJsDefault = parcelHelpers.interopDefault(_cpartworkJs);
var _cpimageLayerJs = require("./CPImageLayer.js");
var _cpimageLayerJsDefault = parcelHelpers.interopDefault(_cpimageLayerJs);
var _cpcolorBmpJs = require("./CPColorBmp.js");
var _cpcolorBmpJsDefault = parcelHelpers.interopDefault(_cpcolorBmpJs);
var _arrayDataStreamJs = require("../util/ArrayDataStream.js");
var _arrayDataStreamJsDefault = parcelHelpers.interopDefault(_arrayDataStreamJs);
var _cplayerGroupJs = require("./CPLayerGroup.js");
var _cplayerGroupJsDefault = parcelHelpers.interopDefault(_cplayerGroupJs);
var _cpgreyBmpJs = require("./CPGreyBmp.js");
var _cpgreyBmpJsDefault = parcelHelpers.interopDefault(_cpgreyBmpJs);
var _cpblendJs = require("./CPBlend.js");
var _cpblendJsDefault = parcelHelpers.interopDefault(_cpblendJs);
var _pako = require("pako");
var _pakoDefault = parcelHelpers.interopDefault(_pako);
/**
 * Concat two Uint8Arrays to make a new one and return it.
 *
 * Either one may be set to null. If either one is null, the other is returned. If both are null, null is
 * returned.
 */ function concatBuffers(one, two) {
    if (one === null || one.length === 0) return two;
    if (two === null || two.length === 0) return one;
    let result = new Uint8Array(one.length + two.length);
    result.set(one, 0);
    result.set(two, one.length);
    return result;
}
const OUR_MAJOR_VERSION = 0, OUR_MINOR_VERSION = 10, MAX_SUPPORTED_MAJOR_VERSION = OUR_MAJOR_VERSION, CHI_MAGIC = "CHIBIOEK", CHUNK_TAG_HEAD = "HEAD", CHUNK_TAG_LAYER = "LAYR", CHUNK_TAG_GROUP = "GRUP", CHUNK_TAG_END = "ZEND";
function CPChibiFileHeader(stream) {
    this.version = stream.readU32BE();
    this.width = stream.readU32BE();
    this.height = stream.readU32BE();
    this.layersNb = stream.readU32BE();
}
CPChibiFileHeader.FIXED_HEADER_LENGTH = 16;
function ChibiChunkHeader(stream) {
    let chunkType = new Array(4);
    for(let i = 0; i < chunkType.length; i++)chunkType[i] = String.fromCharCode(stream.readByte());
    this.chunkType = chunkType.join("");
    this.chunkSize = stream.readU32BE();
    if (stream.eof) throw "Truncated chunk";
}
ChibiChunkHeader.HEADER_LENGTH = 8;
const LAYER_FLAG_VISIBLE = 1, LAYER_FLAG_CLIP = 2, LAYER_FLAG_HAS_MASK = 4, LAYER_FLAG_MASK_LINKED = 8, LAYER_FLAG_MASK_VISIBLE = 16, LAYER_FLAG_EXPANDED = 32, LAYER_FLAG_ALPHA_LOCKED = 64, // Set if the LM_MULTIPLY2 blend mode should be used instead of the LM_MULTIPLY noted in the layer's blend mode
LAYER_FLAG_MULTIPLY2 = 128, LAYER_DECODE_STATE_FIXED_HEADER = 0, LAYER_DECODE_STATE_VARIABLE_HEADER = 1, LAYER_DECODE_STATE_IMAGE_DATA = 3, LAYER_DECODE_STATE_MASK_DATA = 4, LAYER_DECODE_STATE_SKIP_TRAILING = 5, LAYER_DECODE_STATE_COMPLETE = 6;
class ChibiLayerDecoder {
    /**
     * @param {ChibiChunkHeader} chunkHeader - The header for the layer chunk to decode
     * @param {number} width - The width of the document
     * @param {number} height - The height of the document
     */ constructor(chunkHeader, width, height){
        this.chunkHeader = chunkHeader;
        this.width = width;
        this.height = height;
        this.state = LAYER_DECODE_STATE_FIXED_HEADER;
        this.payloadOffset = 0;
        this.skipBytes = 0;
        this.nameLength = 0;
        this.done = false;
        this.colorDecoder = null;
        this.maskDecoder = null;
    }
    readFixedHeader(stream) {
        this.payloadOffset = stream.readU32BE();
        this.blendMode = stream.readU32BE();
        this.alpha = stream.readU32BE();
        let layerFlags = stream.readU32BE();
        this.visible = (layerFlags & LAYER_FLAG_VISIBLE) != 0;
        this.clip = (layerFlags & LAYER_FLAG_CLIP) != 0;
        this.hasMask = (layerFlags & LAYER_FLAG_HAS_MASK) != 0;
        this.maskLinked = (layerFlags & LAYER_FLAG_MASK_LINKED) != 0;
        this.maskVisible = (layerFlags & LAYER_FLAG_MASK_VISIBLE) != 0;
        this.expanded = (layerFlags & LAYER_FLAG_EXPANDED) != 0;
        this.lockAlpha = (layerFlags & LAYER_FLAG_ALPHA_LOCKED) != 0;
        if (this.blendMode === (0, _cpblendJsDefault.default).LM_MULTIPLY && (layerFlags & LAYER_FLAG_MULTIPLY2) !== 0) this.blendMode = (0, _cpblendJsDefault.default).LM_MULTIPLY2;
        this.nameLength = stream.readU32BE();
    }
    getFixedHeaderLen() {
        return 20;
    }
    getVariableHeaderLen() {
        return this.nameLength;
    }
    readVariableSizeHeader(stream) {
        this.name = stream.readString(this.nameLength);
    }
    /**
     * Decode some layer data from the beginning of the given block. Returns any non-layer data
     * that was left over from that block, or null if the block was read completely.
     *
     * Keep calling with more data until the .done property is set to true.
     *
     * @param {Uint8Array} block
     * @returns {?Uint8Array}
     */ decode(block) {
        let stream;
        // Dummy loop so we can re-enter the switch statement with "continue"
        while(true){
            if (this.skipBytes > 0) {
                if (this.skipBytes >= block.length) {
                    this.skipBytes -= block.length;
                    return null;
                } else {
                    block = block.subarray(this.skipBytes);
                    this.skipBytes = 0;
                }
            }
            switch(this.state){
                case LAYER_DECODE_STATE_FIXED_HEADER:
                    // Wait for first part of header to arrive
                    if (block.length < this.getFixedHeaderLen()) break;
                    stream = new (0, _arrayDataStreamJsDefault.default)(block);
                    this.readFixedHeader(stream);
                    block = block.subarray(stream.pos);
                    this.state = LAYER_DECODE_STATE_VARIABLE_HEADER;
                    continue;
                case LAYER_DECODE_STATE_VARIABLE_HEADER:
                    // Wait for variable part of header to arrive
                    if (block.length < this.getVariableHeaderLen()) break;
                    stream = new (0, _arrayDataStreamJsDefault.default)(block);
                    this.readVariableSizeHeader(stream);
                    this.layer = this.createLayer();
                    if (this.hasMask) {
                        this.layer.setMask(new (0, _cpgreyBmpJsDefault.default)(this.width, this.height, 8));
                        this.maskDecoder = new CPMaskDecoder(this.layer.mask);
                    }
                    if (this.layer instanceof (0, _cpimageLayerJsDefault.default)) this.colorDecoder = new CPColorPixelsDecoder(this.layer.image);
                    this.skipBytes = this.payloadOffset - this.getFixedHeaderLen();
                    if (this.colorDecoder) this.state = LAYER_DECODE_STATE_IMAGE_DATA;
                    else if (this.maskDecoder) this.state = LAYER_DECODE_STATE_MASK_DATA;
                    else this.state = LAYER_DECODE_STATE_SKIP_TRAILING;
                    continue;
                case LAYER_DECODE_STATE_IMAGE_DATA:
                    block = this.colorDecoder.decode(block);
                    if (this.colorDecoder.done) {
                        if (this.maskDecoder) this.state = LAYER_DECODE_STATE_MASK_DATA;
                        else this.state = LAYER_DECODE_STATE_SKIP_TRAILING;
                        continue;
                    }
                    break;
                case LAYER_DECODE_STATE_MASK_DATA:
                    block = this.maskDecoder.decode(block);
                    if (this.maskDecoder.done) {
                        this.state = LAYER_DECODE_STATE_SKIP_TRAILING;
                        continue;
                    }
                    break;
                case LAYER_DECODE_STATE_SKIP_TRAILING:
                    let bytesRead = this.payloadOffset;
                    if (this.colorDecoder) bytesRead += this.colorDecoder.bytesTotal;
                    if (this.maskDecoder) bytesRead += this.maskDecoder.bytesTotal;
                    this.state = LAYER_DECODE_STATE_COMPLETE;
                    this.skipBytes = this.chunkHeader.chunkSize - bytesRead;
                    continue;
                case LAYER_DECODE_STATE_COMPLETE:
                    this.done = true;
            }
            break;
        }
        return block;
    }
}
class ChibiImageLayerDecoder extends ChibiLayerDecoder {
    /**
     * Create a layer using the properties previously read into this decoder.
     *
     * @returns {CPImageLayer}
     */ createLayer() {
        let layer = new (0, _cpimageLayerJsDefault.default)(this.width, this.height, this.name);
        layer.setBlendMode(this.blendMode);
        layer.setAlpha(this.alpha);
        layer.setVisible(this.visible);
        layer.setClip(this.clip);
        layer.setMaskLinked(this.maskLinked);
        layer.setMaskVisible(this.maskVisible);
        layer.setLockAlpha(this.lockAlpha);
        return layer;
    }
}
class ChibiLayerGroupDecoder extends ChibiLayerDecoder {
    constructor(chunkHeader, width, height){
        super(chunkHeader, width, height);
        this.childLayers = 0;
    }
    readFixedHeader(stream) {
        super.readFixedHeader.call(this, stream);
        this.childLayers = stream.readU32BE();
    }
    getFixedHeaderLen() {
        return super.getFixedHeaderLen.call(this) + 4;
    }
    /**
     * Create a group using the properties previously read into this decoder.
     *
     * @returns {CPLayerGroup}
     */ createLayer() {
        let group = new (0, _cplayerGroupJsDefault.default)(this.name, this.blendMode);
        group.setAlpha(this.alpha);
        group.setVisible(this.visible);
        group.setExpanded(this.expanded);
        group.setMaskLinked(this.maskLinked);
        group.setMaskVisible(this.maskVisible);
        return group;
    }
}
/**
 * Write the RGBA pixels of the given bitmap to the stream in ARGB order to match the Chibi specs.
 *
 * @param {ArrayDataStream} stream
 * @param {CPColorBmp} bitmap
 */ function writeColorBitmapToStream(stream, bitmap) {
    let pos = stream.pos, buffer = stream.data, bitmapData = bitmap.data;
    for(let i = 0; i < bitmapData.length; i += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL){
        buffer[pos++] = bitmapData[i + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET];
        buffer[pos++] = bitmapData[i + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET];
        buffer[pos++] = bitmapData[i + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET];
        buffer[pos++] = bitmapData[i + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET];
    }
    stream.pos = pos;
}
/**
 * Write the 8-bit greyscale pixels of the given bitmap to the stream.
 *
 * @param {ArrayDataStream} stream
 * @param {CPGreyBmp} bitmap
 */ function writeMaskToStream(stream, bitmap) {
    stream.data.set(bitmap.data, stream.pos);
    stream.pos += bitmap.data.length;
}
class CPColorPixelsDecoder {
    /**
     * @param {CPColorBmp} destImage - Image to decode into.
     */ constructor(destImage){
        this.bytesRead = 0;
        this.bytesTotal = destImage.width * destImage.height * (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL;
        this.output = destImage.data;
        this.done = false;
    }
    /**
     * Decode A,R,G,B pixels from the given buffer into the R,G,B,A destination image.
     *
     * Returns the buffer with the read bytes removed from the front, or null if the buffer was read in its entirety.
     *
     * @param {Uint8Array} buffer
     */ decode(buffer) {
        if (buffer == null) return null;
        let subpixel = this.bytesRead % (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL, dstPixelStartOffset = this.bytesRead - subpixel, bufferPos = 0, // Map from source channel order to CPLayer's dest order
        channelMap = [
            (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET,
            (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET,
            (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET,
            (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET
        ];
        // The first pixel might be a partial one, since we might be continuing a pixel split over buffers
        for(; subpixel < (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL && bufferPos < buffer.length; subpixel++){
            this.output[dstPixelStartOffset + channelMap[subpixel]] = buffer[bufferPos];
            bufferPos++;
        }
        this.bytesRead += bufferPos;
        // How many more pixels are we to read in this buffer?
        let bytesRemain = Math.min(buffer.length - bufferPos, this.bytesTotal - this.bytesRead) | 0, fullPixelsRemain = bytesRemain / (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL | 0, subpixelsRemain = bytesRemain % (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL;
        for(let i = 0; i < fullPixelsRemain; i++){
            this.output[this.bytesRead + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET] = buffer[bufferPos];
            this.output[this.bytesRead + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET] = buffer[bufferPos + 1];
            this.output[this.bytesRead + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET] = buffer[bufferPos + 2];
            this.output[this.bytesRead + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET] = buffer[bufferPos + 3];
            this.bytesRead += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL;
            bufferPos += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL;
        }
        // Read a fractional pixel at the end of the buffer
        dstPixelStartOffset = this.bytesRead;
        for(subpixel = 0; subpixel < subpixelsRemain; subpixel++){
            this.output[dstPixelStartOffset + channelMap[subpixel]] = buffer[bufferPos];
            bufferPos++;
        }
        this.bytesRead += subpixelsRemain;
        if (this.bytesRead >= this.bytesTotal) this.done = true;
        if (bufferPos < buffer.length) // Layer was completed before the end of the buffer, there is buffer left over for someone else to use
        return buffer.subarray(bufferPos);
        else // Buffer exhausted
        return null;
    }
}
class CPMaskDecoder {
    /**
     *
     * @param {CPGreyBmp} mask - The destination to decode pixels into, must already be the correct size.
     */ constructor(mask){
        this.bytesRead = 0;
        this.bytesTotal = mask.width * mask.height;
        this.output = mask.data;
        this.done = false;
    }
    /**
     * Read 8-bit greyscale pixels from the given buffer into destination pixel array.
     *
     * Returns the buffer with the read bytes removed from the front, or null if the buffer was read in its entirety.
     *
     * @param {Uint8Array} buffer
     */ decode(buffer) {
        if (buffer == null) return null;
        let // How many more pixels are we to read from this buffer?
        bytesRemain = Math.min(buffer.length, this.bytesTotal - this.bytesRead) | 0, dstIndex = this.bytesRead, srcIndex;
        for(srcIndex = 0; srcIndex < bytesRemain; srcIndex++, dstIndex++)this.output[dstIndex] = buffer[srcIndex];
        this.bytesRead = dstIndex;
        if (this.bytesRead >= this.bytesTotal) this.done = true;
        if (srcIndex < buffer.length) // Layer was completed before the end of the buffer, there is buffer left over for someone else to use
        return buffer.subarray(srcIndex);
        else // Buffer exhausted
        return null;
    }
}
/**
 * Make a 32-bit Chibi file-version value for storing in the file header.
 *
 * @param {number} major
 * @param {number} minor
 * @returns {number}
 */ function makeChibiVersion(major, minor) {
    return major << 16 | minor;
}
function decomposeChibiVersion(version) {
    return {
        major: version >> 16 & 0xFFFF,
        minor: version & 0xFFFF
    };
}
function chibiVersionToString(version) {
    let decomposed = decomposeChibiVersion(version);
    if (decomposed.major === 0 && decomposed.minor === 0) return "ChibiPaint v0.0";
    else return "ChickenPaint v" + decomposed.major + "." + decomposed.minor;
}
/**
 * Decides which Chibi file version will be required to support the features used by the given artwork, and returns
 * the corresponding version number header.
 *
 * @param {CPArtwork} artwork
 * @returns {number}
 */ function minimumVersionForArtwork(artwork) {
    for (let layer of artwork.getLayersRoot().getLinearizedLayerList(false)){
        if (layer instanceof (0, _cplayerGroupJsDefault.default) || layer.mask || layer.clip || layer.blendMode > (0, _cpblendJsDefault.default).LM_LAST_CHIBIPAINT || layer.blendMode === (0, _cpblendJsDefault.default).LM_MULTIPLY) /*
             * We'll claim to be compatible with ChibiPaint (by not incrementing the major version number), since
             * ChibiPaint will at least be able to open the file, even though it'll lose information in doing so.
             */ return makeChibiVersion(OUR_MAJOR_VERSION, OUR_MINOR_VERSION);
    }
    return makeChibiVersion(0, 0); // The version used by the original ChibiPaint
}
function writeChunkHeader(stream, tag, chunkSize) {
    stream.writeString(tag);
    stream.writeU32BE(chunkSize);
}
/**
 * Allocate a fixed-size buffer to represent the chunk with the given tag and size, and return a stream which
 * points to the body of the chunk (with the chunk header already written).
 *
 * @param {string} chunkTag
 * @param {number} chunkBodySize
 * @returns {ArrayDataStream}
 */ function allocateChunkStream(chunkTag, chunkBodySize) {
    let buffer = new Uint8Array(ChibiChunkHeader.HEADER_LENGTH + chunkBodySize), stream = new (0, _arrayDataStreamJsDefault.default)(buffer);
    writeChunkHeader(stream, chunkTag, chunkBodySize);
    return stream;
}
/**
 * @param {CPArtwork} artwork
 * @param {number} version
 * @param {number} numLayers
 *
 * @returns Uint8Array
 */ function serializeFileHeaderChunk(artwork, version, numLayers) {
    let stream = allocateChunkStream(CHUNK_TAG_HEAD, CPChibiFileHeader.FIXED_HEADER_LENGTH);
    stream.writeU32BE(version);
    stream.writeU32BE(artwork.width);
    stream.writeU32BE(artwork.height);
    stream.writeU32BE(numLayers);
    return stream.getAsDataArray();
}
/**
 * @returns {Uint8Array}
 */ function serializeEndChunk() {
    return allocateChunkStream(CHUNK_TAG_END, 0).getAsDataArray();
}
/**
 * Serialize an layer's header and image data into a byte array buffer, and return it.
 *
 * @param {CPImageLayer|CPLayerGroup} layer
 */ function serializeLayerChunk(layer) {
    const isImageLayer = layer instanceof (0, _cpimageLayerJsDefault.default), FIXED_HEADER_LENGTH = 4 * (isImageLayer ? 5 : 6), VARIABLE_HEADER_LENGTH = layer.name.length, COMBINED_HEADER_LENGTH = FIXED_HEADER_LENGTH + VARIABLE_HEADER_LENGTH, PAYLOAD_LENGTH = (isImageLayer ? layer.image.data.length : 0) + (layer.mask ? layer.mask.data.length : 0), stream = allocateChunkStream(isImageLayer ? CHUNK_TAG_LAYER : CHUNK_TAG_GROUP, FIXED_HEADER_LENGTH + VARIABLE_HEADER_LENGTH + PAYLOAD_LENGTH);
    let layerFlags = 0, blendMode;
    if (layer.visible) layerFlags |= LAYER_FLAG_VISIBLE;
    if (isImageLayer && layer.clip) layerFlags |= LAYER_FLAG_CLIP;
    if (layer.mask) layerFlags |= LAYER_FLAG_HAS_MASK;
    if (layer.maskLinked) layerFlags |= LAYER_FLAG_MASK_LINKED;
    if (layer.maskVisible) layerFlags |= LAYER_FLAG_MASK_VISIBLE;
    if (layer.lockAlpha) layerFlags |= LAYER_FLAG_ALPHA_LOCKED;
    if (!isImageLayer && layer.expanded) layerFlags |= LAYER_FLAG_EXPANDED;
    if (layer.blendMode === (0, _cpblendJsDefault.default).LM_MULTIPLY2) {
        /* So that ChibiPaint can still open files that use our new blending routine, re-label it as the original
	     * multiply mode, but add a flag so that we know it's supposed to use the new version.
	     */ blendMode = (0, _cpblendJsDefault.default).LM_MULTIPLY;
        layerFlags |= LAYER_FLAG_MULTIPLY2;
    } else blendMode = layer.blendMode;
    // Fixed length header portion
    stream.writeU32BE(COMBINED_HEADER_LENGTH); // Offset to layer data from start of header
    stream.writeU32BE(blendMode);
    stream.writeU32BE(layer.alpha);
    stream.writeU32BE(layerFlags);
    stream.writeU32BE(layer.name.length);
    if (!isImageLayer) stream.writeU32BE(layer.layers.length);
    // Variable length header portion
    stream.writeString(layer.name);
    // Payload:
    if (isImageLayer) writeColorBitmapToStream(stream, layer.image);
    if (layer.mask) writeMaskToStream(stream, layer.mask);
    return stream.getAsDataArray();
}
/**
 *
 * @param {Uint8Array} array
 * @returns {boolean}
 */ function hasChibiMagicMarker(array) {
    for(let i = 0; i < CHI_MAGIC.length; i++){
        if (array[i] != CHI_MAGIC.charCodeAt(i)) return false;
    }
    return true;
}
function save(artwork, options) {
    options = options || {};
    return Promise.resolve().then(()=>{
        const deflator = new (0, _pakoDefault.default).Deflate({
            level: 7
        }), /**
             * The fragments that make up the completed .chi file:
             * @type {Uint8Array[]}
             */ blobParts = [], magic = new Uint8Array(CHI_MAGIC.length), layers = artwork.getLayersRoot().getLinearizedLayerList(false), version = options.forceOldVersion ? makeChibiVersion(0, 0) : minimumVersionForArtwork(artwork), versionString = chibiVersionToString(version);
        let layerWritePromise = Promise.resolve();
        deflator.onData = function(chunk) {
            blobParts.push(chunk);
        };
        // The magic file signature is not ZLIB compressed:
        for(let i = 0; i < CHI_MAGIC.length; i++)magic[i] = CHI_MAGIC.charCodeAt(i);
        blobParts.push(magic);
        // The rest gets compressed
        deflator.push(serializeFileHeaderChunk(artwork, version, layers.length), false);
        for (let layer of layers)layerWritePromise = layerWritePromise.then(()=>new Promise(function(resolve) {
                deflator.push(serializeLayerChunk(layer), false);
                // Insert a setTimeout between each serialized layer, so we can maintain browser responsiveness
                setTimeout(resolve, 10);
            }));
        return layerWritePromise.then(()=>new Promise((resolve, reject)=>{
                deflator.onEnd = function(status) {
                    if (status === 0) {
                        if (typeof Blob !== "undefined") // In the browser
                        resolve({
                            bytes: new Blob(blobParts, {
                                type: "application/octet-stream"
                            }),
                            version: versionString
                        });
                        else {
                            // In Node.js
                            let totalSize = blobParts.map((part)=>part.byteLength).reduce((total, size)=>{
                                return total + size;
                            }, 0), buffer = new Uint8Array(totalSize), offset = 0;
                            for (let part of blobParts){
                                buffer.set(part, offset);
                                offset += part.byteLength;
                            }
                            resolve({
                                bytes: buffer,
                                version: versionString
                            });
                        }
                    } else reject(status);
                };
                deflator.push(serializeEndChunk(), true);
            }));
    });
}
function load(source, options) {
    options = options || {};
    const STATE_WAIT_FOR_CHUNK = 0, STATE_DECODE_FILE_HEADER = 1, STATE_DECODE_LAYER = 2, STATE_DECODE_GROUP = 3, STATE_SUCCESS = 45, STATE_FATAL = 5;
    let inflator = new (0, _pakoDefault.default).Inflate({}), state = STATE_WAIT_FOR_CHUNK, /**
		 * Destination artwork
		 *
		 * @type {CPArtwork}
		 */ artwork = null, /**
		 * Group we're currently loading layers into
		 *
		 * @type {CPLayerGroup}
		 */ destGroup = null, /**
		 * Decoder we're currently using to read a layer.
		 *
		 * @type {ChibiLayerDecoder}
		 */ layerDecoder, /**
		 * Number of bytes we should skip in the stream before resuming decoding.
		 *
		 * @type {number}
		 */ skipCount = 0, /**
		 * The overall file descriptor
		 *
		 * @type {CPChibiFileHeader}
		 */ fileHeader = null, /**
		 *
		 * @type {ChibiChunkHeader}
		 */ curChunkHeader = null, /**
		 * Here we store data that we weren't able to process in previous iterations due to not enough
		 * data being available at once.
		 *
		 * @type {Uint8Array}
		 */ accumulator = null;
    /**
	 * Called by the Pako Zlib decompressor each time a block of data is ready for processing.
	 *
	 * @param {Uint8Array} block
	 */ function processBlock(block) {
        let stream;
        accumulator = concatBuffers(accumulator, block);
        block = null;
        // Add a loop here so we can re-enter the switch with 'continue'
        while(true){
            if (accumulator) {
                if (skipCount < accumulator.length) {
                    accumulator = accumulator.subarray(skipCount);
                    skipCount = 0;
                } else {
                    skipCount -= accumulator.length;
                    accumulator = null;
                    break;
                }
            } else break;
            // Decode some data from the accumulator
            switch(state){
                case STATE_WAIT_FOR_CHUNK:
                    // Wait for whole chunk header to become available
                    if (accumulator.length < ChibiChunkHeader.HEADER_LENGTH) break;
                    // Decode chunk header
                    stream = new (0, _arrayDataStreamJsDefault.default)(accumulator);
                    curChunkHeader = new ChibiChunkHeader(stream);
                    // Remove the chunk header from the start of the accumulator
                    accumulator = accumulator.subarray(stream.pos);
                    if (fileHeader) {
                        if (curChunkHeader.chunkType == CHUNK_TAG_END) state = STATE_SUCCESS;
                        else if (curChunkHeader.chunkType == CHUNK_TAG_LAYER) {
                            state = STATE_DECODE_LAYER;
                            layerDecoder = new ChibiImageLayerDecoder(curChunkHeader, fileHeader.width, fileHeader.height);
                            continue;
                        } else if (curChunkHeader.chunkType == CHUNK_TAG_GROUP) {
                            state = STATE_DECODE_GROUP;
                            layerDecoder = new ChibiLayerGroupDecoder(curChunkHeader, fileHeader.width, fileHeader.height);
                            continue;
                        } else {
                            console.log("Unknown chunk type '" + curChunkHeader.chunkType + "', attempting to skip...");
                            skipCount = curChunkHeader.chunkSize;
                            continue;
                        }
                    } else if (curChunkHeader.chunkType == CHUNK_TAG_HEAD) {
                        state = STATE_DECODE_FILE_HEADER;
                        continue;
                    } else // File didn't start with image header chunk
                    state = STATE_FATAL;
                    break;
                case STATE_DECODE_FILE_HEADER:
                    // Wait for whole chunk to be available
                    if (accumulator.length < curChunkHeader.chunkSize) break;
                    stream = new (0, _arrayDataStreamJsDefault.default)(accumulator);
                    fileHeader = new CPChibiFileHeader(stream);
                    if (decomposeChibiVersion(fileHeader.version).major > MAX_SUPPORTED_MAJOR_VERSION) {
                        state = STATE_FATAL; // the file version is higher than what we can deal with, bail out
                        break;
                    }
                    artwork = new (0, _cpartworkJsDefault.default)(fileHeader.width, fileHeader.height);
                    destGroup = artwork.getLayersRoot();
                    // Skip the header chunk along with any trailing bytes
                    skipCount = curChunkHeader.chunkSize;
                    state = STATE_WAIT_FOR_CHUNK;
                    continue;
                case STATE_DECODE_LAYER:
                    accumulator = layerDecoder.decode(accumulator);
                    if (layerDecoder.done) {
                        artwork.addLayerObject(destGroup, layerDecoder.layer);
                        state = STATE_WAIT_FOR_CHUNK;
                        continue;
                    }
                    break;
                case STATE_DECODE_GROUP:
                    accumulator = layerDecoder.decode(accumulator);
                    if (layerDecoder.done) {
                        artwork.addLayerGroupObject(destGroup, layerDecoder.layer, layerDecoder.childLayers);
                        state = STATE_WAIT_FOR_CHUNK;
                        continue;
                    }
                    break;
            }
            break;
        }
    }
    return new Promise(function(resolve) {
        if (source instanceof ArrayBuffer) resolve(source);
        else {
            // Assume source is a Blob
            let reader = new FileReader();
            reader.onload = function() {
                resolve(this.result);
            };
            reader.readAsArrayBuffer(source);
        }
    }).then((arrayBuffer)=>new Promise(function(resolve, reject) {
            let byteArray = new Uint8Array(arrayBuffer);
            if (!hasChibiMagicMarker(byteArray)) {
                reject("This doesn't appear to be a ChibiPaint layers file, is it damaged?");
                return;
            }
            // Remove the magic header
            byteArray = byteArray.subarray(CHI_MAGIC.length);
            inflator.onData = processBlock;
            inflator.onEnd = function(status) {
                if (status === 0 && state == STATE_SUCCESS) {
                    if (options.upgradeMultiplyLayers !== false && fileHeader.version < makeChibiVersion(OUR_MAJOR_VERSION, OUR_MINOR_VERSION)) artwork.upgradeMultiplyLayers(options.upgradeMultiplyLayers);
                    artwork.selectTopmostVisibleLayer();
                    resolve(artwork);
                } else reject("Fatal error decoding ChibiFile: " + status);
            };
            // Begin decompression/decoding
            inflator.push(byteArray, true);
        }));
}

},{"./CPArtwork.js":"3AbfY","./CPImageLayer.js":"93gOf","./CPColorBmp.js":"5rykl","../util/ArrayDataStream.js":"6f1Ke","./CPLayerGroup.js":"k5mD3","./CPGreyBmp.js":"fGKWG","./CPBlend.js":"k5HfA","pako":"bWbUK","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6f1Ke":[function(require,module,exports,__globalThis) {
/**
 * A tool for presenting a Uint8Array as a stream for reading and writing some simple data types.
 * 
 * By Nicholas Sherlock <n.sherlock@gmail.com> 2016, released under the WTFPL license.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ArrayDataStream);
var EOF = -1;
function signExtend16Bit(word) {
    //If sign bit is set, fill the top bits with 1s to sign-extend
    return word & 0x8000 ? word | 0xFFFF0000 : word;
}
function signExtend8Bit(byte) {
    //If sign bit is set, fill the top bits with 1s to sign-extend
    return byte & 0x80 ? byte | 0xFFFFFF00 : byte;
}
function ArrayDataStream(data, start, end) {
    this.data = data;
    this.eof = false;
    this.start = start === undefined ? 0 : start;
    this.end = end === undefined ? data.length : end;
    this.pos = this.start;
}
/**
 * Read a single byte from the stream and turn it into a JavaScript string (assuming ASCII).
 * 
 * @returns {String|number} String containing one character, or EOF if the end of file was reached (eof flag
 * is set).
 */ ArrayDataStream.prototype.readChar = function() {
    if (this.pos < this.end) return String.fromCharCode(this.data[this.pos++]);
    this.eof = true;
    return EOF;
};
/**
 * Read one unsigned byte from the stream
 * 
 * @returns {number} Unsigned byte, or EOF if the end of file was reached (eof flag is set).
 */ ArrayDataStream.prototype.readByte = function() {
    if (this.pos < this.end) return this.data[this.pos++];
    this.eof = true;
    return EOF;
};
//Synonym:
ArrayDataStream.prototype.readU8 = ArrayDataStream.prototype.readByte;
ArrayDataStream.prototype.readS8 = function() {
    return signExtend8Bit(this.readByte());
};
ArrayDataStream.prototype.unreadChar = function(c) {
    this.pos--;
};
ArrayDataStream.prototype.peekChar = function() {
    if (this.pos < this.end) return String.fromCharCode(this.data[this.pos]);
    this.eof = true;
    return EOF;
};
ArrayDataStream.prototype.readString = function(length) {
    var chars = new Array(length), i;
    for(i = 0; i < length; i++)chars[i] = this.readChar();
    return chars.join("");
};
ArrayDataStream.prototype.readS16 = function() {
    var b1 = this.readByte(), b2 = this.readByte();
    return signExtend16Bit(b1 << 8 | b2);
};
ArrayDataStream.prototype.readU16BE = function() {
    var b1 = this.readByte(), b2 = this.readByte();
    return b1 << 8 | b2;
};
ArrayDataStream.prototype.readU16LE = function() {
    var b1 = this.readByte(), b2 = this.readByte();
    return b2 << 8 | b1;
};
ArrayDataStream.prototype.readU32BE = function() {
    var b1 = this.readByte(), b2 = this.readByte(), b3 = this.readByte(), b4 = this.readByte();
    return (b1 << 24 | b2 << 16 | b3 << 8 | b4) >>> 0;
};
ArrayDataStream.prototype.readU32LE = function() {
    var b1 = this.readByte(), b2 = this.readByte(), b3 = this.readByte(), b4 = this.readByte();
    return (b4 << 24 | b3 << 16 | b2 << 8 | b1) >>> 0;
};
ArrayDataStream.prototype.readBytes = function(count) {
    var result = this.data.subarray(this.pos, this.pos + count);
    this.pos += count;
    if (this.pos > this.end) this.eof = true;
    return result;
};
ArrayDataStream.prototype.skip = function(numBytes) {
    this.pos += numBytes;
    if (this.pos > this.end) this.eof = true;
};
ArrayDataStream.prototype.seek = function(offset) {
    this.pos = offset;
};
ArrayDataStream.prototype.writeBytes = function(arr) {
    for(var i = 0; i < arr.length; i++)this.data[this.pos++] = arr[i];
};
ArrayDataStream.prototype.writeByte = function(b) {
    this.data[this.pos++] = b;
};
//Synonym:
ArrayDataStream.prototype.writeU8 = ArrayDataStream.prototype.writeByte;
ArrayDataStream.prototype.writeU16LE = function(u) {
    this.data[this.pos++] = u;
    this.data[this.pos++] = u >> 8;
};
ArrayDataStream.prototype.writeU16BE = function(u) {
    this.data[this.pos++] = u >> 8;
    this.data[this.pos++] = u;
};
ArrayDataStream.prototype.writeU32BE = function(u) {
    this.data[this.pos++] = u >> 24;
    this.data[this.pos++] = u >> 16;
    this.data[this.pos++] = u >> 8;
    this.data[this.pos++] = u;
};
ArrayDataStream.prototype.writeU32LE = function(u) {
    this.data[this.pos++] = u;
    this.data[this.pos++] = u >> 8;
    this.data[this.pos++] = u >> 16;
    this.data[this.pos++] = u >> 24;
};
ArrayDataStream.prototype.writeDoubleBE = function(d) {
    var bytes = new Uint8Array(new Float64Array([
        d
    ]).buffer);
    for(var i = bytes.length - 1; i >= 0; i--)this.writeByte(bytes[i]);
};
ArrayDataStream.prototype.writeFloatBE = function(d) {
    var bytes = new Uint8Array(new Float32Array([
        d
    ]).buffer);
    for(var i = bytes.length - 1; i >= 0; i--)this.writeByte(bytes[i]);
};
/**
 * Write an ASCII string to the stream
 */ ArrayDataStream.prototype.writeString = function(s) {
    for(var i = 0; i < s.length; i++)this.data[this.pos++] = s.charCodeAt(i);
};
/**
 * Write the given unsigned 32-bit integer to the stream in big-endian order using the given byte width.
 * No error checking is performed to ensure that the supplied width is correct for the integer.
 * 
 * Omit the width parameter to have it determined automatically for you.
 * 
 * @param u Unsigned integer to be written
 * @param width Number of bytes to write to the stream
 */ ArrayDataStream.prototype.writeUnsignedIntBE = function(u, width) {
    if (width === undefined) width = this.measureUnsignedInt(u);
    // Each case falls through:
    //noinspection FallThroughInSwitchStatementJS
    switch(width){
        case 5:
            this.writeU8(Math.floor(u / 4294967296)); // Need to use division to access >32 bits of floating point var
        case 4:
            this.writeU8(u >> 24);
        case 3:
            this.writeU8(u >> 16);
        case 2:
            this.writeU8(u >> 8);
        case 1:
            this.writeU8(u);
            break;
        default:
            throw "Bad UINT size " + width;
    }
};
/**
 * Return the number of bytes needed to hold the non-zero bits of the given unsigned integer.
 */ ArrayDataStream.prototype.measureUnsignedInt = function(val) {
    // Force to 32-bit unsigned integer
    if (val < 256) return 1;
    else if (val < 65536) return 2;
    else if (val < 16777216) return 3;
    else if (val < 4294967296) return 4;
    else return 5;
};
/**
 * Return a view on the portion of the buffer from the beginning to the current seek position as a Uint8Array.
 */ ArrayDataStream.prototype.getAsDataArray = function() {
    if (this.pos < this.data.byteLength) return this.data.subarray(0, this.pos);
    else if (this.pos == this.data.byteLength) return this.data;
    else throw "ArrayDataStream's pos lies beyond end of buffer";
};
ArrayDataStream.prototype.EOF = EOF;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bWbUK":[function(require,module,exports,__globalThis) {
// Top level file is just a mixin of submodules & constants
'use strict';
var assign = require("348045eb9f6197c9").assign;
var deflate = require("56b639b6aa076763");
var inflate = require("fe93ff52db6ebaa6");
var constants = require("e2707a1304e9de10");
var pako = {};
assign(pako, deflate, inflate, constants);
module.exports = pako;

},{"348045eb9f6197c9":"9lGgI","56b639b6aa076763":"dGKT1","fe93ff52db6ebaa6":"eF7nj","e2707a1304e9de10":"c09N4"}],"9lGgI":[function(require,module,exports,__globalThis) {
'use strict';
var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';
function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
exports.assign = function(obj /*from1, from2, from3, ...*/ ) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while(sources.length){
        var source = sources.shift();
        if (!source) continue;
        if (typeof source !== 'object') throw new TypeError(source + 'must be non-object');
        for(var p in source)if (_has(source, p)) obj[p] = source[p];
    }
    return obj;
};
// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) return buf;
    if (buf.subarray) return buf.subarray(0, size);
    buf.length = size;
    return buf;
};
var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
            return;
        }
        // Fallback to ordinary array
        for(var i = 0; i < len; i++)dest[dest_offs + i] = src[src_offs + i];
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        // calculate data length
        len = 0;
        for(i = 0, l = chunks.length; i < l; i++)len += chunks[i].length;
        // join chunks
        result = new Uint8Array(len);
        pos = 0;
        for(i = 0, l = chunks.length; i < l; i++){
            chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length;
        }
        return result;
    }
};
var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
        for(var i = 0; i < len; i++)dest[dest_offs + i] = src[src_offs + i];
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
    }
};
// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function(on) {
    if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
    } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
    }
};
exports.setTyped(TYPED_OK);

},{}],"dGKT1":[function(require,module,exports,__globalThis) {
'use strict';
var zlib_deflate = require("b0ef42cbda6fe16c");
var utils = require("a402d15c852a9ca0");
var strings = require("24460910c8f8079d");
var msg = require("9bcdc2aa7c5a51aa");
var ZStream = require("fa305d4f7d21ccbf");
var toString = Object.prototype.toString;
/* Public constants ==========================================================*/ /* ===========================================================================*/ var Z_NO_FLUSH = 0;
var Z_FINISH = 4;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_SYNC_FLUSH = 2;
var Z_DEFAULT_COMPRESSION = -1;
var Z_DEFAULT_STRATEGY = 0;
var Z_DEFLATED = 8;
/* ===========================================================================*/ /**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/ /* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/ /**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/ /**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/ /**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/ /**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/ function Deflate(options) {
    if (!(this instanceof Deflate)) return new Deflate(options);
    this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ''
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) opt.windowBits = -opt.windowBits;
    else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) opt.windowBits += 16;
    this.err = 0; // error code, if happens (0 = Z_OK)
    this.msg = ''; // error message
    this.ended = false; // used to avoid multiple onEnd() calls
    this.chunks = []; // chunks of compressed data
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK) throw new Error(msg[status]);
    if (opt.header) zlib_deflate.deflateSetHeader(this.strm, opt.header);
    if (opt.dictionary) {
        var dict;
        // Convert data if needed
        if (typeof opt.dictionary === 'string') // If we need to compress text, change encoding to utf8.
        dict = strings.string2buf(opt.dictionary);
        else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') dict = new Uint8Array(opt.dictionary);
        else dict = opt.dictionary;
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) throw new Error(msg[status]);
        this._dict_set = true;
    }
}
/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/ Deflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) return false;
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    // Convert data if needed
    if (typeof data === 'string') // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
    else if (toString.call(data) === '[object ArrayBuffer]') strm.input = new Uint8Array(data);
    else strm.input = data;
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
        if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode); /* no bad return value */ 
        if (status !== Z_STREAM_END && status !== Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
            if (this.options.to === 'string') this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
            else this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
    }while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    // Finalize on the last chunk.
    if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
    }
    // callback interim results if Z_SYNC_FLUSH.
    if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
    }
    return true;
};
/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/ Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
};
/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/ Deflate.prototype.onEnd = function(status) {
    // On success - join
    if (status === Z_OK) {
        if (this.options.to === 'string') this.result = this.chunks.join('');
        else this.result = utils.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
};
/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/ function deflate(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    // That will never happens, if you don't cheat with options :)
    if (deflator.err) throw deflator.msg || msg[deflator.err];
    return deflator.result;
}
/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/ function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate(input, options);
}
/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/ function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate(input, options);
}
exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"b0ef42cbda6fe16c":"7WhmS","a402d15c852a9ca0":"9lGgI","24460910c8f8079d":"9m1XG","9bcdc2aa7c5a51aa":"3b6uW","fa305d4f7d21ccbf":"i3gjN"}],"7WhmS":[function(require,module,exports,__globalThis) {
'use strict';
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
var utils = require("6ecd050ab5cf9e92");
var trees = require("b17b4660c9a756a1");
var adler32 = require("8a0173ce93724f81");
var crc32 = require("9fe740ea87b93669");
var msg = require("86729d90d4373c72");
/* Public constants ==========================================================*/ /* ===========================================================================*/ /* Allowed flush values; see deflate() and inflate() below for details */ var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
//var Z_TREES         = 6;
/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */ var Z_OK = 0;
var Z_STREAM_END = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR = -5;
//var Z_VERSION_ERROR = -6;
/* compression levels */ //var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
/* Possible values of the data_type field (though see inflate()) */ //var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN = 2;
/* The deflate compression method */ var Z_DEFLATED = 8;
/*============================================================================*/ var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */ var MAX_WBITS = 15;
/* 32K LZ77 window */ var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */ var LITERALS = 256;
/* number of literal bytes 0..255 */ var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */ var D_CODES = 30;
/* number of distance codes */ var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */ var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */ var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */ var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 0x20;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1; /* block not completed, need more input or more output */ 
var BS_BLOCK_DONE = 2; /* block flush performed */ 
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */ 
var BS_FINISH_DONE = 4; /* finish done, accept no more input or output */ 
var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.
function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
}
function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
}
function zero(buf) {
    var len = buf.length;
    while(--len >= 0)buf[len] = 0;
}
/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */ function flush_pending(strm) {
    var s = strm.state;
    //_tr_flush_bits(s);
    var len = s.pending;
    if (len > strm.avail_out) len = strm.avail_out;
    if (len === 0) return;
    utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) s.pending_out = 0;
}
function flush_block_only(s, last) {
    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
}
function put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
}
/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */ function putShortMSB(s, b) {
    //  put_byte(s, (Byte)(b >> 8));
    //  put_byte(s, (Byte)(b & 0xff));
    s.pending_buf[s.pending++] = b >>> 8 & 0xff;
    s.pending_buf[s.pending++] = b & 0xff;
}
/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */ function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) len = size;
    if (len === 0) return 0;
    strm.avail_in -= len;
    // zmemcpy(buf, strm->next_in, len);
    utils.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) strm.adler = adler32(strm.adler, buf, len, start);
    else if (strm.state.wrap === 2) strm.adler = crc32(strm.adler, buf, len, start);
    strm.next_in += len;
    strm.total_in += len;
    return len;
}
/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */ function longest_match(s, cur_match) {
    var chain_length = s.max_chain_length; /* max hash chain length */ 
    var scan = s.strstart; /* current string */ 
    var match; /* matched string */ 
    var len; /* length of current match */ 
    var best_len = s.prev_length; /* best match length so far */ 
    var nice_match = s.nice_match; /* stop if match long enough */ 
    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/ ;
    var _win = s.window; // shortcut
    var wmask = s.w_mask;
    var prev = s.prev;
    /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */ var strend = s.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */ // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
    /* Do not waste too much time if we already have a good match: */ if (s.prev_length >= s.good_match) chain_length >>= 2;
    /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */ if (nice_match > s.lookahead) nice_match = s.lookahead;
    // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
    do {
        // Assert(cur_match < s->strstart, "no future");
        match = cur_match;
        /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */ if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) continue;
        /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */ scan += 2;
        match++;
        // Assert(*scan == *match, "match[2]?");
        /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */ do ;
        while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) break;
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
        }
    }while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) return best_len;
    return s.lookahead;
}
/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */ function fill_window(s) {
    var _w_size = s.w_size;
    var p, n, m, more, str;
    //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
    do {
        more = s.window_size - s.lookahead - s.strstart;
        // JS ints have 32 bit, block below not needed
        /* Deal with !@#$% 64K limit: */ //if (sizeof(int) <= 2) {
        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
        //        more = wsize;
        //
        //  } else if (more == (unsigned)(-1)) {
        //        /* Very unlikely, but possible on 16 bit machine if
        //         * strstart == 0 && lookahead == 1 (input done a byte at time)
        //         */
        //        more--;
        //    }
        //}
        /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */ if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            /* we now have strstart >= MAX_DIST */ s.block_start -= _w_size;
            /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */ n = s.hash_size;
            p = n;
            do {
                m = s.head[--p];
                s.head[p] = m >= _w_size ? m - _w_size : 0;
            }while (--n);
            n = _w_size;
            p = n;
            do {
                m = s.prev[--p];
                s.prev[p] = m >= _w_size ? m - _w_size : 0;
            /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */ }while (--n);
            more += _w_size;
        }
        if (s.strm.avail_in === 0) break;
        /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */ //Assert(more >= 2, "more < 2");
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        /* Initialize the hash value now that we have some input: */ if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
            //#if MIN_MATCH != 3
            //        Call update_hash() MIN_MATCH-3 more times
            //#endif
            while(s.insert){
                /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
                s.insert--;
                if (s.lookahead + s.insert < MIN_MATCH) break;
            }
        }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */ }while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
/* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */ //  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}
/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */ function deflate_stored(s, flush) {
    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */ var max_block_size = 0xffff;
    if (max_block_size > s.pending_buf_size - 5) max_block_size = s.pending_buf_size - 5;
    /* Copy as much as possible from input to output: */ for(;;){
        /* Fill the window as much as possible: */ if (s.lookahead <= 1) {
            //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
            //  s->block_start >= (long)s->w_size, "slide too late");
            //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
            //        s.block_start >= s.w_size)) {
            //        throw  new Error("slide too late");
            //      }
            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH) return BS_NEED_MORE;
            if (s.lookahead === 0) break;
        /* flush the current block */ }
        //Assert(s->block_start >= 0L, "block gone");
        //    if (s.block_start < 0) throw new Error("block gone");
        s.strstart += s.lookahead;
        s.lookahead = 0;
        /* Emit a stored block if pending_buf will be full: */ var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
            /* strstart == 0 is possible when wraparound on 16-bit machine */ s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);
            if (s.strm.avail_out === 0) return BS_NEED_MORE;
        /***/ }
        /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */ if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);
            if (s.strm.avail_out === 0) return BS_NEED_MORE;
        /***/ }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);
        if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
        /***/ return BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);
        if (s.strm.avail_out === 0) return BS_NEED_MORE;
    /***/ }
    return BS_NEED_MORE;
}
/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */ function deflate_fast(s, flush) {
    var hash_head; /* head of the hash chain */ 
    var bflush; /* set if current block must be flushed */ 
    for(;;){
        /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */ if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) return BS_NEED_MORE;
            if (s.lookahead === 0) break; /* flush the current block */ 
        }
        /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */ hash_head = 0 /*NIL*/ ;
        if (s.lookahead >= MIN_MATCH) {
            /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
        /***/ }
        /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */ if (hash_head !== 0 /*NIL*/  && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */ s.match_length = longest_match(s, hash_head);
        if (s.match_length >= MIN_MATCH) {
            // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only
            /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/ bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */ if (s.match_length <= s.max_lazy_match /*max_insert_length*/  && s.lookahead >= MIN_MATCH) {
                s.match_length--; /* string at strstart already in table */ 
                do {
                    s.strstart++;
                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                /***/ /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */ }while (--s.match_length !== 0);
                s.strstart++;
            } else {
                s.strstart += s.match_length;
                s.match_length = 0;
                s.ins_h = s.window[s.strstart];
                /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
            //#if MIN_MATCH != 3
            //                Call UPDATE_HASH() MIN_MATCH-3 more times
            //#endif
            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */ }
        } else {
            /* No match, output a literal byte */ //Tracevv((stderr,"%c", s.window[s.strstart]));
            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
        }
        if (bflush) {
            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);
            if (s.strm.avail_out === 0) return BS_NEED_MORE;
        /***/ }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);
        if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
        /***/ return BS_FINISH_DONE;
    }
    if (s.last_lit) {
        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);
        if (s.strm.avail_out === 0) return BS_NEED_MORE;
    /***/ }
    return BS_BLOCK_DONE;
}
/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */ function deflate_slow(s, flush) {
    var hash_head; /* head of hash chain */ 
    var bflush; /* set if current block must be flushed */ 
    var max_insert;
    /* Process the input block. */ for(;;){
        /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */ if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) return BS_NEED_MORE;
            if (s.lookahead === 0) break;
             /* flush the current block */ 
        }
        /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */ hash_head = 0 /*NIL*/ ;
        if (s.lookahead >= MIN_MATCH) {
            /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
        /***/ }
        /* Find the longest match, discarding those <= prev_length.
     */ s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 /*NIL*/  && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */ s.match_length = longest_match(s, hash_head);
            /* longest_match() sets match_start */ if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/ )) /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */ s.match_length = MIN_MATCH - 1;
        }
        /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */ if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            /* Do not insert strings in hash table beyond this. */ //check_match(s, s.strstart-1, s.prev_match, s.prev_length);
            /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/ bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */ s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do if (++s.strstart <= max_insert) {
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
            /***/ }
            while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);
                if (s.strm.avail_out === 0) return BS_NEED_MORE;
            /***/ }
        } else if (s.match_available) {
            /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */ //Tracevv((stderr,"%c", s->window[s->strstart-1]));
            /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) /*** FLUSH_BLOCK_ONLY(s, 0) ***/ flush_block_only(s, false);
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) return BS_NEED_MORE;
        } else {
            /* There is no previous match to compare with, wait for
       * the next step to decide.
       */ s.match_available = 1;
            s.strstart++;
            s.lookahead--;
        }
    }
    //Assert (flush != Z_NO_FLUSH, "no flush?");
    if (s.match_available) {
        //Tracevv((stderr,"%c", s->window[s->strstart-1]));
        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);
        if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
        /***/ return BS_FINISH_DONE;
    }
    if (s.last_lit) {
        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);
        if (s.strm.avail_out === 0) return BS_NEED_MORE;
    /***/ }
    return BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */ function deflate_rle(s, flush) {
    var bflush; /* set if current block must be flushed */ 
    var prev; /* byte at distance one to match */ 
    var scan, strend; /* scan goes up to strend for length of run */ 
    var _win = s.window;
    for(;;){
        /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */ if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) return BS_NEED_MORE;
            if (s.lookahead === 0) break;
             /* flush the current block */ 
        }
        /* See how many times the previous byte repeats */ s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                strend = s.strstart + MAX_MATCH;
                do ;
                while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                s.match_length = MAX_MATCH - (strend - scan);
                if (s.match_length > s.lookahead) s.match_length = s.lookahead;
            }
        //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
        }
        /* Emit match if have run of MIN_MATCH or longer, else emit literal */ if (s.match_length >= MIN_MATCH) {
            //check_match(s, s.strstart, s.strstart - 1, s.match_length);
            /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/ bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
        } else {
            /* No match, output a literal byte */ //Tracevv((stderr,"%c", s->window[s->strstart]));
            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
        }
        if (bflush) {
            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);
            if (s.strm.avail_out === 0) return BS_NEED_MORE;
        /***/ }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);
        if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
        /***/ return BS_FINISH_DONE;
    }
    if (s.last_lit) {
        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);
        if (s.strm.avail_out === 0) return BS_NEED_MORE;
    /***/ }
    return BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */ function deflate_huff(s, flush) {
    var bflush; /* set if current block must be flushed */ 
    for(;;){
        /* Make sure that we have a literal to write. */ if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
                if (flush === Z_NO_FLUSH) return BS_NEED_MORE;
                break; /* flush the current block */ 
            }
        }
        /* Output a literal byte */ s.match_length = 0;
        //Tracevv((stderr,"%c", s->window[s->strstart]));
        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);
            if (s.strm.avail_out === 0) return BS_NEED_MORE;
        /***/ }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);
        if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
        /***/ return BS_FINISH_DONE;
    }
    if (s.last_lit) {
        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);
        if (s.strm.avail_out === 0) return BS_NEED_MORE;
    /***/ }
    return BS_BLOCK_DONE;
}
/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */ function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
}
var configuration_table;
configuration_table = [
    /*      good lazy nice chain */ new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */ new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */ new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */ new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */ new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */ new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */ new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */ new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */ new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */ new Config(32, 258, 258, 4096, deflate_slow)
];
/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */ function lm_init(s) {
    s.window_size = 2 * s.w_size;
    /*** CLEAR_HASH(s); ***/ zero(s.head); // Fill with NIL (= 0);
    /* Set the default configuration parameters:
   */ s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
}
function DeflateState() {
    this.strm = null; /* pointer back to this zlib stream */ 
    this.status = 0; /* as the name implies */ 
    this.pending_buf = null; /* output still pending */ 
    this.pending_buf_size = 0; /* size of pending_buf */ 
    this.pending_out = 0; /* next pending byte to output to the stream */ 
    this.pending = 0; /* nb of bytes in the pending buffer */ 
    this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */ 
    this.gzhead = null; /* gzip header information to write */ 
    this.gzindex = 0; /* where in extra, name, or comment */ 
    this.method = Z_DEFLATED; /* can only be DEFLATED */ 
    this.last_flush = -1; /* value of flush param for previous deflate call */ 
    this.w_size = 0; /* LZ77 window size (32K by default) */ 
    this.w_bits = 0; /* log2(w_size)  (8..16) */ 
    this.w_mask = 0; /* w_size - 1 */ 
    this.window = null;
    /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */ this.window_size = 0;
    /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */ this.prev = null;
    /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */ this.head = null; /* Heads of the hash chains or NIL. */ 
    this.ins_h = 0; /* hash index of string to be inserted */ 
    this.hash_size = 0; /* number of elements in hash table */ 
    this.hash_bits = 0; /* log2(hash_size) */ 
    this.hash_mask = 0; /* hash_size-1 */ 
    this.hash_shift = 0;
    /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */ this.block_start = 0;
    /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */ this.match_length = 0; /* length of best match */ 
    this.prev_match = 0; /* previous match */ 
    this.match_available = 0; /* set if previous match exists */ 
    this.strstart = 0; /* start of string to insert */ 
    this.match_start = 0; /* start of matching string */ 
    this.lookahead = 0; /* number of valid bytes ahead in window */ 
    this.prev_length = 0;
    /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */ this.max_chain_length = 0;
    /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */ this.max_lazy_match = 0;
    /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */ // That's alias to max_lazy_match, don't use directly
    //this.max_insert_length = 0;
    /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */ this.level = 0; /* compression level (1..9) */ 
    this.strategy = 0; /* favor or force Huffman coding*/ 
    this.good_match = 0;
    /* Use a faster search when the previous match is longer than this */ this.nice_match = 0; /* Stop searching when current match exceeds this */ 
    /* used by trees.c: */ /* Didn't use ct_data typedef below to suppress compiler warning */ // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
    // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
    // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
    // Use flat array of DOUBLE size, with interleaved fata,
    // because JS does not support effective
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null; /* desc. for literal tree */ 
    this.d_desc = null; /* desc. for distance tree */ 
    this.bl_desc = null; /* desc. for bit length tree */ 
    //ush bl_count[MAX_BITS+1];
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    /* number of codes at each bit length for an optimal tree */ //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
    this.heap = new utils.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */ 
    zero(this.heap);
    this.heap_len = 0; /* number of elements in the heap */ 
    this.heap_max = 0; /* element of largest frequency */ 
    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */ this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
    zero(this.depth);
    /* Depth of each subtree used as tie breaker for trees of equal frequency
   */ this.l_buf = 0; /* buffer index for literals or lengths */ 
    this.lit_bufsize = 0;
    /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */ this.last_lit = 0; /* running index in l_buf */ 
    this.d_buf = 0;
    /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */ this.opt_len = 0; /* bit length of current block with optimal trees */ 
    this.static_len = 0; /* bit length of current block with static trees */ 
    this.matches = 0; /* number of string matches in current block */ 
    this.insert = 0; /* bytes at end of window left to insert */ 
    this.bi_buf = 0;
    /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */ this.bi_valid = 0;
/* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */ // Used for window memory init. We safely ignore it for JS. That makes
// sense only for pointers and memory check tools.
//this.high_water = 0;
/* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */ }
function deflateResetKeep(strm) {
    var s;
    if (!strm || !strm.state) return err(strm, Z_STREAM_ERROR);
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) s.wrap = -s.wrap;
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
     : 1; // adler32(0, Z_NULL, 0)
    s.last_flush = Z_NO_FLUSH;
    trees._tr_init(s);
    return Z_OK;
}
function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) lm_init(strm.state);
    return ret;
}
function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) return Z_STREAM_ERROR;
    if (strm.state.wrap !== 2) return Z_STREAM_ERROR;
    strm.state.gzhead = head;
    return Z_OK;
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) return Z_STREAM_ERROR;
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) level = 6;
    if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
    } else if (windowBits > 15) {
        wrap = 2; /* write gzip wrapper instead */ 
        windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) return err(strm, Z_STREAM_ERROR);
    if (windowBits === 8) windowBits = 9;
    /* until 256-byte window bug fixed */ var s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new utils.Buf8(s.w_size * 2);
    s.head = new utils.Buf16(s.hash_size);
    s.prev = new utils.Buf16(s.w_size);
    // Don't need mem init magic for JS.
    //s.high_water = 0;  /* nothing written to s->window yet */
    s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */ 
    s.pending_buf_size = s.lit_bufsize * 4;
    //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
    //s->pending_buf = (uchf *) overlay;
    s.pending_buf = new utils.Buf8(s.pending_buf_size);
    // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
    //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
    s.d_buf = 1 * s.lit_bufsize;
    //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
    s.l_buf = 3 * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
}
function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}
function deflate(strm, flush) {
    var old_flush, s;
    var beg, val; // for gzip header write only
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    s.strm = strm; /* just in case */ 
    old_flush = s.last_flush;
    s.last_flush = flush;
    /* Write the header */ if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
            strm.adler = 0; //crc32(0L, Z_NULL, 0);
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, OS_CODE);
                s.status = BUSY_STATE;
            } else {
                put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
                put_byte(s, s.gzhead.time & 0xff);
                put_byte(s, s.gzhead.time >> 8 & 0xff);
                put_byte(s, s.gzhead.time >> 16 & 0xff);
                put_byte(s, s.gzhead.time >> 24 & 0xff);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, s.gzhead.os & 0xff);
                if (s.gzhead.extra && s.gzhead.extra.length) {
                    put_byte(s, s.gzhead.extra.length & 0xff);
                    put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
                }
                if (s.gzhead.hcrc) strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                s.gzindex = 0;
                s.status = EXTRA_STATE;
            }
        } else {
            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
            var level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) level_flags = 0;
            else if (s.level < 6) level_flags = 1;
            else if (s.level === 6) level_flags = 2;
            else level_flags = 3;
            header |= level_flags << 6;
            if (s.strstart !== 0) header |= PRESET_DICT;
            header += 31 - header % 31;
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            /* Save the adler32 of the preset dictionary: */ if (s.strstart !== 0) {
                putShortMSB(s, strm.adler >>> 16);
                putShortMSB(s, strm.adler & 0xffff);
            }
            strm.adler = 1; // adler32(0L, Z_NULL, 0);
        }
    }
    //#ifdef GZIP
    if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra /* != Z_NULL*/ ) {
            beg = s.pending; /* start of bytes to update crc */ 
            while(s.gzindex < (s.gzhead.extra.length & 0xffff)){
                if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    flush_pending(strm);
                    beg = s.pending;
                    if (s.pending === s.pending_buf_size) break;
                }
                put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
                s.gzindex++;
            }
            if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            if (s.gzindex === s.gzhead.extra.length) {
                s.gzindex = 0;
                s.status = NAME_STATE;
            }
        } else s.status = NAME_STATE;
    }
    if (s.status === NAME_STATE) {
        if (s.gzhead.name /* != Z_NULL*/ ) {
            beg = s.pending; /* start of bytes to update crc */ 
            //int val;
            do {
                if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    flush_pending(strm);
                    beg = s.pending;
                    if (s.pending === s.pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                // JS specific: little magic to add zero terminator to end of string
                if (s.gzindex < s.gzhead.name.length) val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
                else val = 0;
                put_byte(s, val);
            }while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            if (val === 0) {
                s.gzindex = 0;
                s.status = COMMENT_STATE;
            }
        } else s.status = COMMENT_STATE;
    }
    if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment /* != Z_NULL*/ ) {
            beg = s.pending; /* start of bytes to update crc */ 
            //int val;
            do {
                if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    flush_pending(strm);
                    beg = s.pending;
                    if (s.pending === s.pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                // JS specific: little magic to add zero terminator to end of string
                if (s.gzindex < s.gzhead.comment.length) val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
                else val = 0;
                put_byte(s, val);
            }while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            if (val === 0) s.status = HCRC_STATE;
        } else s.status = HCRC_STATE;
    }
    if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) flush_pending(strm);
            if (s.pending + 2 <= s.pending_buf_size) {
                put_byte(s, strm.adler & 0xff);
                put_byte(s, strm.adler >> 8 & 0xff);
                strm.adler = 0; //crc32(0L, Z_NULL, 0);
                s.status = BUSY_STATE;
            }
        } else s.status = BUSY_STATE;
    }
    //#endif
    /* Flush as much pending output as possible */ if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
            /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */ s.last_flush = -1;
            return Z_OK;
        }
    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */ } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) return err(strm, Z_BUF_ERROR);
    /* User must not provide more input after the first FINISH: */ if (s.status === FINISH_STATE && strm.avail_in !== 0) return err(strm, Z_BUF_ERROR);
    /* Start a new block or continue the current one.
   */ if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) s.status = FINISH_STATE;
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) s.last_flush = -1;
            return Z_OK;
        /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */ }
        if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) trees._tr_align(s);
            else if (flush !== Z_BLOCK) {
                trees._tr_stored_block(s, 0, 0, false);
                /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */ if (flush === Z_FULL_FLUSH) {
                    /*** CLEAR_HASH(s); ***/ /* forget history */ zero(s.head); // Fill with NIL (= 0);
                    if (s.lookahead === 0) {
                        s.strstart = 0;
                        s.block_start = 0;
                        s.insert = 0;
                    }
                }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
                s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */ 
                return Z_OK;
            }
        }
    }
    //Assert(strm->avail_out > 0, "bug2");
    //if (strm.avail_out <= 0) { throw new Error("bug2");}
    if (flush !== Z_FINISH) return Z_OK;
    if (s.wrap <= 0) return Z_STREAM_END;
    /* Write the trailer */ if (s.wrap === 2) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        put_byte(s, strm.adler >> 16 & 0xff);
        put_byte(s, strm.adler >> 24 & 0xff);
        put_byte(s, strm.total_in & 0xff);
        put_byte(s, strm.total_in >> 8 & 0xff);
        put_byte(s, strm.total_in >> 16 & 0xff);
        put_byte(s, strm.total_in >> 24 & 0xff);
    } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
    }
    flush_pending(strm);
    /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */ if (s.wrap > 0) s.wrap = -s.wrap;
    /* write the trailer only once! */ return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}
function deflateEnd(strm) {
    var status;
    if (!strm /*== Z_NULL*/  || !strm.state /*== Z_NULL*/ ) return Z_STREAM_ERROR;
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) return err(strm, Z_STREAM_ERROR);
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}
/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */ function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s;
    var str, n;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm /*== Z_NULL*/  || !strm.state /*== Z_NULL*/ ) return Z_STREAM_ERROR;
    s = strm.state;
    wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) return Z_STREAM_ERROR;
    /* when using zlib wrappers, compute Adler-32 for provided dictionary */ if (wrap === 1) /* adler32(strm->adler, dictionary, dictLength); */ strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    s.wrap = 0; /* avoid computing Adler-32 in read_buf */ 
    /* if dictionary would fill window, just replace the history */ if (dictLength >= s.w_size) {
        if (wrap === 0) {
            /*** CLEAR_HASH(s); ***/ zero(s.head); // Fill with NIL (= 0);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
        }
        /* use the tail */ // dictionary = dictionary.slice(dictLength - s.w_size);
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
    }
    /* insert dictionary into window and hash */ avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while(s.lookahead >= MIN_MATCH){
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
        }while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
}
exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)'; /* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/ 

},{"6ecd050ab5cf9e92":"9lGgI","b17b4660c9a756a1":"iItDK","8a0173ce93724f81":"eOyJn","9fe740ea87b93669":"P1ij2","86729d90d4373c72":"3b6uW"}],"iItDK":[function(require,module,exports,__globalThis) {
'use strict';
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
/* eslint-disable space-unary-ops */ var utils = require("f7e73d4e313a2bb7");
/* Public constants ==========================================================*/ /* ===========================================================================*/ //var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED = 4;
//var Z_DEFAULT_STRATEGY  = 0;
/* Possible values of the data_type field (though see inflate()) */ var Z_BINARY = 0;
var Z_TEXT = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN = 2;
/*============================================================================*/ function zero(buf) {
    var len = buf.length;
    while(--len >= 0)buf[len] = 0;
}
// From zutil.h
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
/* The three kinds of block type */ var MIN_MATCH = 3;
var MAX_MATCH = 258;
/* The minimum and maximum match lengths */ // From deflate.h
/* ===========================================================================
 * Internal compression state.
 */ var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */ var LITERALS = 256;
/* number of literal bytes 0..255 */ var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */ var D_CODES = 30;
/* number of distance codes */ var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */ var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */ var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */ var Buf_size = 16;
/* size of bit buffer in bi_buf */ /* ===========================================================================
 * Constants
 */ var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */ var END_BLOCK = 256;
/* end of block literal code */ var REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */ var REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */ var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */ /* eslint-disable comma-spacing,array-bracket-spacing */ var extra_lbits = /* extra bits for each length code */ [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0
];
var extra_dbits = /* extra bits for each distance code */ [
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
];
var extra_blbits = /* extra bits for each bit length code */ [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    3,
    7
];
var bl_order = [
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
];
/* eslint-enable comma-spacing,array-bracket-spacing */ /* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */ /* ===========================================================================
 * Local data. These are initialized only once.
 */ // We pre-fill arrays with 0 to avoid uninitialized gaps
var DIST_CODE_LEN = 512; /* see definition of array dist_code below */ 
// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */ var static_dtree = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */ var _dist_code = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */ var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */ var base_length = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */ var base_dist = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */ function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree; /* static tree or NULL */ 
    this.extra_bits = extra_bits; /* extra bits for each code or NULL */ 
    this.extra_base = extra_base; /* base index for extra_bits */ 
    this.elems = elems; /* max number of elements in the tree */ 
    this.max_length = max_length; /* max bit length for the codes */ 
    // show if `static_tree` has data or dummy - needed for monomorphic objects
    this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree; /* the dynamic tree */ 
    this.max_code = 0; /* largest code with non zero frequency */ 
    this.stat_desc = stat_desc; /* the corresponding static tree */ 
}
function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */ function put_short(s, w) {
    //    put_byte(s, (uch)((w) & 0xff));
    //    put_byte(s, (uch)((ush)(w) >> 8));
    s.pending_buf[s.pending++] = w & 0xff;
    s.pending_buf[s.pending++] = w >>> 8 & 0xff;
}
/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */ function send_bits(s, value, length) {
    if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 0xffff;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
    } else {
        s.bi_buf |= value << s.bi_valid & 0xffff;
        s.bi_valid += length;
    }
}
function send_code(s, c, tree) {
    send_bits(s, tree[c * 2], tree[c * 2 + 1]);
}
/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */ function bi_reverse(code, len) {
    var res = 0;
    do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
    }while (--len > 0);
    return res >>> 1;
}
/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */ function bi_flush(s) {
    if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 0xff;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
    }
}
/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */ function gen_bitlen(s, desc) //    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h; /* heap index */ 
    var n, m; /* iterate over the tree elements */ 
    var bits; /* bit length */ 
    var xbits; /* extra bits */ 
    var f; /* frequency */ 
    var overflow = 0; /* number of elements with bit length too large */ 
    for(bits = 0; bits <= MAX_BITS; bits++)s.bl_count[bits] = 0;
    /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */ tree[s.heap[s.heap_max] * 2 + 1] = 0; /* root of the heap */ 
    for(h = s.heap_max + 1; h < HEAP_SIZE; h++){
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
            bits = max_length;
            overflow++;
        }
        tree[n * 2 + 1] = bits;
        /* We overwrite tree[n].Dad which is no longer needed */ if (n > max_code) continue;
         /* not a leaf node */ 
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) xbits = extra[n - base];
        f = tree[n * 2] /*.Freq*/ ;
        s.opt_len += f * (bits + xbits);
        if (has_stree) s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
    if (overflow === 0) return;
    // Trace((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */ /* Find the first bit length which could increase: */ do {
        bits = max_length - 1;
        while(s.bl_count[bits] === 0)bits--;
        s.bl_count[bits]--; /* move one leaf down the tree */ 
        s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */ 
        s.bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */ overflow -= 2;
    }while (overflow > 0);
    /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */ for(bits = max_length; bits !== 0; bits--){
        n = s.bl_count[bits];
        while(n !== 0){
            m = s.heap[--h];
            if (m > max_code) continue;
            if (tree[m * 2 + 1] !== bits) {
                // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2] /*.Freq*/ ;
                tree[m * 2 + 1] = bits;
            }
            n--;
        }
    }
}
/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */ function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
    var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */ 
    var code = 0; /* running code value */ 
    var bits; /* bit index */ 
    var n; /* code index */ 
    /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */ for(bits = 1; bits <= MAX_BITS; bits++)next_code[bits] = code = code + bl_count[bits - 1] << 1;
    /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */ //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
    //        "inconsistent bit counts");
    //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
    for(n = 0; n <= max_code; n++){
        var len = tree[n * 2 + 1] /*.Len*/ ;
        if (len === 0) continue;
        /* Now reverse the bits */ tree[n * 2] = bi_reverse(next_code[len]++, len);
    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
}
/* ===========================================================================
 * Initialize the various 'constant' tables.
 */ function tr_static_init() {
    var n; /* iterates over tree elements */ 
    var bits; /* bit counter */ 
    var length; /* length value */ 
    var code; /* code value */ 
    var dist; /* distance index */ 
    var bl_count = new Array(MAX_BITS + 1);
    /* number of codes at each bit length for an optimal tree */ // do check in _tr_init()
    //if (static_init_done) return;
    /* For some embedded targets, global variables are not initialized: */ /*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/ /* Initialize the mapping length (0..255) -> length code (0..28) */ length = 0;
    for(code = 0; code < LENGTH_CODES - 1; code++){
        base_length[code] = length;
        for(n = 0; n < 1 << extra_lbits[code]; n++)_length_code[length++] = code;
    }
    //Assert (length == 256, "tr_static_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */ _length_code[length - 1] = code;
    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */ dist = 0;
    for(code = 0; code < 16; code++){
        base_dist[code] = dist;
        for(n = 0; n < 1 << extra_dbits[code]; n++)_dist_code[dist++] = code;
    }
    //Assert (dist == 256, "tr_static_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */ 
    for(; code < D_CODES; code++){
        base_dist[code] = dist << 7;
        for(n = 0; n < 1 << extra_dbits[code] - 7; n++)_dist_code[256 + dist++] = code;
    }
    //Assert (dist == 256, "tr_static_init: 256+dist != 512");
    /* Construct the codes of the static literal tree */ for(bits = 0; bits <= MAX_BITS; bits++)bl_count[bits] = 0;
    n = 0;
    while(n <= 143){
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
    }
    while(n <= 255){
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
    }
    while(n <= 279){
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
    }
    while(n <= 287){
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
    }
    /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */ gen_codes(static_ltree, L_CODES + 1, bl_count);
    /* The static distance tree is trivial: */ for(n = 0; n < D_CODES; n++){
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
    }
    // Now data ready and we can init static trees
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
//static_init_done = true;
}
/* ===========================================================================
 * Initialize a new block.
 */ function init_block(s) {
    var n; /* iterates over tree elements */ 
    /* Initialize the trees. */ for(n = 0; n < L_CODES; n++)s.dyn_ltree[n * 2] = 0;
    for(n = 0; n < D_CODES; n++)s.dyn_dtree[n * 2] = 0;
    for(n = 0; n < BL_CODES; n++)s.bl_tree[n * 2] = 0;
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
}
/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */ function bi_windup(s) {
    if (s.bi_valid > 8) put_short(s, s.bi_buf);
    else if (s.bi_valid > 0) //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
    s.bi_buf = 0;
    s.bi_valid = 0;
}
/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */ function copy_block(s, buf, len, header) //DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
    bi_windup(s); /* align on byte boundary */ 
    if (header) {
        put_short(s, len);
        put_short(s, ~len);
    }
    //  while (len--) {
    //    put_byte(s, *buf++);
    //  }
    utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
    s.pending += len;
}
/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */ function smaller(tree, n, m, depth) {
    var _n2 = n * 2;
    var _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
}
/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */ function pqdownheap(s, tree, k) //    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
    var v = s.heap[k];
    var j = k << 1; /* left son of k */ 
    while(j <= s.heap_len){
        /* Set j to the smallest of the two sons: */ if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) j++;
        /* Exit if v is smaller than both sons */ if (smaller(tree, v, s.heap[j], s.depth)) break;
        /* Exchange v with the smallest son */ s.heap[k] = s.heap[j];
        k = j;
        /* And continue down the tree, setting j to the left son of k */ j <<= 1;
    }
    s.heap[k] = v;
}
// inlined manually
// var SMALLEST = 1;
/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */ function compress_block(s, ltree, dtree) //    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
    var dist; /* distance of matched string */ 
    var lc; /* match length or unmatched char (if dist == 0) */ 
    var lx = 0; /* running index in l_buf */ 
    var code; /* the code to send */ 
    var extra; /* number of extra bits to send */ 
    if (s.last_lit !== 0) do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) send_code(s, lc, ltree); /* send a literal byte */ 
        else {
            /* Here, lc is the match length - MIN_MATCH */ code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree); /* send the length code */ 
            extra = extra_lbits[code];
            if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra); /* send the extra length bits */ 
            }
            dist--; /* dist is now the match distance - 1 */ 
            code = d_code(dist);
            //Assert (code < D_CODES, "bad d_code");
            send_code(s, code, dtree); /* send the distance code */ 
            extra = extra_dbits[code];
            if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra); /* send the extra distance bits */ 
            }
        } /* literal or match pair ? */ 
    /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */ //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
    //       "pendingBuf overflow");
    }while (lx < s.last_lit);
    send_code(s, END_BLOCK, ltree);
}
/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */ function build_tree(s, desc) //    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m; /* iterate over heap elements */ 
    var max_code = -1; /* largest code with non zero frequency */ 
    var node; /* new node being created */ 
    /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */ s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for(n = 0; n < elems; n++)if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
    } else tree[n * 2 + 1] = 0;
    /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */ while(s.heap_len < 2){
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) s.static_len -= stree[node * 2 + 1] /*.Len*/ ;
    /* node is 0 or 1 so it does not have extra bits */ }
    desc.max_code = max_code;
    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */ for(n = s.heap_len >> 1 /*int /2*/ ; n >= 1; n--)pqdownheap(s, tree, n);
    /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */ node = elems; /* next internal node of the tree */ 
    do {
        //pqremove(s, tree, n);  /* n = node of least frequency */
        /*** pqremove ***/ n = s.heap[1 /*SMALLEST*/ ];
        s.heap[1 /*SMALLEST*/ ] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1 /*SMALLEST*/ );
        /***/ m = s.heap[1 /*SMALLEST*/ ]; /* m = node of next least frequency */ 
        s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */ 
        s.heap[--s.heap_max] = m;
        /* Create a new node father of n and m */ tree[node * 2] = tree[n * 2] + tree[m * 2] /*.Freq*/ ;
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        /* and insert the new node in the heap */ s.heap[1 /*SMALLEST*/ ] = node++;
        pqdownheap(s, tree, 1 /*SMALLEST*/ );
    }while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/ ];
    /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */ gen_bitlen(s, desc);
    /* The field len is now set, we can generate the bit codes */ gen_codes(tree, max_code, s.bl_count);
}
/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */ function scan_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
    var n; /* iterates over all tree elements */ 
    var prevlen = -1; /* last emitted length */ 
    var curlen; /* length of current code */ 
    var nextlen = tree[1] /*.Len*/ ; /* length of next code */ 
    var count = 0; /* repeat count of the current code */ 
    var max_count = 7; /* max repeat count */ 
    var min_count = 4; /* min repeat count */ 
    if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 0xffff; /* guard */ 
    for(n = 0; n <= max_code; n++){
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;
        if (++count < max_count && curlen === nextlen) continue;
        else if (count < min_count) s.bl_tree[curlen * 2] += count;
        else if (curlen !== 0) {
            if (curlen !== prevlen) s.bl_tree[curlen * 2]++;
            s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) s.bl_tree[REPZ_3_10 * 2]++;
        else s.bl_tree[REPZ_11_138 * 2]++;
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
        } else {
            max_count = 7;
            min_count = 4;
        }
    }
}
/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */ function send_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
    var n; /* iterates over all tree elements */ 
    var prevlen = -1; /* last emitted length */ 
    var curlen; /* length of current code */ 
    var nextlen = tree[1] /*.Len*/ ; /* length of next code */ 
    var count = 0; /* repeat count of the current code */ 
    var max_count = 7; /* max repeat count */ 
    var min_count = 4; /* min repeat count */ 
    /* tree[max_code+1].Len = -1; */ /* guard already set */ if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
    }
    for(n = 0; n <= max_code; n++){
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;
        if (++count < max_count && curlen === nextlen) continue;
        else if (count < min_count) do send_code(s, curlen, s.bl_tree);
        while (--count !== 0);
        else if (curlen !== 0) {
            if (curlen !== prevlen) {
                send_code(s, curlen, s.bl_tree);
                count--;
            }
            //Assert(count >= 3 && count <= 6, " 3_6?");
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);
        } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);
        } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
        } else {
            max_count = 7;
            min_count = 4;
        }
    }
}
/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */ function build_bl_tree(s) {
    var max_blindex; /* index of last bit length code of non zero freq */ 
    /* Determine the bit length frequencies for literal and distance trees */ scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    /* Build the bit length tree: */ build_tree(s, s.bl_desc);
    /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */ /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */ for(max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--){
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */ s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
    //        s->opt_len, s->static_len));
    return max_blindex;
}
/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */ function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
    var rank; /* index in bl_order */ 
    //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
    //        "too many codes");
    //Tracev((stderr, "\nbl counts: "));
    send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */ 
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */ 
    for(rank = 0; rank < blcodes; rank++)//Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
    send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */ 
    //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
    send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */ 
//Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}
/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */ function detect_data_type(s) {
    /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */ var black_mask = 0xf3ffc07f;
    var n;
    /* Check for non-textual ("black-listed") bytes. */ for(n = 0; n <= 31; n++, black_mask >>>= 1){
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) return Z_BINARY;
    }
    /* Check for textual ("white-listed") bytes. */ if (s.dyn_ltree[18] !== 0 || s.dyn_ltree[20] !== 0 || s.dyn_ltree[26] !== 0) return Z_TEXT;
    for(n = 32; n < LITERALS; n++){
        if (s.dyn_ltree[n * 2] !== 0) return Z_TEXT;
    }
    /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */ return Z_BINARY;
}
var static_init_done = false;
/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */ function _tr_init(s) {
    if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    /* Initialize the first block of the first file: */ init_block(s);
}
/* ===========================================================================
 * Send a stored block
 */ function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */ 
    copy_block(s, buf, stored_len, true); /* with header */ 
}
/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */ function _tr_align(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
}
/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */ function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
    var opt_lenb, static_lenb; /* opt_len and static_len in bytes */ 
    var max_blindex = 0; /* index of last bit length code of non zero freq */ 
    /* Build the Huffman trees unless a stored block is forced */ if (s.level > 0) {
        /* Check if the file is binary or text */ if (s.strm.data_type === Z_UNKNOWN) s.strm.data_type = detect_data_type(s);
        /* Construct the literal and distance trees */ build_tree(s, s.l_desc);
        // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
        //        s->static_len));
        build_tree(s, s.d_desc);
        // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
        //        s->static_len));
        /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */ /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */ max_blindex = build_bl_tree(s);
        /* Determine the best encoding. Compute the block lengths in bytes. */ opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
        //        s->last_lit));
        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
    } else // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */ 
    if (stored_len + 4 <= opt_lenb && buf !== -1) /* 4: two words for the lengths */ /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */ _tr_stored_block(s, buf, stored_len, last);
    else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
    } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
    /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */ init_block(s);
    if (last) bi_windup(s);
// Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
//       s->compressed_len-7*last));
}
/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */ function _tr_tally(s, dist, lc) //    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
    //var out_length, in_length, dcode;
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
    s.last_lit++;
    if (dist === 0) /* lc is the unmatched char */ s.dyn_ltree[lc * 2]++;
    else {
        s.matches++;
        /* Here, lc is the match length - MIN_MATCH */ dist--; /* dist = match distance - 1 */ 
        //Assert((ush)dist < (ush)MAX_DIST(s) &&
        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
        //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
    }
    // (!) This block is disabled in zlib defaults,
    // don't enable it for binary compatibility
    //#ifdef TRUNCATE_BLOCK
    //  /* Try to guess if it is profitable to stop the current block here */
    //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
    //    /* Compute an upper bound for the compressed length */
    //    out_length = s.last_lit*8;
    //    in_length = s.strstart - s.block_start;
    //
    //    for (dcode = 0; dcode < D_CODES; dcode++) {
    //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
    //    }
    //    out_length >>>= 3;
    //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
    //    //       s->last_lit, in_length, out_length,
    //    //       100L - out_length*100L/in_length));
    //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
    //      return true;
    //    }
    //  }
    //#endif
    return s.last_lit === s.lit_bufsize - 1;
/* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */ }
exports._tr_init = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"f7e73d4e313a2bb7":"9lGgI"}],"eOyJn":[function(require,module,exports,__globalThis) {
'use strict';
// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
function adler32(adler, buf, len, pos) {
    var s1 = adler & 0xffff | 0, s2 = adler >>> 16 & 0xffff | 0, n = 0;
    while(len !== 0){
        // Set limit ~ twice less than 5552, to keep
        // s2 in 31-bits, because we force signed ints.
        // in other case %= will fail.
        n = len > 2000 ? 2000 : len;
        len -= n;
        do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
        }while (--n);
        s1 %= 65521;
        s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
}
module.exports = adler32;

},{}],"P1ij2":[function(require,module,exports,__globalThis) {
'use strict';
// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// Use ordinary array, since untyped makes no boost here
function makeTable() {
    var c, table = [];
    for(var n = 0; n < 256; n++){
        c = n;
        for(var k = 0; k < 8; k++)c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
        table[n] = c;
    }
    return table;
}
// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();
function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc ^= -1;
    for(var i = pos; i < end; i++)crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
    return crc ^ -1; // >>> 0;
}
module.exports = crc32;

},{}],"3b6uW":[function(require,module,exports,__globalThis) {
'use strict';
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
module.exports = {
    2: 'need dictionary',
    /* Z_NEED_DICT       2  */ 1: 'stream end',
    /* Z_STREAM_END      1  */ 0: '',
    /* Z_OK              0  */ '-1': 'file error',
    /* Z_ERRNO         (-1) */ '-2': 'stream error',
    /* Z_STREAM_ERROR  (-2) */ '-3': 'data error',
    /* Z_DATA_ERROR    (-3) */ '-4': 'insufficient memory',
    /* Z_MEM_ERROR     (-4) */ '-5': 'buffer error',
    /* Z_BUF_ERROR     (-5) */ '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */ 
};

},{}],"9m1XG":[function(require,module,exports,__globalThis) {
// String encode/decode helpers
'use strict';
var utils = require("7ca9172d5a6b1798");
// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;
try {
    String.fromCharCode.apply(null, [
        0
    ]);
} catch (__) {
    STR_APPLY_OK = false;
}
try {
    String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
    STR_APPLY_UIA_OK = false;
}
// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for(var q = 0; q < 256; q++)_utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start
// convert string to array (typed, when possible)
exports.string2buf = function(str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
    // count binary size
    for(m_pos = 0; m_pos < str_len; m_pos++){
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }
    // allocate buffer
    buf = new utils.Buf8(buf_len);
    // convert
    for(i = 0, m_pos = 0; i < buf_len; m_pos++){
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) /* one byte */ buf[i++] = c;
        else if (c < 0x800) {
            /* two bytes */ buf[i++] = 0xC0 | c >>> 6;
            buf[i++] = 0x80 | c & 0x3f;
        } else if (c < 0x10000) {
            /* three bytes */ buf[i++] = 0xE0 | c >>> 12;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        } else {
            /* four bytes */ buf[i++] = 0xf0 | c >>> 18;
            buf[i++] = 0x80 | c >>> 12 & 0x3f;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        }
    }
    return buf;
};
// Helper (used in 2 places)
function buf2binstring(buf, len) {
    // On Chrome, the arguments in a function call that are allowed is `65534`.
    // If the length of the buffer is smaller than that, we can use this optimization,
    // otherwise we will take a slower path.
    if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
    var result = '';
    for(var i = 0; i < len; i++)result += String.fromCharCode(buf[i]);
    return result;
}
// Convert byte array to binary string
exports.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
};
// Convert binary string (typed, when possible)
exports.binstring2buf = function(str) {
    var buf = new utils.Buf8(str.length);
    for(var i = 0, len = buf.length; i < len; i++)buf[i] = str.charCodeAt(i);
    return buf;
};
// convert array to string
exports.buf2string = function(buf, max) {
    var i, out, c, c_len;
    var len = max || buf.length;
    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    var utf16buf = new Array(len * 2);
    for(out = 0, i = 0; i < len;){
        c = buf[i++];
        // quick process ascii
        if (c < 0x80) {
            utf16buf[out++] = c;
            continue;
        }
        c_len = _utf8len[c];
        // skip 5 & 6 byte codes
        if (c_len > 4) {
            utf16buf[out++] = 0xfffd;
            i += c_len - 1;
            continue;
        }
        // apply mask on first byte
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        // join the rest
        while(c_len > 1 && i < len){
            c = c << 6 | buf[i++] & 0x3f;
            c_len--;
        }
        // terminated by end of string?
        if (c_len > 1) {
            utf16buf[out++] = 0xfffd;
            continue;
        }
        if (c < 0x10000) utf16buf[out++] = c;
        else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
            utf16buf[out++] = 0xdc00 | c & 0x3ff;
        }
    }
    return buf2binstring(utf16buf, out);
};
// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function(buf, max) {
    var pos;
    max = max || buf.length;
    if (max > buf.length) max = buf.length;
    // go back from last position, until start of sequence found
    pos = max - 1;
    while(pos >= 0 && (buf[pos] & 0xC0) === 0x80)pos--;
    // Very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) return max;
    // If we came to start of buffer - that means buffer is too small,
    // return max too.
    if (pos === 0) return max;
    return pos + _utf8len[buf[pos]] > max ? pos : max;
};

},{"7ca9172d5a6b1798":"9lGgI"}],"i3gjN":[function(require,module,exports,__globalThis) {
'use strict';
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
function ZStream() {
    /* next input byte */ this.input = null; // JS specific, because we have no pointers
    this.next_in = 0;
    /* number of bytes available at input */ this.avail_in = 0;
    /* total number of input bytes read so far */ this.total_in = 0;
    /* next output byte should be put there */ this.output = null; // JS specific, because we have no pointers
    this.next_out = 0;
    /* remaining free space at output */ this.avail_out = 0;
    /* total number of bytes output so far */ this.total_out = 0;
    /* last error message, NULL if no error */ this.msg = '' /*Z_NULL*/ ;
    /* not visible by applications */ this.state = null;
    /* best guess about the data type: binary or text */ this.data_type = 2 /*Z_UNKNOWN*/ ;
    /* adler32 value of the uncompressed data */ this.adler = 0;
}
module.exports = ZStream;

},{}],"eF7nj":[function(require,module,exports,__globalThis) {
'use strict';
var zlib_inflate = require("dd64f509a13f2ae4");
var utils = require("4c9b744bf1bb68c7");
var strings = require("a6a879671ada369a");
var c = require("dbf920c388b193d4");
var msg = require("a85d599be6e8296a");
var ZStream = require("2cb10505c6d74721");
var GZheader = require("e0b11c8ff712dfd");
var toString = Object.prototype.toString;
/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/ /* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/ /**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/ /**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/ /**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/ /**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/ function Inflate(options) {
    if (!(this instanceof Inflate)) return new Inflate(options);
    this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ''
    }, options || {});
    var opt = this.options;
    // Force window size for `raw` data, if not set directly,
    // because we have no header for autodetect.
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) opt.windowBits = -15;
    }
    // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) opt.windowBits += 32;
    // Gzip header has no info about windows size, we can do autodetect only
    // for deflate. So, if window size not set, force it to max when gzip possible
    if (opt.windowBits > 15 && opt.windowBits < 48) // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    {
        if ((opt.windowBits & 15) === 0) opt.windowBits |= 15;
    }
    this.err = 0; // error code, if happens (0 = Z_OK)
    this.msg = ''; // error message
    this.ended = false; // used to avoid multiple onEnd() calls
    this.chunks = []; // chunks of compressed data
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== c.Z_OK) throw new Error(msg[status]);
    this.header = new GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    // Setup dictionary
    if (opt.dictionary) {
        // Convert data if needed
        if (typeof opt.dictionary === 'string') opt.dictionary = strings.string2buf(opt.dictionary);
        else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') opt.dictionary = new Uint8Array(opt.dictionary);
        if (opt.raw) {
            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
            if (status !== c.Z_OK) throw new Error(msg[status]);
        }
    }
}
/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/ Inflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;
    var status, _mode;
    var next_out_utf8, tail, utf8str;
    // Flag to properly process Z_BUF_ERROR on testing inflate call
    // when we check that all output data was flushed.
    var allowBufError = false;
    if (this.ended) return false;
    _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
    // Convert data if needed
    if (typeof data === 'string') // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
    else if (toString.call(data) === '[object ArrayBuffer]') strm.input = new Uint8Array(data);
    else strm.input = data;
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
        if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH); /* no bad return value */ 
        if (status === c.Z_NEED_DICT && dictionary) status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
            status = c.Z_OK;
            allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        if (strm.next_out) {
            if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
                if (this.options.to === 'string') {
                    next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                    tail = strm.next_out - next_out_utf8;
                    utf8str = strings.buf2string(strm.output, next_out_utf8);
                    // move tail
                    strm.next_out = tail;
                    strm.avail_out = chunkSize - tail;
                    if (tail) utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                    this.onData(utf8str);
                } else this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
        }
        // When no more input data, we should check that internal inflate buffers
        // are flushed. The only way to do it when avail_out = 0 - run one more
        // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
        // Here we set flag to process this error properly.
        //
        // NOTE. Deflate does not return error in this case and does not needs such
        // logic.
        if (strm.avail_in === 0 && strm.avail_out === 0) allowBufError = true;
    }while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
    if (status === c.Z_STREAM_END) _mode = c.Z_FINISH;
    // Finalize on the last chunk.
    if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
    }
    // callback interim results if Z_SYNC_FLUSH.
    if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
    }
    return true;
};
/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/ Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
};
/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/ Inflate.prototype.onEnd = function(status) {
    // On success - join
    if (status === c.Z_OK) {
        if (this.options.to === 'string') // Glue & convert here, until we teach pako to send
        // utf8 aligned strings to onData
        this.result = this.chunks.join('');
        else this.result = utils.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
};
/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/ function inflate(input, options) {
    var inflator = new Inflate(options);
    inflator.push(input, true);
    // That will never happens, if you don't cheat with options :)
    if (inflator.err) throw inflator.msg || msg[inflator.err];
    return inflator.result;
}
/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/ function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate(input, options);
}
/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/ exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip = inflate;

},{"dd64f509a13f2ae4":"lgYJb","4c9b744bf1bb68c7":"9lGgI","a6a879671ada369a":"9m1XG","dbf920c388b193d4":"c09N4","a85d599be6e8296a":"3b6uW","2cb10505c6d74721":"i3gjN","e0b11c8ff712dfd":"apr1Y"}],"lgYJb":[function(require,module,exports,__globalThis) {
'use strict';
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
var utils = require("3693fcbb98dc8df0");
var adler32 = require("6ebe24dff7c86ec6");
var crc32 = require("733ae5de3dad536a");
var inflate_fast = require("d6c5d4935fa23026");
var inflate_table = require("f4fe87fcccdc3597");
var CODES = 0;
var LENS = 1;
var DISTS = 2;
/* Public constants ==========================================================*/ /* ===========================================================================*/ /* Allowed flush values; see deflate() and inflate() below for details */ //var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */ var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
//var Z_VERSION_ERROR = -6;
/* The deflate compression method */ var Z_DEFLATED = 8;
/* STATES ====================================================================*/ /* ===========================================================================*/ var HEAD = 1; /* i: waiting for magic header */ 
var FLAGS = 2; /* i: waiting for method and flags (gzip) */ 
var TIME = 3; /* i: waiting for modification time (gzip) */ 
var OS = 4; /* i: waiting for extra flags and operating system (gzip) */ 
var EXLEN = 5; /* i: waiting for extra length (gzip) */ 
var EXTRA = 6; /* i: waiting for extra bytes (gzip) */ 
var NAME = 7; /* i: waiting for end of file name (gzip) */ 
var COMMENT = 8; /* i: waiting for end of comment (gzip) */ 
var HCRC = 9; /* i: waiting for header crc (gzip) */ 
var DICTID = 10; /* i: waiting for dictionary check value */ 
var DICT = 11; /* waiting for inflateSetDictionary() call */ 
var TYPE = 12; /* i: waiting for type bits, including last-flag bit */ 
var TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */ 
var STORED = 14; /* i: waiting for stored size (length and complement) */ 
var COPY_ = 15; /* i/o: same as COPY below, but only first time in */ 
var COPY = 16; /* i/o: waiting for input or output to copy stored block */ 
var TABLE = 17; /* i: waiting for dynamic block table lengths */ 
var LENLENS = 18; /* i: waiting for code length code lengths */ 
var CODELENS = 19; /* i: waiting for length/lit and distance code lengths */ 
var LEN_ = 20; /* i: same as LEN below, but only first time in */ 
var LEN = 21; /* i: waiting for length/lit/eob code */ 
var LENEXT = 22; /* i: waiting for length extra bits */ 
var DIST = 23; /* i: waiting for distance code */ 
var DISTEXT = 24; /* i: waiting for distance extra bits */ 
var MATCH = 25; /* o: waiting for output space to copy string */ 
var LIT = 26; /* o: waiting for output space to write literal */ 
var CHECK = 27; /* i: waiting for 32-bit check value */ 
var LENGTH = 28; /* i: waiting for 32-bit length (gzip) */ 
var DONE = 29; /* finished check, done -- remain here until reset */ 
var BAD = 30; /* got a data error -- remain here until reset */ 
var MEM = 31; /* got an inflate() memory error -- remain here until reset */ 
var SYNC = 32; /* looking for synchronization bytes to restart inflate() */ 
/* ===========================================================================*/ var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);
var MAX_WBITS = 15;
/* 32K LZ77 window */ var DEF_WBITS = MAX_WBITS;
function zswap32(q) {
    return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
}
function InflateState() {
    this.mode = 0; /* current inflate mode */ 
    this.last = false; /* true if processing last block */ 
    this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */ 
    this.havedict = false; /* true if dictionary provided */ 
    this.flags = 0; /* gzip header method and flags (0 if zlib) */ 
    this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */ 
    this.check = 0; /* protected copy of check value */ 
    this.total = 0; /* protected copy of output count */ 
    // TODO: may be {}
    this.head = null; /* where to save gzip header information */ 
    /* sliding window */ this.wbits = 0; /* log base 2 of requested window size */ 
    this.wsize = 0; /* window size or zero if not using window */ 
    this.whave = 0; /* valid bytes in the window */ 
    this.wnext = 0; /* window write index */ 
    this.window = null; /* allocated sliding window, if needed */ 
    /* bit accumulator */ this.hold = 0; /* input bit accumulator */ 
    this.bits = 0; /* number of bits in "in" */ 
    /* for string and stored block copying */ this.length = 0; /* literal or length of data to copy */ 
    this.offset = 0; /* distance back to copy string from */ 
    /* for table and code decoding */ this.extra = 0; /* extra bits needed */ 
    /* fixed and dynamic code tables */ this.lencode = null; /* starting table for length/literal codes */ 
    this.distcode = null; /* starting table for distance codes */ 
    this.lenbits = 0; /* index bits for lencode */ 
    this.distbits = 0; /* index bits for distcode */ 
    /* dynamic table building */ this.ncode = 0; /* number of code length code lengths */ 
    this.nlen = 0; /* number of length code lengths */ 
    this.ndist = 0; /* number of distance code lengths */ 
    this.have = 0; /* number of code lengths in lens[] */ 
    this.next = null; /* next available space in codes[] */ 
    this.lens = new utils.Buf16(320); /* temporary storage for code lengths */ 
    this.work = new utils.Buf16(288); /* work area for code table building */ 
    /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */ //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
    this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */ 
    this.distdyn = null; /* dynamic table for distance codes (JS specific) */ 
    this.sane = 0; /* if false, allow invalid distance too far */ 
    this.back = 0; /* bits back of last unprocessed length/lit */ 
    this.was = 0; /* initial length of match */ 
}
function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) return Z_STREAM_ERROR;
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = ''; /*Z_NULL*/ 
    if (state.wrap) strm.adler = state.wrap & 1;
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null /*Z_NULL*/ ;
    state.hold = 0;
    state.bits = 0;
    //state.lencode = state.distcode = state.next = state.codes;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    //Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
}
function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) return Z_STREAM_ERROR;
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    /* get the state */ if (!strm || !strm.state) return Z_STREAM_ERROR;
    state = strm.state;
    /* extract wrap request from windowBits parameter */ if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
    } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) windowBits &= 15;
    }
    /* set number of window bits, free window if different */ if (windowBits && (windowBits < 8 || windowBits > 15)) return Z_STREAM_ERROR;
    if (state.window !== null && state.wbits !== windowBits) state.window = null;
    /* update state and reset the rest of it */ state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) return Z_STREAM_ERROR;
    //strm.msg = Z_NULL;                 /* in case we return an error */
    state = new InflateState();
    //if (state === Z_NULL) return Z_MEM_ERROR;
    //Tracev((stderr, "inflate: allocated\n"));
    strm.state = state;
    state.window = null /*Z_NULL*/ ;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) strm.state = null /*Z_NULL*/ ;
    return ret;
}
function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
}
/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */ var virgin = true;
var lenfix, distfix; // We have no pointers in JS, so keep tables separate
function fixedtables(state) {
    /* build fixed huffman tables if first call (may not be thread safe) */ if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        /* literal/length table */ sym = 0;
        while(sym < 144)state.lens[sym++] = 8;
        while(sym < 256)state.lens[sym++] = 9;
        while(sym < 280)state.lens[sym++] = 7;
        while(sym < 288)state.lens[sym++] = 8;
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
            bits: 9
        });
        /* distance table */ sym = 0;
        while(sym < 32)state.lens[sym++] = 5;
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
            bits: 5
        });
        /* do this just once */ virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
}
/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */ function updatewindow(strm, src, end, copy) {
    var dist;
    var state = strm.state;
    /* if it hasn't been done already, allocate space for the window */ if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
    }
    /* copy state->wsize or less output bytes into the circular window */ if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
    } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) dist = copy;
        //zmemcpy(state->window + state->wnext, end - copy, dist);
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
            //zmemcpy(state->window, end - copy, copy);
            utils.arraySet(state.window, src, end - copy, copy, 0);
            state.wnext = copy;
            state.whave = state.wsize;
        } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) state.wnext = 0;
            if (state.whave < state.wsize) state.whave += dist;
        }
    }
    return 0;
}
function inflate(strm, flush) {
    var state;
    var input, output; // input/output buffers
    var next; /* next input INDEX */ 
    var put; /* next output INDEX */ 
    var have, left; /* available input and output */ 
    var hold; /* bit buffer */ 
    var bits; /* bits in bit buffer */ 
    var _in, _out; /* save starting available input and output */ 
    var copy; /* number of stored or match bytes to copy */ 
    var from; /* where to copy match bytes from */ 
    var from_source;
    var here = 0; /* current decoding table entry */ 
    var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
    //var last;                   /* parent table entry */
    var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
    var len; /* length to copy for repeats, bits to drop */ 
    var ret; /* return code */ 
    var hbuf = new utils.Buf8(4); /* buffer for gzip header crc calculation */ 
    var opts;
    var n; // temporary var for NEED_BITS
    var order = /* permutation of code lengths */ [
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
    ];
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) return Z_STREAM_ERROR;
    state = strm.state;
    if (state.mode === TYPE) state.mode = TYPEDO;
     /* skip check */ 
    //--- LOAD() ---
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    //---
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave: for(;;)switch(state.mode){
        case HEAD:
            if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
            }
            //=== NEEDBITS(16);
            while(bits < 16){
                if (have === 0) break inf_leave;
                have--;
                hold += input[next++] << bits;
                bits += 8;
            }
            //===//
            if (state.wrap & 2 && hold === 0x8b1f) {
                state.check = 0 /*crc32(0L, Z_NULL, 0)*/ ;
                //=== CRC2(state.check, hold);
                hbuf[0] = hold & 0xff;
                hbuf[1] = hold >>> 8 & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
                //===//
                //=== INITBITS();
                hold = 0;
                bits = 0;
                //===//
                state.mode = FLAGS;
                break;
            }
            state.flags = 0; /* expect zlib header */ 
            if (state.head) state.head.done = false;
            if (!(state.wrap & 1) || /* check if zlib header allowed */ (((hold & 0xff) << 8) + (hold >> 8)) % 31) {
                strm.msg = 'incorrect header check';
                state.mode = BAD;
                break;
            }
            if ((hold & 0x0f) !== Z_DEFLATED) {
                strm.msg = 'unknown compression method';
                state.mode = BAD;
                break;
            }
            //--- DROPBITS(4) ---//
            hold >>>= 4;
            bits -= 4;
            //---//
            len = (hold & 0x0f) + 8;
            if (state.wbits === 0) state.wbits = len;
            else if (len > state.wbits) {
                strm.msg = 'invalid window size';
                state.mode = BAD;
                break;
            }
            state.dmax = 1 << len;
            //Tracev((stderr, "inflate:   zlib header ok\n"));
            strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;
            state.mode = hold & 0x200 ? DICTID : TYPE;
            //=== INITBITS();
            hold = 0;
            bits = 0;
            break;
        case FLAGS:
            //=== NEEDBITS(16); */
            while(bits < 16){
                if (have === 0) break inf_leave;
                have--;
                hold += input[next++] << bits;
                bits += 8;
            }
            //===//
            state.flags = hold;
            if ((state.flags & 0xff) !== Z_DEFLATED) {
                strm.msg = 'unknown compression method';
                state.mode = BAD;
                break;
            }
            if (state.flags & 0xe000) {
                strm.msg = 'unknown header flags set';
                state.mode = BAD;
                break;
            }
            if (state.head) state.head.text = hold >> 8 & 1;
            if (state.flags & 0x0200) {
                //=== CRC2(state.check, hold);
                hbuf[0] = hold & 0xff;
                hbuf[1] = hold >>> 8 & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
            //===//
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = TIME;
        /* falls through */ case TIME:
            //=== NEEDBITS(32); */
            while(bits < 32){
                if (have === 0) break inf_leave;
                have--;
                hold += input[next++] << bits;
                bits += 8;
            }
            //===//
            if (state.head) state.head.time = hold;
            if (state.flags & 0x0200) {
                //=== CRC4(state.check, hold)
                hbuf[0] = hold & 0xff;
                hbuf[1] = hold >>> 8 & 0xff;
                hbuf[2] = hold >>> 16 & 0xff;
                hbuf[3] = hold >>> 24 & 0xff;
                state.check = crc32(state.check, hbuf, 4, 0);
            //===
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = OS;
        /* falls through */ case OS:
            //=== NEEDBITS(16); */
            while(bits < 16){
                if (have === 0) break inf_leave;
                have--;
                hold += input[next++] << bits;
                bits += 8;
            }
            //===//
            if (state.head) {
                state.head.xflags = hold & 0xff;
                state.head.os = hold >> 8;
            }
            if (state.flags & 0x0200) {
                //=== CRC2(state.check, hold);
                hbuf[0] = hold & 0xff;
                hbuf[1] = hold >>> 8 & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
            //===//
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = EXLEN;
        /* falls through */ case EXLEN:
            if (state.flags & 0x0400) {
                //=== NEEDBITS(16); */
                while(bits < 16){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                //===//
                state.length = hold;
                if (state.head) state.head.extra_len = hold;
                if (state.flags & 0x0200) {
                    //=== CRC2(state.check, hold);
                    hbuf[0] = hold & 0xff;
                    hbuf[1] = hold >>> 8 & 0xff;
                    state.check = crc32(state.check, hbuf, 2, 0);
                //===//
                }
                //=== INITBITS();
                hold = 0;
                bits = 0;
            //===//
            } else if (state.head) state.head.extra = null /*Z_NULL*/ ;
            state.mode = EXTRA;
        /* falls through */ case EXTRA:
            if (state.flags & 0x0400) {
                copy = state.length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state.head) {
                        len = state.head.extra_len - state.length;
                        if (!state.head.extra) // Use untyped array for more convenient processing later
                        state.head.extra = new Array(state.head.extra_len);
                        utils.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        copy, /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/ len);
                    //zmemcpy(state.head.extra + len, next,
                    //        len + copy > state.head.extra_max ?
                    //        state.head.extra_max - len : copy);
                    }
                    if (state.flags & 0x0200) state.check = crc32(state.check, input, copy, next);
                    have -= copy;
                    next += copy;
                    state.length -= copy;
                }
                if (state.length) break inf_leave;
            }
            state.length = 0;
            state.mode = NAME;
        /* falls through */ case NAME:
            if (state.flags & 0x0800) {
                if (have === 0) break inf_leave;
                copy = 0;
                do {
                    // TODO: 2 or 1 bytes?
                    len = input[next + copy++];
                    /* use constant limit because in js we should not preallocate memory */ if (state.head && len && state.length < 65536 /*state.head.name_max*/ ) state.head.name += String.fromCharCode(len);
                }while (len && copy < have);
                if (state.flags & 0x0200) state.check = crc32(state.check, input, copy, next);
                have -= copy;
                next += copy;
                if (len) break inf_leave;
            } else if (state.head) state.head.name = null;
            state.length = 0;
            state.mode = COMMENT;
        /* falls through */ case COMMENT:
            if (state.flags & 0x1000) {
                if (have === 0) break inf_leave;
                copy = 0;
                do {
                    len = input[next + copy++];
                    /* use constant limit because in js we should not preallocate memory */ if (state.head && len && state.length < 65536 /*state.head.comm_max*/ ) state.head.comment += String.fromCharCode(len);
                }while (len && copy < have);
                if (state.flags & 0x0200) state.check = crc32(state.check, input, copy, next);
                have -= copy;
                next += copy;
                if (len) break inf_leave;
            } else if (state.head) state.head.comment = null;
            state.mode = HCRC;
        /* falls through */ case HCRC:
            if (state.flags & 0x0200) {
                //=== NEEDBITS(16); */
                while(bits < 16){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                //===//
                if (hold !== (state.check & 0xffff)) {
                    strm.msg = 'header crc mismatch';
                    state.mode = BAD;
                    break;
                }
                //=== INITBITS();
                hold = 0;
                bits = 0;
            //===//
            }
            if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
        case DICTID:
            //=== NEEDBITS(32); */
            while(bits < 32){
                if (have === 0) break inf_leave;
                have--;
                hold += input[next++] << bits;
                bits += 8;
            }
            //===//
            strm.adler = state.check = zswap32(hold);
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = DICT;
        /* falls through */ case DICT:
            if (state.havedict === 0) {
                //--- RESTORE() ---
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                //---
                return Z_NEED_DICT;
            }
            strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;
            state.mode = TYPE;
        /* falls through */ case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) break inf_leave;
        /* falls through */ case TYPEDO:
            if (state.last) {
                //--- BYTEBITS() ---//
                hold >>>= bits & 7;
                bits -= bits & 7;
                //---//
                state.mode = CHECK;
                break;
            }
            //=== NEEDBITS(3); */
            while(bits < 3){
                if (have === 0) break inf_leave;
                have--;
                hold += input[next++] << bits;
                bits += 8;
            }
            //===//
            state.last = hold & 0x01 /*BITS(1)*/ ;
            //--- DROPBITS(1) ---//
            hold >>>= 1;
            bits -= 1;
            //---//
            switch(hold & 0x03){
                case 0:
                    /* stored block */ //Tracev((stderr, "inflate:     stored block%s\n",
                    //        state.last ? " (last)" : ""));
                    state.mode = STORED;
                    break;
                case 1:
                    /* fixed block */ fixedtables(state);
                    //Tracev((stderr, "inflate:     fixed codes block%s\n",
                    //        state.last ? " (last)" : ""));
                    state.mode = LEN_; /* decode codes */ 
                    if (flush === Z_TREES) {
                        //--- DROPBITS(2) ---//
                        hold >>>= 2;
                        bits -= 2;
                        break inf_leave;
                    }
                    break;
                case 2:
                    /* dynamic block */ //Tracev((stderr, "inflate:     dynamic codes block%s\n",
                    //        state.last ? " (last)" : ""));
                    state.mode = TABLE;
                    break;
                case 3:
                    strm.msg = 'invalid block type';
                    state.mode = BAD;
            }
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            break;
        case STORED:
            //--- BYTEBITS() ---// /* go to byte boundary */
            hold >>>= bits & 7;
            bits -= bits & 7;
            //---//
            //=== NEEDBITS(32); */
            while(bits < 32){
                if (have === 0) break inf_leave;
                have--;
                hold += input[next++] << bits;
                bits += 8;
            }
            //===//
            if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
                strm.msg = 'invalid stored block lengths';
                state.mode = BAD;
                break;
            }
            state.length = hold & 0xffff;
            //Tracev((stderr, "inflate:       stored length %u\n",
            //        state.length));
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = COPY_;
            if (flush === Z_TREES) break inf_leave;
        /* falls through */ case COPY_:
            state.mode = COPY;
        /* falls through */ case COPY:
            copy = state.length;
            if (copy) {
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy === 0) break inf_leave;
                //--- zmemcpy(put, next, copy); ---
                utils.arraySet(output, input, next, copy, put);
                //---//
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
            }
            //Tracev((stderr, "inflate:       stored end\n"));
            state.mode = TYPE;
            break;
        case TABLE:
            //=== NEEDBITS(14); */
            while(bits < 14){
                if (have === 0) break inf_leave;
                have--;
                hold += input[next++] << bits;
                bits += 8;
            }
            //===//
            state.nlen = (hold & 0x1f) + 257;
            //--- DROPBITS(5) ---//
            hold >>>= 5;
            bits -= 5;
            //---//
            state.ndist = (hold & 0x1f) + 1;
            //--- DROPBITS(5) ---//
            hold >>>= 5;
            bits -= 5;
            //---//
            state.ncode = (hold & 0x0f) + 4;
            //--- DROPBITS(4) ---//
            hold >>>= 4;
            bits -= 4;
            //---//
            //#ifndef PKZIP_BUG_WORKAROUND
            if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = 'too many length or distance symbols';
                state.mode = BAD;
                break;
            }
            //#endif
            //Tracev((stderr, "inflate:       table sizes ok\n"));
            state.have = 0;
            state.mode = LENLENS;
        /* falls through */ case LENLENS:
            while(state.have < state.ncode){
                //=== NEEDBITS(3);
                while(bits < 3){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                //===//
                state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
                //--- DROPBITS(3) ---//
                hold >>>= 3;
                bits -= 3;
            //---//
            }
            while(state.have < 19)state.lens[order[state.have++]] = 0;
            // We have separate tables & no pointers. 2 commented lines below not needed.
            //state.next = state.codes;
            //state.lencode = state.next;
            // Switch to use dynamic table
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {
                bits: state.lenbits
            };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
                strm.msg = 'invalid code lengths set';
                state.mode = BAD;
                break;
            }
            //Tracev((stderr, "inflate:       code lengths ok\n"));
            state.have = 0;
            state.mode = CODELENS;
        /* falls through */ case CODELENS:
            while(state.have < state.nlen + state.ndist){
                for(;;){
                    here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/ 
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 0xff;
                    here_val = here & 0xffff;
                    if (here_bits <= bits) break;
                    //--- PULLBYTE() ---//
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                //---//
                }
                if (here_val < 16) {
                    //--- DROPBITS(here.bits) ---//
                    hold >>>= here_bits;
                    bits -= here_bits;
                    //---//
                    state.lens[state.have++] = here_val;
                } else {
                    if (here_val === 16) {
                        //=== NEEDBITS(here.bits + 2);
                        n = here_bits + 2;
                        while(bits < n){
                            if (have === 0) break inf_leave;
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        //--- DROPBITS(here.bits) ---//
                        hold >>>= here_bits;
                        bits -= here_bits;
                        //---//
                        if (state.have === 0) {
                            strm.msg = 'invalid bit length repeat';
                            state.mode = BAD;
                            break;
                        }
                        len = state.lens[state.have - 1];
                        copy = 3 + (hold & 0x03); //BITS(2);
                        //--- DROPBITS(2) ---//
                        hold >>>= 2;
                        bits -= 2;
                    //---//
                    } else if (here_val === 17) {
                        //=== NEEDBITS(here.bits + 3);
                        n = here_bits + 3;
                        while(bits < n){
                            if (have === 0) break inf_leave;
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        //--- DROPBITS(here.bits) ---//
                        hold >>>= here_bits;
                        bits -= here_bits;
                        //---//
                        len = 0;
                        copy = 3 + (hold & 0x07); //BITS(3);
                        //--- DROPBITS(3) ---//
                        hold >>>= 3;
                        bits -= 3;
                    //---//
                    } else {
                        //=== NEEDBITS(here.bits + 7);
                        n = here_bits + 7;
                        while(bits < n){
                            if (have === 0) break inf_leave;
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        //--- DROPBITS(here.bits) ---//
                        hold >>>= here_bits;
                        bits -= here_bits;
                        //---//
                        len = 0;
                        copy = 11 + (hold & 0x7f); //BITS(7);
                        //--- DROPBITS(7) ---//
                        hold >>>= 7;
                        bits -= 7;
                    //---//
                    }
                    if (state.have + copy > state.nlen + state.ndist) {
                        strm.msg = 'invalid bit length repeat';
                        state.mode = BAD;
                        break;
                    }
                    while(copy--)state.lens[state.have++] = len;
                }
            }
            /* handle error breaks in while */ if (state.mode === BAD) break;
            /* check for end-of-block code (better have one) */ if (state.lens[256] === 0) {
                strm.msg = 'invalid code -- missing end-of-block';
                state.mode = BAD;
                break;
            }
            /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */ state.lenbits = 9;
            opts = {
                bits: state.lenbits
            };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            // We have separate tables & no pointers. 2 commented lines below not needed.
            // state.next_index = opts.table_index;
            state.lenbits = opts.bits;
            // state.lencode = state.next;
            if (ret) {
                strm.msg = 'invalid literal/lengths set';
                state.mode = BAD;
                break;
            }
            state.distbits = 6;
            //state.distcode.copy(state.codes);
            // Switch to use dynamic table
            state.distcode = state.distdyn;
            opts = {
                bits: state.distbits
            };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            // We have separate tables & no pointers. 2 commented lines below not needed.
            // state.next_index = opts.table_index;
            state.distbits = opts.bits;
            // state.distcode = state.next;
            if (ret) {
                strm.msg = 'invalid distances set';
                state.mode = BAD;
                break;
            }
            //Tracev((stderr, 'inflate:       codes ok\n'));
            state.mode = LEN_;
            if (flush === Z_TREES) break inf_leave;
        /* falls through */ case LEN_:
            state.mode = LEN;
        /* falls through */ case LEN:
            if (have >= 6 && left >= 258) {
                //--- RESTORE() ---
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                //---
                inflate_fast(strm, _out);
                //--- LOAD() ---
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                //---
                if (state.mode === TYPE) state.back = -1;
                break;
            }
            state.back = 0;
            for(;;){
                here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/ 
                here_bits = here >>> 24;
                here_op = here >>> 16 & 0xff;
                here_val = here & 0xffff;
                if (here_bits <= bits) break;
                //--- PULLBYTE() ---//
                if (have === 0) break inf_leave;
                have--;
                hold += input[next++] << bits;
                bits += 8;
            //---//
            }
            if (here_op && (here_op & 0xf0) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for(;;){
                    here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 0xff;
                    here_val = here & 0xffff;
                    if (last_bits + here_bits <= bits) break;
                    //--- PULLBYTE() ---//
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                //---//
                }
                //--- DROPBITS(last.bits) ---//
                hold >>>= last_bits;
                bits -= last_bits;
                //---//
                state.back += last_bits;
            }
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
                //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                //        "inflate:         literal '%c'\n" :
                //        "inflate:         literal 0x%02x\n", here.val));
                state.mode = LIT;
                break;
            }
            if (here_op & 32) {
                //Tracevv((stderr, "inflate:         end of block\n"));
                state.back = -1;
                state.mode = TYPE;
                break;
            }
            if (here_op & 64) {
                strm.msg = 'invalid literal/length code';
                state.mode = BAD;
                break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
        /* falls through */ case LENEXT:
            if (state.extra) {
                //=== NEEDBITS(state.extra);
                n = state.extra;
                while(bits < n){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                //===//
                state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/ ;
                //--- DROPBITS(state.extra) ---//
                hold >>>= state.extra;
                bits -= state.extra;
                //---//
                state.back += state.extra;
            }
            //Tracevv((stderr, "inflate:         length %u\n", state.length));
            state.was = state.length;
            state.mode = DIST;
        /* falls through */ case DIST:
            for(;;){
                here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/ 
                here_bits = here >>> 24;
                here_op = here >>> 16 & 0xff;
                here_val = here & 0xffff;
                if (here_bits <= bits) break;
                //--- PULLBYTE() ---//
                if (have === 0) break inf_leave;
                have--;
                hold += input[next++] << bits;
                bits += 8;
            //---//
            }
            if ((here_op & 0xf0) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for(;;){
                    here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 0xff;
                    here_val = here & 0xffff;
                    if (last_bits + here_bits <= bits) break;
                    //--- PULLBYTE() ---//
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                //---//
                }
                //--- DROPBITS(last.bits) ---//
                hold >>>= last_bits;
                bits -= last_bits;
                //---//
                state.back += last_bits;
            }
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.back += here_bits;
            if (here_op & 64) {
                strm.msg = 'invalid distance code';
                state.mode = BAD;
                break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
        /* falls through */ case DISTEXT:
            if (state.extra) {
                //=== NEEDBITS(state.extra);
                n = state.extra;
                while(bits < n){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                //===//
                state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/ ;
                //--- DROPBITS(state.extra) ---//
                hold >>>= state.extra;
                bits -= state.extra;
                //---//
                state.back += state.extra;
            }
            //#ifdef INFLATE_STRICT
            if (state.offset > state.dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break;
            }
            //#endif
            //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
            state.mode = MATCH;
        /* falls through */ case MATCH:
            if (left === 0) break inf_leave;
            copy = _out - left;
            if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                    if (state.sane) {
                        strm.msg = 'invalid distance too far back';
                        state.mode = BAD;
                        break;
                    }
                }
                if (copy > state.wnext) {
                    copy -= state.wnext;
                    from = state.wsize - copy;
                } else from = state.wnext - copy;
                if (copy > state.length) copy = state.length;
                from_source = state.window;
            } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
            }
            if (copy > left) copy = left;
            left -= copy;
            state.length -= copy;
            do output[put++] = from_source[from++];
            while (--copy);
            if (state.length === 0) state.mode = LEN;
            break;
        case LIT:
            if (left === 0) break inf_leave;
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
        case CHECK:
            if (state.wrap) {
                //=== NEEDBITS(32);
                while(bits < 32){
                    if (have === 0) break inf_leave;
                    have--;
                    // Use '|' instead of '+' to make sure that result is signed
                    hold |= input[next++] << bits;
                    bits += 8;
                }
                //===//
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/ state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                _out = left;
                // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                    strm.msg = 'incorrect data check';
                    state.mode = BAD;
                    break;
                }
                //=== INITBITS();
                hold = 0;
                bits = 0;
            //===//
            //Tracev((stderr, "inflate:   check matches trailer\n"));
            }
            state.mode = LENGTH;
        /* falls through */ case LENGTH:
            if (state.wrap && state.flags) {
                //=== NEEDBITS(32);
                while(bits < 32){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                //===//
                if (hold !== (state.total & 0xffffffff)) {
                    strm.msg = 'incorrect length check';
                    state.mode = BAD;
                    break;
                }
                //=== INITBITS();
                hold = 0;
                bits = 0;
            //===//
            //Tracev((stderr, "inflate:   length matches trailer\n"));
            }
            state.mode = DONE;
        /* falls through */ case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
        case MEM:
            return Z_MEM_ERROR;
        case SYNC:
        /* falls through */ default:
            return Z_STREAM_ERROR;
    }
    // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"
    /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */ //--- RESTORE() ---
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    //---
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR;
        }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/ state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) ret = Z_BUF_ERROR;
    return ret;
}
function inflateEnd(strm) {
    if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/ ) return Z_STREAM_ERROR;
    var state = strm.state;
    if (state.window) state.window = null;
    strm.state = null;
    return Z_OK;
}
function inflateGetHeader(strm, head) {
    var state;
    /* check state */ if (!strm || !strm.state) return Z_STREAM_ERROR;
    state = strm.state;
    if ((state.wrap & 2) === 0) return Z_STREAM_ERROR;
    /* save header structure */ state.head = head;
    head.done = false;
    return Z_OK;
}
function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    /* check state */ if (!strm /* == Z_NULL */  || !strm.state /* == Z_NULL */ ) return Z_STREAM_ERROR;
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) return Z_STREAM_ERROR;
    /* check for correct dictionary identifier */ if (state.mode === DICT) {
        dictid = 1; /* adler32(0, null, 0)*/ 
        /* dictid = adler32(dictid, dictionary, dictLength); */ dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) return Z_DATA_ERROR;
    }
    /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */ ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
    }
    state.havedict = 1;
    // Tracev((stderr, "inflate:   dictionary set\n"));
    return Z_OK;
}
exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)'; /* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/ 

},{"3693fcbb98dc8df0":"9lGgI","6ebe24dff7c86ec6":"eOyJn","733ae5de3dad536a":"P1ij2","d6c5d4935fa23026":"hHnBj","f4fe87fcccdc3597":"3D17N"}],"hHnBj":[function(require,module,exports,__globalThis) {
'use strict';
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// See state defs from inflate.js
var BAD = 30; /* got a data error -- remain here until reset */ 
var TYPE = 12; /* i: waiting for type bits, including last-flag bit */ 
/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */ module.exports = function inflate_fast(strm, start) {
    var state;
    var _in; /* local strm.input */ 
    var last; /* have enough input while in < last */ 
    var _out; /* local strm.output */ 
    var beg; /* inflate()'s initial strm.output */ 
    var end; /* while out < end, enough space available */ 
    //#ifdef INFLATE_STRICT
    var dmax; /* maximum distance from zlib header */ 
    //#endif
    var wsize; /* window size or zero if not using window */ 
    var whave; /* valid bytes in the window */ 
    var wnext; /* window write index */ 
    // Use `s_window` instead `window`, avoid conflict with instrumentation tools
    var s_window; /* allocated sliding window, if wsize != 0 */ 
    var hold; /* local strm.hold */ 
    var bits; /* local strm.bits */ 
    var lcode; /* local strm.lencode */ 
    var dcode; /* local strm.distcode */ 
    var lmask; /* mask for first level of length codes */ 
    var dmask; /* mask for first level of distance codes */ 
    var here; /* retrieved table entry */ 
    var op; /* code bits, operation, extra bits, or */ 
    /*  window position, window bytes to copy */ var len; /* match length, unused bytes */ 
    var dist; /* match distance */ 
    var from; /* where to copy match from */ 
    var from_source;
    var input, output; // JS specific, because we have no pointers
    /* copy state to local variables */ state = strm.state;
    //here = state.here;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    //#ifdef INFLATE_STRICT
    dmax = state.dmax;
    //#endif
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    /* decode literals and length/distances until end-of-block or not enough
     input data or output space */ top: do {
        if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
        }
        here = lcode[hold & lmask];
        dolen: for(;;){
            op = here >>> 24 /*here.bits*/ ;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 0xff /*here.op*/ ;
            if (op === 0) //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
            //        "inflate:         literal '%c'\n" :
            //        "inflate:         literal 0x%02x\n", here.val));
            output[_out++] = here & 0xffff /*here.val*/ ;
            else if (op & 16) {
                len = here & 0xffff /*here.val*/ ;
                op &= 15; /* number of extra bits */ 
                if (op) {
                    if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                }
                //Tracevv((stderr, "inflate:         length %u\n", len));
                if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                }
                here = dcode[hold & dmask];
                dodist: for(;;){
                    op = here >>> 24 /*here.bits*/ ;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 0xff /*here.op*/ ;
                    if (op & 16) {
                        dist = here & 0xffff /*here.val*/ ;
                        op &= 15; /* number of extra bits */ 
                        if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            if (bits < op) {
                                hold += input[_in++] << bits;
                                bits += 8;
                            }
                        }
                        dist += hold & (1 << op) - 1;
                        //#ifdef INFLATE_STRICT
                        if (dist > dmax) {
                            strm.msg = 'invalid distance too far back';
                            state.mode = BAD;
                            break top;
                        }
                        //#endif
                        hold >>>= op;
                        bits -= op;
                        //Tracevv((stderr, "inflate:         distance %u\n", dist));
                        op = _out - beg; /* max distance in output */ 
                        if (dist > op) {
                            op = dist - op; /* distance back in window */ 
                            if (op > whave) {
                                if (state.sane) {
                                    strm.msg = 'invalid distance too far back';
                                    state.mode = BAD;
                                    break top;
                                }
                            }
                            from = 0; // window index
                            from_source = s_window;
                            if (wnext === 0) {
                                from += wsize - op;
                                if (op < len) {
                                    len -= op;
                                    do output[_out++] = s_window[from++];
                                    while (--op);
                                    from = _out - dist; /* rest from output */ 
                                    from_source = output;
                                }
                            } else if (wnext < op) {
                                from += wsize + wnext - op;
                                op -= wnext;
                                if (op < len) {
                                    len -= op;
                                    do output[_out++] = s_window[from++];
                                    while (--op);
                                    from = 0;
                                    if (wnext < len) {
                                        op = wnext;
                                        len -= op;
                                        do output[_out++] = s_window[from++];
                                        while (--op);
                                        from = _out - dist; /* rest from output */ 
                                        from_source = output;
                                    }
                                }
                            } else {
                                from += wnext - op;
                                if (op < len) {
                                    len -= op;
                                    do output[_out++] = s_window[from++];
                                    while (--op);
                                    from = _out - dist; /* rest from output */ 
                                    from_source = output;
                                }
                            }
                            while(len > 2){
                                output[_out++] = from_source[from++];
                                output[_out++] = from_source[from++];
                                output[_out++] = from_source[from++];
                                len -= 3;
                            }
                            if (len) {
                                output[_out++] = from_source[from++];
                                if (len > 1) output[_out++] = from_source[from++];
                            }
                        } else {
                            from = _out - dist; /* copy direct from output */ 
                            do {
                                output[_out++] = output[from++];
                                output[_out++] = output[from++];
                                output[_out++] = output[from++];
                                len -= 3;
                            }while (len > 2);
                            if (len) {
                                output[_out++] = output[from++];
                                if (len > 1) output[_out++] = output[from++];
                            }
                        }
                    } else if ((op & 64) === 0) {
                        here = dcode[(here & 0xffff) + (hold & (1 << op) - 1)];
                        continue dodist;
                    } else {
                        strm.msg = 'invalid distance code';
                        state.mode = BAD;
                        break top;
                    }
                    break; // need to emulate goto via "continue"
                }
            } else if ((op & 64) === 0) {
                here = lcode[(here & 0xffff) + (hold & (1 << op) - 1)];
                continue dolen;
            } else if (op & 32) {
                //Tracevv((stderr, "inflate:         end of block\n"));
                state.mode = TYPE;
                break top;
            } else {
                strm.msg = 'invalid literal/length code';
                state.mode = BAD;
                break top;
            }
            break; // need to emulate goto via "continue"
        }
    }while (_in < last && _out < end);
    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */ len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    /* update state and return */ strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
};

},{}],"3D17N":[function(require,module,exports,__globalThis) {
'use strict';
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
var utils = require("11b3fa99ba8f3902");
var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var lbase = [
    /* Length codes 257..285 base */ 3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
];
var lext = [
    /* Length codes 257..285 extra */ 16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
];
var dbase = [
    /* Distance codes 0..29 base */ 1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
];
var dext = [
    /* Distance codes 0..29 extra */ 16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
];
module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits;
    //here = opts.here; /* table entry for duplication */
    var len = 0; /* a code's length in bits */ 
    var sym = 0; /* index of code symbols */ 
    var min = 0, max = 0; /* minimum and maximum code lengths */ 
    var root = 0; /* number of index bits for root table */ 
    var curr = 0; /* number of index bits for current table */ 
    var drop = 0; /* code bits to drop for sub-table */ 
    var left = 0; /* number of prefix codes available */ 
    var used = 0; /* code entries in table used */ 
    var huff = 0; /* Huffman code */ 
    var incr; /* for incrementing code, index */ 
    var fill; /* index for replicating entries */ 
    var low; /* low bits for current root entry */ 
    var mask; /* mask for low root bits */ 
    var next; /* next available space in table */ 
    var base = null; /* base value table to use */ 
    var base_index = 0;
    //  var shoextra;    /* extra bits table to use */
    var end; /* use base and extra for symbol > end */ 
    var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
    var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */ /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */ for(len = 0; len <= MAXBITS; len++)count[len] = 0;
    for(sym = 0; sym < codes; sym++)count[lens[lens_index + sym]]++;
    /* bound code lengths, force root to be within code lengths */ root = bits;
    for(max = MAXBITS; max >= 1; max--){
        if (count[max] !== 0) break;
    }
    if (root > max) root = max;
    if (max === 0) {
        //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
        //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
        //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
        table[table_index++] = 20971520;
        //table.op[opts.table_index] = 64;
        //table.bits[opts.table_index] = 1;
        //table.val[opts.table_index++] = 0;
        table[table_index++] = 20971520;
        opts.bits = 1;
        return 0; /* no symbols, but wait for decoding to report error */ 
    }
    for(min = 1; min < max; min++){
        if (count[min] !== 0) break;
    }
    if (root < min) root = min;
    /* check for an over-subscribed or incomplete set of lengths */ left = 1;
    for(len = 1; len <= MAXBITS; len++){
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;
         /* over-subscribed */ 
    }
    if (left > 0 && (type === CODES || max !== 1)) return -1; /* incomplete set */ 
    /* generate offsets into symbol table for each length for sorting */ offs[1] = 0;
    for(len = 1; len < MAXBITS; len++)offs[len + 1] = offs[len] + count[len];
    /* sort symbols by length, by symbol order within each length */ for(sym = 0; sym < codes; sym++)if (lens[lens_index + sym] !== 0) work[offs[lens[lens_index + sym]]++] = sym;
    /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */ /* set up for code type */ // poor man optimization - use if-else instead of switch,
    // to avoid deopts in old v8
    if (type === CODES) {
        base = extra = work; /* dummy value--not used */ 
        end = 19;
    } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
    } else {
        base = dbase;
        extra = dext;
        end = -1;
    }
    /* initialize opts for loop */ huff = 0; /* starting code */ 
    sym = 0; /* starting code symbol */ 
    len = min; /* starting code length */ 
    next = table_index; /* current table to fill in */ 
    curr = root; /* current table index bits */ 
    drop = 0; /* current bits to drop from code for index */ 
    low = -1; /* trigger new sub-table when len > root */ 
    used = 1 << root; /* use root table entries */ 
    mask = used - 1; /* mask for comparing low */ 
    /* check available table space */ if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) return 1;
    /* process all codes and make table entries */ for(;;){
        /* create table entry */ here_bits = len - drop;
        if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
        } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]];
        } else {
            here_op = 96; /* end of block */ 
            here_val = 0;
        }
        /* replicate for those indices with low len bits equal to huff */ incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill; /* save offset to next table */ 
        do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        }while (fill !== 0);
        /* backwards increment the len-bit code huff */ incr = 1 << len - 1;
        while(huff & incr)incr >>= 1;
        if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
        } else huff = 0;
        /* go to next symbol, update count, len */ sym++;
        if (--count[len] === 0) {
            if (len === max) break;
            len = lens[lens_index + work[sym]];
        }
        /* create new sub-table if needed */ if (len > root && (huff & mask) !== low) {
            /* if first time, transition to sub-tables */ if (drop === 0) drop = root;
            /* increment past last table */ next += min; /* here min is 1 << curr */ 
            /* determine length of next table */ curr = len - drop;
            left = 1 << curr;
            while(curr + drop < max){
                left -= count[curr + drop];
                if (left <= 0) break;
                curr++;
                left <<= 1;
            }
            /* check for enough space */ used += 1 << curr;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) return 1;
            /* point entry in root table to sub-table */ low = huff & mask;
            /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/ table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
    }
    /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */ if (huff !== 0) //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 4194304;
    /* set return parameters */ //opts.table_index += used;
    opts.bits = root;
    return 0;
};

},{"11b3fa99ba8f3902":"9lGgI"}],"c09N4":[function(require,module,exports,__globalThis) {
'use strict';
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
module.exports = {
    /* Allowed flush values; see deflate() and inflate() below for details */ Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */ Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */ Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */ Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */ Z_DEFLATED: 8
};

},{}],"apr1Y":[function(require,module,exports,__globalThis) {
'use strict';
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
function GZheader() {
    /* true if compressed data believed to be text */ this.text = 0;
    /* modification time */ this.time = 0;
    /* extra flags (not used when writing a gzip file) */ this.xflags = 0;
    /* operating system */ this.os = 0;
    /* pointer to extra field or Z_NULL if none */ this.extra = null;
    /* extra field length (valid if extra != Z_NULL) */ this.extra_len = 0; // Actually, we don't need it in JS,
    // but leave for few code modifications
    //
    // Setup limits is not necessary because in js we should not preallocate memory
    // for inflate use constant limit in 65536 bytes
    //
    /* space at extra (only when reading header) */ // this.extra_max  = 0;
    /* pointer to zero-terminated file name or Z_NULL */ this.name = '';
    /* space at name (only when reading header) */ // this.name_max   = 0;
    /* pointer to zero-terminated comment or Z_NULL */ this.comment = '';
    /* space at comment (only when reading header) */ // this.comm_max   = 0;
    /* true if there was or will be a header crc */ this.hcrc = 0;
    /* true when done reading gzip header (not used when writing a gzip file) */ this.done = false;
}
module.exports = GZheader;

},{}],"lWtyz":[function(require,module,exports,__globalThis) {
/* 
 * By Nicholas Sherlock <n.sherlock@gmail.com>
 * 
 * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>AdobeColorTable);
var _arrayDataStreamJs = require("./ArrayDataStream.js");
var _arrayDataStreamJsDefault = parcelHelpers.interopDefault(_arrayDataStreamJs);
var ACO_COLORSPACE_RGB = 0, ACO_COLORSPACE_HSB = 1, ACO_COLORSPACE_CMYK = 2, ACO_COLORSPACE_LAB = 7, ACO_COLORSPACE_GRAYSCALE = 8;
function AdobeColorTable() {}
/**
 * Read an .aco (Adobe COlor) swatches file and return an array of RGB colors.
 * 
 * Supports version 1 palettes, only RGB format.
 * 
 * @param {Uint8Array} input - The .aco file contents
 * @return {?Object[]} An array of colours, or null if the file was not supported.
 */ AdobeColorTable.prototype.read = function(input) {
    if (input == null) return null;
    var stream = new (0, _arrayDataStreamJsDefault.default)(new Uint8Array(input)), version, count, result = [];
    version = stream.readU16BE();
    if (version != 1) return null;
    count = stream.readU16BE();
    for(var i = 0; i < count; i++){
        var colorSpace = stream.readU16BE();
        if (colorSpace != ACO_COLORSPACE_RGB) continue; // Drop unsupported colours silently
        // Scale back down from 16-bit to 8-bit
        var r = stream.readU16BE() * 255 / 65535, g = stream.readU16BE() * 255 / 65535, b = stream.readU16BE() * 255 / 65535;
        stream.readU16BE(); // third value unused
        result.push(r << 16 | g << 8 | b);
    }
    return result;
};
/**
 * Write an .aco (Adobe COlor) swatches file of the given array of RGB colours (colors are integers with the
 * blue channel in the least-significant position).
 */ AdobeColorTable.prototype.write = function(colours) {
    var buffer = new Uint8Array(4 + colours.length * 10), stream = new (0, _arrayDataStreamJsDefault.default)(buffer);
    stream.writeU16BE(1); // Version 1
    stream.writeU16BE(colours.length); // Number of colours
    for(var i = 0; i < colours.length; i++){
        var colour = colours[i];
        stream.writeU16BE(ACO_COLORSPACE_RGB);
        // Scale up colours to 16-bits (65535/255 = 257)
        stream.writeU16BE((colour >> 16 & 0xFF) * 257);
        stream.writeU16BE((colour >> 8 & 0xFF) * 257);
        stream.writeU16BE((colour & 0xFF) * 257);
        stream.writeU16BE(0);
    }
    return stream.getAsDataArray();
};

},{"./ArrayDataStream.js":"6f1Ke","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aVkzv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * We generally can't do much with binary strings because various methods will try to UTF-8 mangle them.
 * This function converts such a string to a Uint8Array instead.
 */ parcelHelpers.export(exports, "binaryStringToByteArray", ()=>binaryStringToByteArray);
parcelHelpers.export(exports, "default", ()=>CPResourceSaver);
var _cpchibiFileJs = require("./CPChibiFile.js");
var _adobeColorTableJs = require("../util/AdobeColorTable.js");
var _adobeColorTableJsDefault = parcelHelpers.interopDefault(_adobeColorTableJs);
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
var _fileSaver = require("file-saver");
var _fileSaverDefault = parcelHelpers.interopDefault(_fileSaver);
var _langJs = require("../languages/lang.js");
function binaryStringToByteArray(s) {
    var result = new Uint8Array(s.length);
    for(var i = 0; i < s.length; i++)result[i] = s.charCodeAt(i);
    return result;
}
function CPResourceSaver(options) {
    var that = this, cancelled = false;
    options.rotation = options.rotation || 0;
    function reportProgress(progress) {
        if (progress === null) that.emitEvent("savingProgress", [
            1.0,
            (0, _langJs._)("Saving drawing...")
        ]);
        else that.emitEvent("savingProgress", [
            progress,
            (0, _langJs._)("Saving drawing...") + " (" + Math.round(progress * 100) + "%)"
        ]);
    }
    function reportFatal(serverMessage) {
        that.emitEvent("savingFailure", [
            serverMessage
        ]);
    }
    async function postDrawing(formData) {
        // FormDataサイズを取得してチェック
        try {
            const size = await getFormDataSize(formData);
            const total_size = `${(size / 1024 / 1024).toFixed(3)}MB`;
            const limit_size = `${options.post_max_size}MB`;
            console.log("Total size of FormData:", total_size);
            console.log("post_max_size:", limit_size);
            if (options && options.post_max_size && size && !isNaN(size) && size > options.post_max_size * 1048576) {
                reportFatal(`${(0, _langJs._)("The file size exceeds the server limit.")}\n${(0, _langJs._)("Limit size")}:${limit_size}\n${(0, _langJs._)("Current size")}:${total_size}`);
                return; // サイズ超過の場合は中断
            } else console.log((0, _langJs._)("The total size of FormData is within the acceptable range."));
        } catch (error) {
            console.error("Error details:", error);
            reportFatal("An error occurred in the getFormDataSize function.");
            return;
        }
        var requestOptions = {
            method: "POST",
            mode: "same-origin",
            headers: {
                "X-Requested-With": "chickenpaint"
            },
            body: formData
        };
        reportProgress(0.5);
        // リクエストを送信
        fetch(options.url, requestOptions).then((response)=>{
            if (!response.ok) {
                let httpErrorMessag = "";
                switch(response.status){
                    case 400:
                        httpErrorMessag = "Bad Request";
                        break;
                    case 401:
                        httpErrorMessag = "Unauthorized";
                        break;
                    case 403:
                        httpErrorMessag = "Forbidden";
                        break;
                    case 404:
                        httpErrorMessag = "Not Found";
                        break;
                    case 500:
                        httpErrorMessag = "Internal Server Error";
                        break;
                    case 502:
                        httpErrorMessag = "Bad Gateway";
                        break;
                    case 503:
                        httpErrorMessag = "Service Unavailable";
                        break;
                    default:
                        httpErrorMessag = "Unknown Error";
                        break;
                }
                throw new Error(`${(0, _langJs._)("Network response was not OK")} ( ${(0, _langJs._)("HTTP status code")} ${response.status} : ${httpErrorMessag} )`);
            }
            return response.text();
        }).then((responseText)=>{
            if (/^CHIBIOK/.test(responseText)) {
                reportProgress(1.0);
                that.emitEvent("savingComplete");
            } else reportFatal(responseText);
        }).catch((error)=>{
            reportFatal(error.message);
        });
    }
    /**
     * Calculates the total size of a FormData object in bytes.
     * This function iterates over each entry in the FormData object,
     * converting string values to Blobs to measure their size consistently.
     * Blob entries are used directly. All entries are then combined into a single Blob,
     * whose size is returned as the total FormData size.
     *
     * Note: This function is asynchronous to ensure compatibility across
     * all environments where Blob size calculation might be non-blocking.
     *
     * @param {FormData} formData - The FormData object containing data to be measured.
     * @returns {Promise<number>} The total size of the FormData data in bytes.
     */ async function getFormDataSize(formData) {
        if (!options.post_max_size) return;
        const entries = Array.from(formData.entries());
        const blobs = entries.map(([key, value])=>{
            if (typeof value === "string") return new Blob([
                `${key}=${value}`
            ]);
            else return value;
        });
        const totalBlob = new Blob(blobs);
        return totalBlob.size;
    }
    // 	function postDrawing(formData) {
    //     var
    //         xhr = new XMLHttpRequest();
    //     xhr.upload.addEventListener("progress", function(evt) {
    //         var
    //             progress;
    //         if (evt.lengthComputable) {
    //             progress = evt.loaded / evt.total;
    //         } else {
    //             progress = null;
    //         }
    //         reportProgress(progress);
    //     }, false);
    //     xhr.addEventListener("load", function(evt) {
    //         reportProgress(1.0);
    //         if (this.status == 200 && /^CHIBIOK/.test(this.response)) {
    //             that.emitEvent("savingComplete");
    //         } else {
    //             reportFatal(this.response);
    //         }
    //     }, false);
    //     xhr.addEventListener("error", function() {
    //         reportFatal(this.response);
    //     }, false);
    //     reportProgress(0);
    //     xhr.open("POST", options.url, true);
    //     xhr.responseType = "text";
    //     xhr.send(formData);
    // }
    /**
     * Begin saving the data provided in the constructor. Returns immediately, and fires these events to report the
     * saving progress:
     *
     * savingProgress(progress) - Progress is [0.0 ... 1.0] and reports how much has uploaded so far, or null if the
     *                            total progress could not be determined.
     * savingFailure(error)     - When saving fails, along with a string error message to display to the user.
     * savingComplete()         - When saving completes succesfully
     */ this.save = function() {
        var flat, flatBlob, swatchesBlob;
        flat = binaryStringToByteArray(options.artwork.getFlatPNG(options.rotation));
        flatBlob = new Blob([
            flat
        ], {
            type: "image/png"
        });
        flat = null; // Don't need this any more
        var serializeLayers;
        if (options.artwork.isSimpleDrawing()) serializeLayers = Promise.resolve(null);
        else serializeLayers = (0, _cpchibiFileJs.save)(options.artwork);
        serializeLayers.then(function(chibiResult) {
            if (cancelled) {
                that.emitEvent("savingFailure");
                return;
            }
            if (options.swatches) {
                var aco = new (0, _adobeColorTableJsDefault.default)();
                swatchesBlob = new Blob([
                    aco.write(options.swatches)
                ], {
                    type: "application/octet-stream"
                });
            } else swatchesBlob = null;
            if (options.url) {
                let marker = "This marker ensures the upload wasn't truncated", formData = new FormData();
                formData.append("beginMarker", marker);
                formData.append("painter", "ChickenPaint v2.0");
                formData.append("picture", flatBlob);
                flatBlob = null;
                if (chibiResult) {
                    formData.append("chibifileFormat", chibiResult.version);
                    formData.append("chibifile", chibiResult.bytes);
                    chibiResult = null;
                    // Layers will need to be rotated upon opening
                    formData.append("rotation", "" + options.rotation);
                } else /*
                         * Because the image is a flat PNG, we rotate it before we saved it and it doesn't need further
                         * rotation upon opening.
                         */ formData.append("rotation", "0");
                if (swatchesBlob) {
                    formData.append("swatches", swatchesBlob);
                    swatchesBlob = null;
                }
                formData.append("endMarker", marker);
                postDrawing(formData);
            } else {
                const saveFilename = "oekaki_" + new Date().toISOString().split(".")[0].replace(/[^0-9]/g, "_");
                (0, _fileSaverDefault.default).saveAs(flatBlob, saveFilename + ".png");
                if (chibiResult) (0, _fileSaverDefault.default).saveAs(chibiResult.bytes, saveFilename + ".chi");
                if (swatchesBlob) (0, _fileSaverDefault.default).saveAs(swatchesBlob, saveFilename + ".aco");
            }
        }).catch(function(e) {
            that.emitEvent("savingFailure");
        });
    };
    this.cancel = function() {
        cancelled = true;
    };
}
CPResourceSaver.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
CPResourceSaver.prototype.constructor = CPResourceSaver;

},{"./CPChibiFile.js":"2P1CH","../util/AdobeColorTable.js":"lWtyz","wolfy87-eventemitter":"gPUo0","file-saver":"apCnQ","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"apCnQ":[function(require,module,exports,__globalThis) {
var global = arguments[3];
(function(a, b) {
    if ("function" == typeof define && define.amd) define([], b);
    else b();
})(this, function() {
    "use strict";
    function b(a, b) {
        return "undefined" == typeof b ? b = {
            autoBom: !1
        } : "object" != typeof b && (console.warn("Deprecated: Expected third argument to be a object"), b = {
            autoBom: !b
        }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob([
            "\uFEFF",
            a
        ], {
            type: a.type
        }) : a;
    }
    function c(a, b, c) {
        var d = new XMLHttpRequest;
        d.open("GET", a), d.responseType = "blob", d.onload = function() {
            g(d.response, b, c);
        }, d.onerror = function() {
            console.error("could not download file");
        }, d.send();
    }
    function d(a) {
        var b = new XMLHttpRequest;
        b.open("HEAD", a, !1);
        try {
            b.send();
        } catch (a) {}
        return 200 <= b.status && 299 >= b.status;
    }
    function e(a) {
        try {
            a.dispatchEvent(new MouseEvent("click"));
        } catch (c) {
            var b = document.createEvent("MouseEvents");
            b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
        }
    }
    var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {} : "download" in HTMLAnchorElement.prototype && !a ? function(b, g, h) {
        var i = f.URL || f.webkitURL, j = document.createElement("a");
        g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function() {
            i.revokeObjectURL(j.href);
        }, 4E4), setTimeout(function() {
            e(j);
        }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f, g, h) {
        if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);
        else if (d(f)) c(f, g, h);
        else {
            var i = document.createElement("a");
            i.href = f, i.target = "_blank", setTimeout(function() {
                e(i);
            });
        }
    } : function(b, d, e, g) {
        if (g = g || open("", "_blank"), g && (g.document.title = g.document.body.innerText = "downloading..."), "string" == typeof b) return c(b, d, e);
        var h = "application/octet-stream" === b.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((j || h && i || a) && "undefined" != typeof FileReader) {
            var k = new FileReader;
            k.onloadend = function() {
                var a = k.result;
                a = j ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), g ? g.location.href = a : location = a, g = null;
            }, k.readAsDataURL(b);
        } else {
            var l = f.URL || f.webkitURL, m = l.createObjectURL(b);
            g ? g.location = m : location.href = m, g = null, setTimeout(function() {
                l.revokeObjectURL(m);
            }, 4E4);
        }
    });
    f.saveAs = g.saveAs = g, module.exports = g;
});

},{}],"9myCU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setLanguage", ()=>setLanguage);
parcelHelpers.export(exports, "currentLanguage", ()=>currentLanguage);
parcelHelpers.export(exports, "guessLanguage", ()=>guessLanguage);
parcelHelpers.export(exports, "_", ()=>_);
var _enJson = require("./en.json");
var _jaJson = require("./ja.json");
const languages = {
    ja: _jaJson,
    en: _enJson
};
let currentLang = _enJson, currentLangName = "en";
function setLanguage(languageCode) {
    //取得した言語がja-jpなら、jaのみにする
    languageCode = languageCode.split(/[-_]/, 1)[0].toLowerCase();
    if (languageCode in languages) {
        currentLang = languages[languageCode];
        currentLangName = languageCode;
    } else {
        currentLang = _enJson;
        currentLangName = "en";
    }
}
function currentLanguage() {
    return currentLangName;
}
function guessLanguage() {
    try {
        if (typeof navigator !== "undefined") {
            let navLanguages = navigator.languages;
            if (!Array.isArray(navLanguages)) navLanguages = [
                navLanguages
            ];
            for (let language of navLanguages){
                let matches = /^(..)([-_].+)?$/.exec(language);
                if (matches) {
                    matches[1] = matches[1].toLowerCase();
                    if (matches[1] in languages) {
                        setLanguage(language);
                        return;
                    }
                    if (matches[1] === "en") {
                        setLanguage("en");
                        return;
                    }
                }
            }
        }
    } catch (e) {
        // We don't care about failures here because we're only doing this as a best-effort anyway
        console.error(e);
    }
}
function _(originalText) {
    if (originalText in currentLang) return currentLang[originalText];
    return originalText;
}

},{"./en.json":"3r2kA","./ja.json":"gA2MK","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3r2kA":[function(require,module,exports,__globalThis) {
module.exports = JSON.parse("{\"Dodge (tool)\":\"Dodge\",\"Burn (tool)\":\"Burn\",\"Color (picker)\":\"Color\",\"Color swatches (shorter)\":\"Swatches\"}");

},{}],"gA2MK":[function(require,module,exports,__globalThis) {
module.exports = JSON.parse('{"File":"\u30D5\u30A1\u30A4\u30EB","Save to my computer":"PC\u306B\u4FDD\u5B58","Post Oekaki":"\u753B\u50CF\u3092\u6295\u7A3F","Edit":"\u7DE8\u96C6","Undo":"\u53D6\u308A\u6D88\u3057","Redo":"\u3084\u308A\u76F4\u3057","Cut":"\u5207\u308A\u53D6\u308A","Copy":"\u30B3\u30D4\u30FC","Clear history":"\u5C65\u6B74\u6D88\u53BB","Copy merged":"\u7D50\u5408\u30B3\u30D4\u30FC","Paste":"\u8CBC\u308A\u4ED8\u3051","Select all":"\u3059\u3079\u3066\u9078\u629E","Deselect":"\u9078\u629E\u89E3\u9664","Transform":"\u5909\u5F62","Selection":"\u9078\u629E\u7BC4\u56F2","Constrain":"\u7E26\u6A2A\u6BD4\u3092\u7DAD\u6301","Layers":"\u30EC\u30A4\u30E4\u30FC","Duplicate":"\u8907\u88FD","Merge down":"\u4E0B\u306E\u30EC\u30A4\u30E4\u30FC\u3068\u7D50\u5408","Merge group":"\u30B0\u30EB\u30FC\u30D7\u7D50\u5408","Merge all layers":"\u5168\u30EC\u30A4\u30E4\u30FC\u7D50\u5408","Add Merged Layer":"\u7D50\u5408\u30EC\u30A4\u30E4\u30FC\u3092\u8FFD\u52A0","Add layer mask":"\u30EC\u30A4\u30E4\u30FC\u30DE\u30B9\u30AF\u8FFD\u52A0","Delete mask":"\u30EC\u30A4\u30E4\u30FC\u30DE\u30B9\u30AF\u524A\u9664","Delete layer mask":"\u30EC\u30A4\u30E4\u30FC\u30DE\u30B9\u30AF\u524A\u9664","Apply mask":"\u30EC\u30A4\u30E4\u30FC\u30DE\u30B9\u30AF\u9069\u7528","Apply layer mask":"\u30EC\u30A4\u30E4\u30FC\u30DE\u30B9\u30AF\u9069\u7528","Disable mask":"\u30EC\u30A4\u30E4\u30FC\u30DE\u30B9\u30AF\u7121\u52B9\u5316","Enable mask":"\u30EC\u30A4\u30E4\u30FC\u30DE\u30B9\u30AF\u6709\u52B9\u5316","Clip to the layer below":"\u4E0B\u306E\u30EC\u30A4\u30E4\u30FC\u3067\u30AF\u30EA\u30C3\u30D4\u30F3\u30B0","Unclip from the layer below":"\u30AF\u30EA\u30C3\u30D4\u30F3\u30B0\u89E3\u9664","Effects":"\u52B9\u679C","Clear":"\u6D88\u53BB","Fill":"\u5857\u308A\u6F70\u3057","Flip horizontal":"\u5DE6\u53F3\u53CD\u8EE2","Flip vertical":"\u4E0A\u4E0B\u53CD\u8EE2","Invert":"\u30CD\u30AC\u30DD\u30B8\u53CD\u8EE2","Convert brightness to opacity":"\u8F1D\u5EA6\u3092\u900F\u660E\u5EA6\u306B\u5909\u63DB","Box blur...":"\u307C\u304B\u3057","Box blur":"\u307C\u304B\u3057","Blur amount (pixels)":"\u307C\u304B\u3057\u91CF(\u30D4\u30AF\u30BB\u30EB\u5358\u4F4D)","Iterations (1-8, larger gives smoother blur)":"\u53CD\u5FA9(1-8,\u5927\u304D\u3044\u307B\u3069\u307C\u304B\u3057\u304C\u6ED1\u3089\u304B)","Monochromatic noise":"\u5358\u8272\u30CE\u30A4\u30BA","Color noise":"\u30AB\u30E9\u30FC\u30CE\u30A4\u30BA","View":"\u8868\u793A","Full-screen mode":"\u30D5\u30EB\u30B9\u30AF\u30EA\u30FC\u30F3\u30E2\u30FC\u30C9","Zoom in":"\u62E1\u5927","Zoom out":"\u7E2E\u5C0F","Zoom 100%":"100%","Reset Rotation":"\u56DE\u8EE2\u3092\u30EA\u30BB\u30C3\u30C8","Smooth-out zoomed canvas":"\u30BA\u30FC\u30E0\u3092\u306A\u3081\u3089\u304B\u306B\u8868\u793A\u3059\u308B","Show grid":"\u30B0\u30EA\u30C3\u30C9\u3092\u8868\u793A","Grid options...":"\u30B0\u30EA\u30C3\u30C9\u306E\u8A2D\u5B9A","Palettes":"\u30D1\u30EC\u30C3\u30C8","Rearrange":"\u521D\u671F\u5316","Toggle palettes":"\u8868\u793A\u975E\u8868\u793A\u5207\u308A\u66FF\u3048","Use old icons":"\u53E4\u3044\u30A2\u30A4\u30B3\u30F3","Show tool options":"\u30C4\u30FC\u30EB\u30AA\u30D7\u30B7\u30E7\u30F3","Show color":"\u30AB\u30E9\u30FC","Show layers":"\u30EC\u30A4\u30E4\u30FC","Show misc":"\u64CD\u4F5C","Show stroke":"\u30B9\u30C8\u30ED\u30FC\u30AF","Show swatches":"\u30AB\u30E9\u30FC\u30BB\u30C3\u30C8","Show textures":"\u30C6\u30AF\u30B9\u30C1\u30E3","Show tools":"\u30C4\u30FC\u30EB","Help":"\u30D8\u30EB\u30D7","Tablet support":"\u30BF\u30D6\u30EC\u30C3\u30C8\u30B5\u30DD\u30FC\u30C8","Shortcuts":"\u30B7\u30E7\u30FC\u30C8\u30AB\u30C3\u30C8","About":"ChickenPaint Be\u306B\u3064\u3044\u3066","Removes all undo/redo information to regain memory":"\u5C65\u6B74\u3092\u30AF\u30EA\u30A2\u3057\u3066\u30E1\u30E2\u30EA\u3092\u958B\u653E\u3057\u307E\u3059","Clears the selected area":"\u6D88\u53BB","Invert the image colors":"\u30CD\u30AC\u30DD\u30B8\u53CD\u8EE2","Blur effect":"\u307C\u304B\u3057\u30D5\u30A3\u30EB\u30BF","Fills the selection with noise":"\u5358\u8272\u30CE\u30A4\u30BA\u3067\u5857\u308A\u6F70\u3057","Fills the selection with colored noise":"\u30AB\u30E9\u30FC\u30CE\u30A4\u30BA\u3067\u5857\u308A\u6F70\u3057","Linear interpolation is used to give a smoothed looked to the picture when zoomed in":"\u753B\u50CF\u306E\u62E1\u5927\u6642\u306B\u88DC\u5B8C\u3057\u3066\u6ED1\u3089\u304B\u306B\u8868\u793A\u3057\u307E\u3059","Rearrange the palette windows":"\u30D1\u30EC\u30C3\u30C8\u3092\u518D\u914D\u7F6E","Hides or shows all palettes":"\u30D1\u30EC\u30C3\u30C8\u306E\u8868\u793A/\u975E\u8868\u793A","You\'re about to clear the current Undo/Redo history.\\nThis operation cannot be undone, are you sure you want to do that?":"\u30A2\u30F3\u30C9\u30A5\u30FB\u30EA\u30C9\u30A5\u306E\u5C65\u6B74\u3092\u6D88\u53BB\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u307E\u3059\u3002\\n\u3053\u306E\u64CD\u4F5C\u306F\u5143\u306B\u623B\u3059\u3053\u3068\u304C\u3067\u304D\u307E\u305B\u3093\u3002\u672C\u5F53\u306B\u5B9F\u884C\u3057\u307E\u3059\u304B?","Misc":"\u64CD\u4F5C","Round Pixelated":"\u5186\u30D4\u30AF\u30BB\u30EB","Round Hard Edge":"\u5186\u30CF\u30FC\u30C9\u30A8\u30C3\u30B8","Round Soft":"\u5186\u30BD\u30D5\u30C8","Square Pixelated":"\u89D2\u30D4\u30AF\u30BB\u30EB","Square Hard Edge":"\u89D2\u30CF\u30FC\u30C9\u30A8\u30C3\u30B8","Color (picker)":"\u30AB\u30E9\u30FC","Tool options":"\u30C4\u30FC\u30EB\u30AA\u30D7\u30B7\u30E7\u30F3","Brush size":"\u30D6\u30E9\u30B7\u30B5\u30A4\u30BA","Opacity":"\u4E0D\u900F\u660E\u5EA6","Color":"\u8272\u88DC\u5145","Blend":"\u6DF7\u8272","Spacing":"\u9593\u9694","Scattering":"\u6563\u4E71","Smoothing":"\u624B\u3076\u308C\u88DC\u6B63","Rotation":"\u89D2\u5EA6","Color swatches":"\u30AB\u30E9\u30FC\u30BB\u30C3\u30C8","Color swatches (shorter)":"\u30AB\u30E9\u30FC\u30BB\u30C3\u30C8","Remove":"\u524A\u9664","Replace with current color":"\u9078\u629E\u4E2D\u306E\u8272\u306B\u7F6E\u304D\u63DB\u3048","Save swatches to your computer...":"\u30AB\u30E9\u30FC\u30BB\u30C3\u30C8\u3092PC\u306B\u4FDD\u5B58","Load swatches from your computer...":"\u30AB\u30E9\u30FC\u30BB\u30C3\u30C8\u3092PC\u304B\u3089\u8AAD\u307F\u8FBC\u307F","Add the current brush color as a new swatch":"\u9078\u629E\u4E2D\u306E\u8272\u3092\u8FFD\u52A0","Sample all layers":"\u5168\u30EC\u30A4\u30E4\u30FC\u6DF7\u5408","Lock transparency":"\u900F\u660E\u90E8\u5206\u3092\u4FDD\u8B77","Textures":"\u30C6\u30AF\u30B9\u30C1\u30E3","Customize":"\u30AB\u30B9\u30BF\u30DE\u30A4\u30BA","Inverse":"\u30CD\u30AC\u30DD\u30B8\u53CD\u8EE2","Mirror":"\u5DE6\u53F3\u53CD\u8EE2","Brightness":"\u8F1D\u5EA6","Contrast":"\u30B3\u30F3\u30C8\u30E9\u30B9\u30C8","Reset":"\u30EA\u30BB\u30C3\u30C8","Layer blending mode":"\u5408\u6210\u30E2\u30FC\u30C9","Normal":"\u901A\u5E38","Multiply":"\u4E57\u7B97","Add":"\u52A0\u7B97","Screen":"\u30B9\u30AF\u30EA\u30FC\u30F3","Lighten":"\u6BD4\u8F03(\u660E)","Darken":"\u6BD4\u8F03(\u6697)","Subtract":"\u6E1B\u7B97","Dodge":"\u8986\u3044\u713C\u304D","Burn":"\u713C\u304D\u8FBC\u307F","Overlay":"\u30AA\u30FC\u30D0\u30FC\u30EC\u30A4","Hard Light":"\u30CF\u30FC\u30C9\u30E9\u30A4\u30C8","Soft Light":"\u30BD\u30D5\u30C8\u30E9\u30A4\u30C8","Vivid Light":"\u30D3\u30D3\u30C3\u30C9\u30E9\u30A4\u30C8","Linear Light":"\u30EA\u30CB\u30A2\u30E9\u30A4\u30C8","Pin Light":"\u30D4\u30F3\u30E9\u30A4\u30C8","Passthrough":"\u901A\u904E","Stroke":"\u30B9\u30C8\u30ED\u30FC\u30AF","Free-hand":"\u30D5\u30EA\u30FC\u30CF\u30F3\u30C9","Straight line":"\u76F4\u7DDA","Bezier curve":"Bz\uFF08\u30D9\u30B8\u30A7\uFF09\u66F2\u7DDA","Tools":"\u30C4\u30FC\u30EB","Marquee":"\u9078\u629E\u7BC4\u56F2","Move tool":"\u79FB\u52D5","Flood fill":"\u5857\u308A\u6F70\u3057","Gradient fill":"\u30B0\u30E9\u30C7\u30FC\u30B7\u30E7\u30F3","Color picker":"\u30B9\u30DD\u30A4\u30C8","Rotate canvas":"\u30AD\u30E3\u30F3\u30D0\u30B9\u306E\u56DE\u8EE2","Grab canvas":"\u30AD\u30E3\u30F3\u30D0\u30B9\u306E\u4F4D\u7F6E","Pencil":"\u925B\u7B46","Pen":"\u30DA\u30F3","Airbrush":"\u30A8\u30A2\u30D6\u30E9\u30B7","Waterpaint":"\u6C34\u5F69","Eraser":"\u6D88\u3057\u30B4\u30E0","Soft eraser":"\u8584\u6D88\u3057","Smudge":"\u6307\u5148","Blender":"\u6DF7\u8272","Dodge (tool)":"\u8986\u3044\u713C\u304D","Burn (tool)":"\u713C\u304D\u8FBC\u307F","Blur":"\u307C\u304B\u3057","Grid options":"\u30B0\u30EA\u30C3\u30C9\u306E\u8A2D\u5B9A","Grid size":"\u30B0\u30EA\u30C3\u30C9\u30B5\u30A4\u30BA","Rename...":"\u540D\u524D\u3092\u5909\u66F4","Add layer":"\u65B0\u898F\u30EC\u30A4\u30E4\u30FC","Delete layer":"\u30EC\u30A4\u30E4\u30FC\u524A\u9664","Add group":"\u65B0\u898F\u30B0\u30EB\u30FC\u30D7","Delete group":"\u30B0\u30EB\u30FC\u30D7\u524A\u9664","Add mask":"\u30EC\u30A4\u30E4\u30FC\u30DE\u30B9\u30AF\u8FFD\u52A0","Gradient":"\u30B0\u30E9\u30C7\u30FC\u30B7\u30E7\u30F3\u4F5C\u6210","Zoom and Rotate":"\u30BA\u30FC\u30E0\u3068\u56DE\u8EE2","Reset View":"\u8868\u793A\u3092\u521D\u671F\u5316","Transform style":"\u5909\u5F62\u30B9\u30BF\u30A4\u30EB","Apply transform":"\u5909\u5F62\u78BA\u5B9A","Complete transform":"\u5909\u5F62\u3092\u5B8C\u4E86","Undo transform":"\u53D6\u308A\u6D88\u3057","You need to finish transforming this layer before you can do that. What would you like to do with the transform?":"\u7D9A\u884C\u3059\u308B\u305F\u3081\u306B\u5909\u5F62\u3092\u5B8C\u4E86\u3057\u307E\u3059\u3002","Smooth":"\u30B9\u30E0\u30FC\u30BA","Sharp":"\u30B7\u30E3\u30FC\u30D7","Opacity: ":"\u4E0D\u900F\u660E\u5EA6:","Please enter a color in hex format":"16\u9032\u5F62\u5F0F\u3067\u8272\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\uFF08#xxxxxx\u306E\u5F62\uFF09","Cancel":"\u30AD\u30E3\u30F3\u30BB\u30EB","Ok":"OK","Okay":"OK","OK":"OK","Whoops! This layer is currently hidden":"\u975E\u8868\u793A\u30EC\u30A4\u30E4\u30FC\u3067\u3059\u3002","Whoops! This layer\'s opacity is currently 0%":"\u30EC\u30A4\u30E4\u30FC\u306E\u4E0D\u900F\u660E\u5EA6\u304C0%\u3067\u3059","Whoops! You can\'t draw on a group":"\u30B0\u30EB\u30FC\u30D7\u30D5\u30A9\u30EB\u30C0\u306B\u306F\u63CF\u3051\u307E\u305B\u3093","Whoops! All of the selected pixels are transparent!":"\u30EC\u30A4\u30E4\u30FC\u304C\u7A7A\u3067\u3059","Image":"\u753B\u50CF","Layer mask":"\u30EC\u30A4\u30E4\u30FC\u30DE\u30B9\u30AF","Sorry, you can\'t remove the last remaining layer in the drawing.":"\u6700\u5F8C\u306E1\u3064\u306A\u306E\u3067\u524A\u9664\u3067\u304D\u307E\u305B\u3093\u3002","Are you sure you want to send your drawing to the server and finish drawing now?":"\u753B\u50CF\u3092\u30B5\u30FC\u30D0\u30FC\u306B\u9001\u4FE1\u3057\u307E\u3059\u3002\u7D42\u4E86\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F","Your drawing has unsaved changes! Are you sure to want to navigate away?":"\u753B\u50CF\u306B\u672A\u4FDD\u5B58\u306E\u5909\u66F4\u304C\u3042\u308A\u307E\u3059\u3002\u7D42\u4E86\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F","Many of the menu options and painting tools have keyboard shortcuts which are written next to them or appear when you hover.":"\u5229\u7528\u53EF\u80FD\u306A\u30AD\u30FC\u30DC\u30FC\u30C9\u30B7\u30E7\u30FC\u30C8\u30AB\u30C3\u30C8\u306E\u3044\u304F\u3064\u304B\u306F\u30E1\u30CB\u30E5\u30FC\u306E\u6A2A\u3084\u30C4\u30FC\u30EB\u30C1\u30C3\u30D7\u306B\u8868\u793A\u3055\u308C\u3066\u3044\u307E\u3059\u3002","Here are some other shortcuts which are not as obvious!":"\u3053\u306E\u4E00\u89A7\u306F\u305D\u308C\u4EE5\u5916\u306E\u30B7\u30E7\u30FC\u30C8\u30AB\u30C3\u30C8\u3092\u307E\u3068\u3081\u305F\u3082\u306E\u3067\u3059\u3002","Right":"\u53F3","Left":"\u5DE6","Middle":"\u4E2D","or":"\u307E\u305F\u306F","Double click":"\u30C0\u30D6\u30EB\u30AF\u30EA\u30C3\u30AF","Color swatches palette":"\u30AB\u30E9\u30FC\u30BB\u30C3\u30C8","Use as the drawing color":"\u30D1\u30EC\u30C3\u30C8\u306E\u8272\u3092\u53D6\u5F97","Remove or replace a color swatch":"\u30D1\u30EC\u30C3\u30C8\u306E\u5909\u66F4\uFF65\u524A\u9664","Line drawing mode":"\u76F4\u7DDA\u30E2\u30FC\u30C9","Snap line to nearest 45 degrees":"45\xb0\u5358\u4F4D\u3067\u30B9\u30CA\u30C3\u30D7","Painting tools":"\u30C4\u30FC\u30EB","Change brush opacity":"\u30D6\u30E9\u30B7\u306E\u4E0D\u900F\u660E\u5EA6","Change brush size":"\u30D6\u30E9\u30B7\u30B5\u30A4\u30BA","Brush palette":"\u30D6\u30E9\u30B7\u30D1\u30EC\u30C3\u30C8","Adjust brush sliders more precisely":"\u30D6\u30E9\u30B7\u30B9\u30E9\u30A4\u30C0\u30FC\u3092\u3088\u308A\u7D30\u304B\u304F\u8ABF\u6574","Drawing canvas":"\u30AD\u30E3\u30F3\u30D0\u30B9","Move the canvas around":"\u30AD\u30E3\u30F3\u30D0\u30B9\u306E\u79FB\u52D5","Rotate the canvas":"\u30AD\u30E3\u30F3\u30D0\u30B9\u306E\u56DE\u8EE2","Zoom":"\u30BA\u30FC\u30E0","Zoom the canvas":"\u30AD\u30E3\u30F3\u30D0\u30B9\u306E\u62E1\u5927\u7E2E\u5C0F","Sample the color under the cursor":"\u30AD\u30E3\u30F3\u30D0\u30B9\u306E\u8272\u3092\u30B9\u30DD\u30A4\u30C8","Flip View Horizontal":"\u8868\u793A\u306E\u5DE6\u53F3\u53CD\u8EE2","Layers palette":"\u30EC\u30A4\u30E4\u30FC\u30D1\u30EC\u30C3\u30C8","Rename layer":"\u30EC\u30A4\u30E4\u30FC\u540D\u5909\u66F4","Toggle mask enable/disable":"\u30DE\u30B9\u30AF\u306E\u6709\u52B9/\u7121\u52B9\u5207\u308A\u66FF\u3048","Toggle mask View":"\u30DE\u30B9\u30AF\u306E\u8868\u793A/\u975E\u8868\u793A\u5207\u308A\u66FF\u3048","Save Oekaki":"\u4FDD\u5B58","Saving drawing...":"\u753B\u50CF\u3092\u4FDD\u5B58\u4E2D\u2026","Preparing your drawing to be saved, please wait...":"\u753B\u50CF\u3092\u4FDD\u5B58\u3059\u308B\u6E96\u5099\u3092\u3057\u3066\u3044\u307E\u3059\u3002\u3057\u3070\u3089\u304F\u304A\u5F85\u3061\u304F\u3060\u3055\u3044\u2026","Drawing saved!":"\u753B\u50CF\u3092\u4FDD\u5B58\u3057\u307E\u3057\u305F\uFF01","Your drawing has been saved, would you like to post it to the forum now?":"\u753B\u50CF\u306E\u4FDD\u5B58\u306B\u6210\u529F\u3057\u307E\u3057\u305F\u3002\u30D5\u30A9\u30FC\u30E9\u30E0\u3078\u6295\u7A3F\u3057\u307E\u3059\u304B\uFF1F","Yes, post it now":"\u306F\u3044\u3001\u6295\u7A3F\u3057\u307E\u3059","No, keep drawing":"\u307E\u3060\u63CF\u304D\u307E\u3059","No, quit and I\'ll finish it later":"\u30A2\u30D7\u30EA\u3092\u7D42\u4E86\u3057\u3066\u7D9A\u304D\u3092\u5F8C\u3067\u63CF\u304F","Your drawing has been saved, would you like to view it on the forum now?":"\u753B\u50CF\u306E\u4FDD\u5B58\u306B\u6210\u529F\u3057\u307E\u3057\u305F\u3002\u30D5\u30A9\u30FC\u30E9\u30E0\u3078\u6295\u7A3F\u3057\u307E\u3059\u304B\uFF1F","Yes, view the post":"\u306F\u3044\u3001\u6295\u7A3F\u3057\u307E\u3059\u3002","Your drawing has been saved, redirecting you to view your new post now...":"\u753B\u50CF\u306E\u4FDD\u5B58\u306B\u6210\u529F\u3057\u307E\u3057\u305F\u3002\u6295\u7A3F\u5148\u306B\u79FB\u52D5\u3057\u307E\u3059\u3002","Sorry, your drawing could not be saved, Please see the error message.":"\u753B\u50CF\u3092\u4FDD\u5B58\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\u30A8\u30E9\u30FC\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u3054\u78BA\u8A8D\u304F\u3060\u3055\u3044\u3002","Sorry, your drawing could not be saved, please try again later.":"\u753B\u50CF\u3092\u4FDD\u5B58\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\u6642\u9593\u3092\u7F6E\u3044\u3066\u518D\u5EA6\u6295\u7A3F\u3057\u3066\u307F\u3066\u304F\u3060\u3055\u3044\u3002","The error returned from the server was":"\u30B5\u30FC\u30D0\u30FC\u304B\u3089\u8FD4\u3063\u3066\u6765\u305F\u30A8\u30E9\u30FC","The file size exceeds the server limit.":"\u30D5\u30A1\u30A4\u30EB\u30B5\u30A4\u30BA\u304C\u30B5\u30FC\u30D0\u30FC\u306E\u4E0A\u9650\u3092\u8D85\u3048\u3066\u3044\u307E\u3059\u3002","The total size of FormData is within the acceptable range.":"FormData\u306E\u5408\u8A08\u30B5\u30A4\u30BA\u306F\u5236\u9650\u7BC4\u56F2\u5185\u3067\u3059\u3002","Limit size":"\u4E0A\u9650\u30B5\u30A4\u30BA","Current size":"\u73FE\u5728\u306E\u30B5\u30A4\u30BA","Network response was not OK":"\u901A\u4FE1\u30A8\u30E9\u30FC","HTTP status code":"HTTP\u30B9\u30C6\u30FC\u30BF\u30B9\u30B3\u30FC\u30C9"}');

},{}],"lo0db":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPSplashScreen);
function CPSplashScreen(uiParent, loader, resourcesRoot) {
    const MAX_SMOOTHIE_OFFSET = 170;
    var canvas = document.createElement("canvas"), canvasContext = canvas.getContext("2d"), cup = new Image(), lid = new Image(), outlines = new Image(), text = new Image(), shading = new Image(), highlights = new Image(), smoothie = new Image(), images = [
        cup,
        lid,
        outlines,
        text,
        shading,
        highlights,
        smoothie
    ], loadedCount = 0, cupComposite, smoothieComposite, cupCompositeContext, smoothieCompositeContext, progress = 0.0, message = "", fontHeight = 14;
    var imageRoot = resourcesRoot + "splash/";
    for(var i = 0; i < images.length; i++)images[i].onload = function() {
        loadedCount++;
        if (loadedCount == images.length) repaint();
    };
    cup.src = imageRoot + "cup.png";
    highlights.src = imageRoot + "highlights.png";
    lid.src = imageRoot + "lid.png";
    outlines.src = imageRoot + "lines.png";
    shading.src = imageRoot + "shading.png";
    smoothie.src = imageRoot + "smoothie.png";
    text.src = imageRoot + "text.png";
    function buildSmoothieComposite(imgWidth, imgHeight, progress) {
        if (!smoothieComposite) {
            smoothieComposite = document.createElement("canvas");
            smoothieComposite.width = imgWidth;
            smoothieComposite.height = imgHeight;
            smoothieCompositeContext = smoothieComposite.getContext("2d");
        }
        // First draw the smoothie in its mask position:
        smoothieCompositeContext.globalCompositeOperation = "copy";
        smoothieCompositeContext.drawImage(smoothie, 0, 0);
        // Now shift the smoothie downwards and use the original position as a mask
        smoothieCompositeContext.globalCompositeOperation = "source-in";
        smoothieCompositeContext.drawImage(smoothie, 0, Math.round(progress * MAX_SMOOTHIE_OFFSET));
    }
    function buildCupComposite(imgWidth, imgHeight, progress) {
        if (!cupComposite) {
            cupComposite = document.createElement("canvas");
            cupComposite.width = imgWidth;
            cupComposite.height = imgHeight;
            cupCompositeContext = cupComposite.getContext("2d");
        }
        cupCompositeContext.globalCompositeOperation = "copy";
        cupCompositeContext.drawImage(cup, 0, 0);
        buildSmoothieComposite(imgWidth, imgHeight, progress);
        cupCompositeContext.globalCompositeOperation = "source-over";
        cupCompositeContext.drawImage(smoothieComposite, 0, 0);
        cupCompositeContext.drawImage(lid, 0, 0);
        cupCompositeContext.globalCompositeOperation = "screen";
        cupCompositeContext.drawImage(highlights, 0, 0);
        cupCompositeContext.globalCompositeOperation = "multiply";
        cupCompositeContext.drawImage(shading, 0, 0);
        return cupComposite;
    }
    function repaint() {
        var centerX = canvas.width / 2, centerY = canvas.height / 2;
        canvasContext.fillStyle = 'white';
        canvasContext.fillRect(0, 0, canvas.width, canvas.height);
        if (loadedCount == images.length) {
            var imgWidth = text.width, imgHeight = text.height, left = Math.round(centerX - imgWidth / 2), top = Math.round(centerY - imgHeight / 2);
            canvasContext.drawImage(text, left, top);
            buildCupComposite(imgWidth, imgHeight, progress);
            //The whole cup composite is slightly transparent
            canvasContext.globalAlpha = 0.88;
            canvasContext.drawImage(cupComposite, left, top);
            canvasContext.globalAlpha = 1.0;
            canvasContext.drawImage(outlines, left, top);
            centerY = Math.round(centerY + imgHeight / 2 + 2);
        }
        if (message != "") {
            canvasContext.fillStyle = "black";
            var lines = message.split("\n");
            for(var i = 0; i < lines.length; i++){
                var line = lines[i], lineWidth = canvasContext.measureText(line).width;
                centerY += fontHeight * 2;
                canvasContext.fillText(line, centerX - lineWidth / 2, centerY);
            }
        }
    }
    function resize() {
        // Use the canvas dimensions set by the CSS styles
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        canvasContext.font = fontHeight + "pt sans-serif";
        repaint();
    }
    loader.on("loadingProgress", function(_progress, _message) {
        progress = _progress;
        message = _message;
        repaint();
    });
    loader.on("loadingFailure", function(_message) {
        progress = 0;
        message = _message;
        repaint();
    });
    loader.on("loadingComplete", function() {
        window.removeEventListener("resize", resize);
        uiParent.removeChild(canvas);
    });
    window.addEventListener("resize", resize);
    canvas.className = "chickenpaint-splash-screen";
    uiParent.appendChild(canvas);
    resize();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6MxAQ":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPMainGUI);
var _bootstrapBundleMinJs = require("bootstrap/dist/js/bootstrap.bundle.min.js");
var _cpcanvasJs = require("./CPCanvas.js");
var _cpcanvasJsDefault = parcelHelpers.interopDefault(_cpcanvasJs);
var _cppaletteManagerJs = require("./CPPaletteManager.js");
var _cppaletteManagerJsDefault = parcelHelpers.interopDefault(_cppaletteManagerJs);
var _cpmainMenuJs = require("./CPMainMenu.js");
var _cpmainMenuJsDefault = parcelHelpers.interopDefault(_cpmainMenuJs);
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
function CPMainGUI(controller, uiElem) {
    let lowerArea = document.createElement("div"), canvas = new (0, _cpcanvasJsDefault.default)(controller), paletteManager = new (0, _cppaletteManagerJsDefault.default)(controller), menuBar, fullScreenMode = false, that = this;
    this.togglePalettes = function() {
        paletteManager.togglePalettes();
    };
    this.arrangePalettes = function() {
        // Give the browser a chance to do the sizing of the palettes before we try to rearrange them
        setTimeout(paletteManager.arrangePalettes.bind(paletteManager), 0);
    };
    this.constrainPalettes = function() {
        paletteManager.constrainPalettes();
    };
    this.showPalette = function(paletteName, show) {
        paletteManager.showPaletteByName(paletteName, show);
    };
    this.getSwatches = function() {
        return paletteManager.palettes.swatches.getSwatches();
    };
    this.setSwatches = function(swatches) {
        paletteManager.palettes.swatches.setSwatches(swatches);
    };
    this.getPaletteManager = function() {
        return paletteManager;
    };
    /**
     *
     * @param {number} rotation - in 90 degree increments
     */ this.setRotation90 = function(rotation) {
        canvas.setRotation(rotation * Math.PI / 2);
        paletteManager.palettes.layers.setRotation90(rotation);
    };
    this.setFullScreenMode = function(value) {
        if (fullScreenMode !== value) {
            fullScreenMode = value;
            that.resize();
            that.arrangePalettes();
        }
    };
    this.resize = function(doConstrain = true) {
        let newHeight;
        let windowHeight = window.innerHeight, menuBarHeight = menuBar.getElement().getBoundingClientRect().height;
        if (fullScreenMode) newHeight = windowHeight - menuBarHeight;
        else newHeight = Math.min(Math.max(windowHeight - menuBarHeight - 65, 500), 850);
        canvas.resize(newHeight, false);
        if (doConstrain) that.constrainPalettes();
    };
    menuBar = new (0, _cpmainMenuJsDefault.default)(controller, this);
    this.getMainMenu = function() {
        return menuBar;
    };
    uiElem.appendChild(menuBar.getElement());
    lowerArea.className = "chickenpaint-main-section";
    lowerArea.appendChild(canvas.getElement());
    lowerArea.appendChild(paletteManager.getElement());
    uiElem.appendChild(lowerArea);
    canvas.on("canvasRotated90", function(newAngle) {
        paletteManager.palettes.layers.setRotation90(newAngle);
    });
    // デバイスの向きの変更時にパレットの配置を初期化
    if (screen.orientation) //非対応ブラウザ対策
    screen.orientation.addEventListener("change", (e)=>{
        //何通りも、試してどれかが有効になる事を期待
        this.resize();
        // パレット初期化
        controller.actionPerformed({
            action: "CPArrangePalettes"
        });
        setTimeout(()=>{
            this.resize();
            // パレット初期化
            controller.actionPerformed({
                action: "CPArrangePalettes"
            });
        }, 10);
        Promise.resolve().then(()=>{
            this.resize();
        }).then(()=>{
            // パレット初期化
            controller.actionPerformed({
                action: "CPArrangePalettes"
            });
        });
    });
    // ハンバガーメニューとモーダルの二重表示防止
    const collapseElement = document.getElementById("chickenpaint-main-menu-content");
    document.addEventListener("show.bs.modal", ()=>{
        // chickenpaint-main-menu-contentのIDを持つcollapse要素を閉じる
        if (collapseElement && collapseElement.classList.contains("show")) {
            const bsCollapse = new _bootstrapBundleMinJs.Collapse(collapseElement, {
                toggle: false
            });
            bsCollapse.hide();
        }
    });
    if (collapseElement) {
        const WidgetNav = document.querySelector(".chickenpaint .widget-nav");
        if (WidgetNav) {
            collapseElement.addEventListener("show.bs.collapse", (e)=>{
                //ハンバガーメニューを表示する時に
                // .navbar-nav を非表示にする
                WidgetNav.classList.add("hidden");
            });
            collapseElement.addEventListener("hidden.bs.collapse", (e)=>{
                //ハンバガーメニューを閉じる時に
                // .navbar-nav を表示する
                WidgetNav.classList.remove("hidden");
            });
        }
        window.addEventListener("resize", ()=>{
            // .navbar-nav を表示する
            WidgetNav?.classList.remove("hidden");
        });
    }
    //Bootstrap5のコラプスでメニューバーが閉じる時にリサイズする
    document.addEventListener("hidden.bs.collapse", this.resize.bind(this));
    window.addEventListener("resize", this.resize.bind(this));
    let lastScrollbarVisible = null;
    let resizeScheduled = false;
    //縦スクロールバーの表示を監視してリサイズする
    const observer = new ResizeObserver(()=>{
        const scrollbarVisible = window.innerWidth > document.documentElement.clientWidth;
        if (scrollbarVisible !== lastScrollbarVisible) {
            lastScrollbarVisible = scrollbarVisible;
            // console.log('Scrollbar visibility changed:', scrollbarVisible);
            if (!resizeScheduled) {
                resizeScheduled = true;
                requestAnimationFrame(()=>{
                    resizeScheduled = false;
                    //doConstrain = false
                    //キャンバスのリサイズは行うがパレットの再配置は行わない
                    this.resize(false);
                });
            }
        }
    });
    observer.observe(document.body);
    controller.on("fullScreen", (fullscreen)=>this.setFullScreenMode(fullscreen));
    controller.on("unsavedChanges", (unsaved)=>{
        uiElem.classList.toggle("chickenpaint-unsaved", unsaved);
    });
    setTimeout(this.resize.bind(this), 0);
}
CPMainGUI.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
CPMainGUI.prototype.constructor = CPMainGUI;

},{"bootstrap/dist/js/bootstrap.bundle.min.js":"joWv1","./CPCanvas.js":"01U1t","./CPPaletteManager.js":"3jeYk","./CPMainMenu.js":"yJXzu","wolfy87-eventemitter":"gPUo0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"joWv1":[function(require,module,exports,__globalThis) {
/*!
  * Bootstrap v5.3.7 (https://getbootstrap.com/)
  * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */ !function(t, e) {
    module.exports = e();
}(this, function() {
    "use strict";
    const t = new Map, e = {
        set (e, i, n) {
            t.has(e) || t.set(e, new Map);
            const s = t.get(e);
            s.has(i) || 0 === s.size ? s.set(i, n) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`);
        },
        get: (e, i)=>t.has(e) && t.get(e).get(i) || null,
        remove (e, i) {
            if (!t.has(e)) return;
            const n = t.get(e);
            n.delete(i), 0 === n.size && t.delete(e);
        }
    }, i = "transitionend", n = (t)=>(t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, (t, e)=>`#${CSS.escape(e)}`)), t), s = (t)=>{
        t.dispatchEvent(new Event(i));
    }, o = (t)=>!(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), r = (t)=>o(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(n(t)) : null, a = (t)=>{
        if (!o(t) || 0 === t.getClientRects().length) return !1;
        const e = "visible" === getComputedStyle(t).getPropertyValue("visibility"), i = t.closest("details:not([open])");
        if (!i) return e;
        if (i !== t) {
            const e = t.closest("summary");
            if (e && e.parentNode !== i) return !1;
            if (null === e) return !1;
        }
        return e;
    }, l = (t)=>!t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")), c = (t)=>{
        if (!document.documentElement.attachShadow) return null;
        if ("function" == typeof t.getRootNode) {
            const e = t.getRootNode();
            return e instanceof ShadowRoot ? e : null;
        }
        return t instanceof ShadowRoot ? t : t.parentNode ? c(t.parentNode) : null;
    }, h = ()=>{}, d = (t)=>{
        t.offsetHeight;
    }, u = ()=>window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, f = [], p = ()=>"rtl" === document.documentElement.dir, m = (t)=>{
        var e;
        e = ()=>{
            const e = u();
            if (e) {
                const i = t.NAME, n = e.fn[i];
                e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = ()=>(e.fn[i] = n, t.jQueryInterface);
            }
        }, "loading" === document.readyState ? (f.length || document.addEventListener("DOMContentLoaded", ()=>{
            for (const t of f)t();
        }), f.push(e)) : e();
    }, g = (t, e = [], i = t)=>"function" == typeof t ? t.call(...e) : i, _ = (t, e, n = !0)=>{
        if (!n) return void g(t);
        const o = ((t)=>{
            if (!t) return 0;
            let { transitionDuration: e, transitionDelay: i } = window.getComputedStyle(t);
            const n = Number.parseFloat(e), s = Number.parseFloat(i);
            return n || s ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0;
        })(e) + 5;
        let r = !1;
        const a = ({ target: n })=>{
            n === e && (r = !0, e.removeEventListener(i, a), g(t));
        };
        e.addEventListener(i, a), setTimeout(()=>{
            r || s(e);
        }, o);
    }, b = (t, e, i, n)=>{
        const s = t.length;
        let o = t.indexOf(e);
        return -1 === o ? !i && n ? t[s - 1] : t[0] : (o += i ? 1 : -1, n && (o = (o + s) % s), t[Math.max(0, Math.min(o, s - 1))]);
    }, v = /[^.]*(?=\..*)\.|.*/, y = /\..*/, w = /::\d+$/, A = {};
    let E = 1;
    const T = {
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, C = new Set([
        "click",
        "dblclick",
        "mouseup",
        "mousedown",
        "contextmenu",
        "mousewheel",
        "DOMMouseScroll",
        "mouseover",
        "mouseout",
        "mousemove",
        "selectstart",
        "selectend",
        "keydown",
        "keypress",
        "keyup",
        "orientationchange",
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel",
        "pointerdown",
        "pointermove",
        "pointerup",
        "pointerleave",
        "pointercancel",
        "gesturestart",
        "gesturechange",
        "gestureend",
        "focus",
        "blur",
        "change",
        "reset",
        "select",
        "submit",
        "focusin",
        "focusout",
        "load",
        "unload",
        "beforeunload",
        "resize",
        "move",
        "DOMContentLoaded",
        "readystatechange",
        "error",
        "abort",
        "scroll"
    ]);
    function O(t, e) {
        return e && `${e}::${E++}` || t.uidEvent || E++;
    }
    function x(t) {
        const e = O(t);
        return t.uidEvent = e, A[e] = A[e] || {}, A[e];
    }
    function k(t, e, i = null) {
        return Object.values(t).find((t)=>t.callable === e && t.delegationSelector === i);
    }
    function L(t, e, i) {
        const n = "string" == typeof e, s = n ? i : e || i;
        let o = I(t);
        return C.has(o) || (o = t), [
            n,
            s,
            o
        ];
    }
    function S(t, e, i, n, s) {
        if ("string" != typeof e || !t) return;
        let [o, r, a] = L(e, i, n);
        if (e in T) {
            const t = (t)=>function(e) {
                    if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e);
                };
            r = t(r);
        }
        const l = x(t), c = l[a] || (l[a] = {}), h = k(c, r, o ? i : null);
        if (h) return void (h.oneOff = h.oneOff && s);
        const d = O(r, e.replace(v, "")), u = o ? function(t, e, i) {
            return function n(s) {
                const o = t.querySelectorAll(e);
                for(let { target: r } = s; r && r !== this; r = r.parentNode)for (const a of o)if (a === r) return P(s, {
                    delegateTarget: r
                }), n.oneOff && N.off(t, s.type, e, i), i.apply(r, [
                    s
                ]);
            };
        }(t, i, r) : function(t, e) {
            return function i(n) {
                return P(n, {
                    delegateTarget: t
                }), i.oneOff && N.off(t, n.type, e), e.apply(t, [
                    n
                ]);
            };
        }(t, r);
        u.delegationSelector = o ? i : null, u.callable = r, u.oneOff = s, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o);
    }
    function D(t, e, i, n, s) {
        const o = k(e[i], n, s);
        o && (t.removeEventListener(i, o, Boolean(s)), delete e[i][o.uidEvent]);
    }
    function $(t, e, i, n) {
        const s = e[i] || {};
        for (const [o, r] of Object.entries(s))o.includes(n) && D(t, e, i, r.callable, r.delegationSelector);
    }
    function I(t) {
        return t = t.replace(y, ""), T[t] || t;
    }
    const N = {
        on (t, e, i, n) {
            S(t, e, i, n, !1);
        },
        one (t, e, i, n) {
            S(t, e, i, n, !0);
        },
        off (t, e, i, n) {
            if ("string" != typeof e || !t) return;
            const [s, o, r] = L(e, i, n), a = r !== e, l = x(t), c = l[r] || {}, h = e.startsWith(".");
            if (void 0 === o) {
                if (h) for (const i of Object.keys(l))$(t, l, i, e.slice(1));
                for (const [i, n] of Object.entries(c)){
                    const s = i.replace(w, "");
                    a && !e.includes(s) || D(t, l, r, n.callable, n.delegationSelector);
                }
            } else {
                if (!Object.keys(c).length) return;
                D(t, l, r, o, s ? i : null);
            }
        },
        trigger (t, e, i) {
            if ("string" != typeof e || !t) return null;
            const n = u();
            let s = null, o = !0, r = !0, a = !1;
            e !== I(e) && n && (s = n.Event(e, i), n(t).trigger(s), o = !s.isPropagationStopped(), r = !s.isImmediatePropagationStopped(), a = s.isDefaultPrevented());
            const l = P(new Event(e, {
                bubbles: o,
                cancelable: !0
            }), i);
            return a && l.preventDefault(), r && t.dispatchEvent(l), l.defaultPrevented && s && s.preventDefault(), l;
        }
    };
    function P(t, e = {}) {
        for (const [i, n] of Object.entries(e))try {
            t[i] = n;
        } catch (e) {
            Object.defineProperty(t, i, {
                configurable: !0,
                get: ()=>n
            });
        }
        return t;
    }
    function j(t) {
        if ("true" === t) return !0;
        if ("false" === t) return !1;
        if (t === Number(t).toString()) return Number(t);
        if ("" === t || "null" === t) return null;
        if ("string" != typeof t) return t;
        try {
            return JSON.parse(decodeURIComponent(t));
        } catch (e) {
            return t;
        }
    }
    function M(t) {
        return t.replace(/[A-Z]/g, (t)=>`-${t.toLowerCase()}`);
    }
    const F = {
        setDataAttribute (t, e, i) {
            t.setAttribute(`data-bs-${M(e)}`, i);
        },
        removeDataAttribute (t, e) {
            t.removeAttribute(`data-bs-${M(e)}`);
        },
        getDataAttributes (t) {
            if (!t) return {};
            const e = {}, i = Object.keys(t.dataset).filter((t)=>t.startsWith("bs") && !t.startsWith("bsConfig"));
            for (const n of i){
                let i = n.replace(/^bs/, "");
                i = i.charAt(0).toLowerCase() + i.slice(1), e[i] = j(t.dataset[n]);
            }
            return e;
        },
        getDataAttribute: (t, e)=>j(t.getAttribute(`data-bs-${M(e)}`))
    };
    class H {
        static get Default() {
            return {};
        }
        static get DefaultType() {
            return {};
        }
        static get NAME() {
            throw new Error('You have to implement the static method "NAME", for each component!');
        }
        _getConfig(t) {
            return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
        }
        _configAfterMerge(t) {
            return t;
        }
        _mergeConfigObj(t, e) {
            const i = o(e) ? F.getDataAttribute(e, "config") : {};
            return {
                ...this.constructor.Default,
                ..."object" == typeof i ? i : {},
                ...o(e) ? F.getDataAttributes(e) : {},
                ..."object" == typeof t ? t : {}
            };
        }
        _typeCheckConfig(t, e = this.constructor.DefaultType) {
            for (const [n, s] of Object.entries(e)){
                const e = t[n], r = o(e) ? "element" : null == (i = e) ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase();
                if (!new RegExp(s).test(r)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${r}" but expected type "${s}".`);
            }
            var i;
        }
    }
    class W extends H {
        constructor(t, i){
            super(), (t = r(t)) && (this._element = t, this._config = this._getConfig(i), e.set(this._element, this.constructor.DATA_KEY, this));
        }
        dispose() {
            e.remove(this._element, this.constructor.DATA_KEY), N.off(this._element, this.constructor.EVENT_KEY);
            for (const t of Object.getOwnPropertyNames(this))this[t] = null;
        }
        _queueCallback(t, e, i = !0) {
            _(t, e, i);
        }
        _getConfig(t) {
            return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
        }
        static getInstance(t) {
            return e.get(r(t), this.DATA_KEY);
        }
        static getOrCreateInstance(t, e = {}) {
            return this.getInstance(t) || new this(t, "object" == typeof e ? e : null);
        }
        static get VERSION() {
            return "5.3.7";
        }
        static get DATA_KEY() {
            return `bs.${this.NAME}`;
        }
        static get EVENT_KEY() {
            return `.${this.DATA_KEY}`;
        }
        static eventName(t) {
            return `${t}${this.EVENT_KEY}`;
        }
    }
    const B = (t)=>{
        let e = t.getAttribute("data-bs-target");
        if (!e || "#" === e) {
            let i = t.getAttribute("href");
            if (!i || !i.includes("#") && !i.startsWith(".")) return null;
            i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), e = i && "#" !== i ? i.trim() : null;
        }
        return e ? e.split(",").map((t)=>n(t)).join(",") : null;
    }, z = {
        find: (t, e = document.documentElement)=>[].concat(...Element.prototype.querySelectorAll.call(e, t)),
        findOne: (t, e = document.documentElement)=>Element.prototype.querySelector.call(e, t),
        children: (t, e)=>[].concat(...t.children).filter((t)=>t.matches(e)),
        parents (t, e) {
            const i = [];
            let n = t.parentNode.closest(e);
            for(; n;)i.push(n), n = n.parentNode.closest(e);
            return i;
        },
        prev (t, e) {
            let i = t.previousElementSibling;
            for(; i;){
                if (i.matches(e)) return [
                    i
                ];
                i = i.previousElementSibling;
            }
            return [];
        },
        next (t, e) {
            let i = t.nextElementSibling;
            for(; i;){
                if (i.matches(e)) return [
                    i
                ];
                i = i.nextElementSibling;
            }
            return [];
        },
        focusableChildren (t) {
            const e = [
                "a",
                "button",
                "input",
                "textarea",
                "select",
                "details",
                "[tabindex]",
                '[contenteditable="true"]'
            ].map((t)=>`${t}:not([tabindex^="-"])`).join(",");
            return this.find(e, t).filter((t)=>!l(t) && a(t));
        },
        getSelectorFromElement (t) {
            const e = B(t);
            return e && z.findOne(e) ? e : null;
        },
        getElementFromSelector (t) {
            const e = B(t);
            return e ? z.findOne(e) : null;
        },
        getMultipleElementsFromSelector (t) {
            const e = B(t);
            return e ? z.find(e) : [];
        }
    }, R = (t, e = "hide")=>{
        const i = `click.dismiss${t.EVENT_KEY}`, n = t.NAME;
        N.on(document, i, `[data-bs-dismiss="${n}"]`, function(i) {
            if ([
                "A",
                "AREA"
            ].includes(this.tagName) && i.preventDefault(), l(this)) return;
            const s = z.getElementFromSelector(this) || this.closest(`.${n}`);
            t.getOrCreateInstance(s)[e]();
        });
    }, q = ".bs.alert", V = `close${q}`, K = `closed${q}`;
    class Q extends W {
        static get NAME() {
            return "alert";
        }
        close() {
            if (N.trigger(this._element, V).defaultPrevented) return;
            this._element.classList.remove("show");
            const t = this._element.classList.contains("fade");
            this._queueCallback(()=>this._destroyElement(), this._element, t);
        }
        _destroyElement() {
            this._element.remove(), N.trigger(this._element, K), this.dispose();
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Q.getOrCreateInstance(this);
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                    e[t](this);
                }
            });
        }
    }
    R(Q, "close"), m(Q);
    const X = '[data-bs-toggle="button"]';
    class Y extends W {
        static get NAME() {
            return "button";
        }
        toggle() {
            this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Y.getOrCreateInstance(this);
                "toggle" === t && e[t]();
            });
        }
    }
    N.on(document, "click.bs.button.data-api", X, (t)=>{
        t.preventDefault();
        const e = t.target.closest(X);
        Y.getOrCreateInstance(e).toggle();
    }), m(Y);
    const U = ".bs.swipe", G = `touchstart${U}`, J = `touchmove${U}`, Z = `touchend${U}`, tt = `pointerdown${U}`, et = `pointerup${U}`, it = {
        endCallback: null,
        leftCallback: null,
        rightCallback: null
    }, nt = {
        endCallback: "(function|null)",
        leftCallback: "(function|null)",
        rightCallback: "(function|null)"
    };
    class st extends H {
        constructor(t, e){
            super(), this._element = t, t && st.isSupported() && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents());
        }
        static get Default() {
            return it;
        }
        static get DefaultType() {
            return nt;
        }
        static get NAME() {
            return "swipe";
        }
        dispose() {
            N.off(this._element, U);
        }
        _start(t) {
            this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX;
        }
        _end(t) {
            this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), g(this._config.endCallback);
        }
        _move(t) {
            this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX;
        }
        _handleSwipe() {
            const t = Math.abs(this._deltaX);
            if (t <= 40) return;
            const e = t / this._deltaX;
            this._deltaX = 0, e && g(e > 0 ? this._config.rightCallback : this._config.leftCallback);
        }
        _initEvents() {
            this._supportPointerEvents ? (N.on(this._element, tt, (t)=>this._start(t)), N.on(this._element, et, (t)=>this._end(t)), this._element.classList.add("pointer-event")) : (N.on(this._element, G, (t)=>this._start(t)), N.on(this._element, J, (t)=>this._move(t)), N.on(this._element, Z, (t)=>this._end(t)));
        }
        _eventIsPointerPenTouch(t) {
            return this._supportPointerEvents && ("pen" === t.pointerType || "touch" === t.pointerType);
        }
        static isSupported() {
            return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
        }
    }
    const ot = ".bs.carousel", rt = ".data-api", at = "ArrowLeft", lt = "ArrowRight", ct = "next", ht = "prev", dt = "left", ut = "right", ft = `slide${ot}`, pt = `slid${ot}`, mt = `keydown${ot}`, gt = `mouseenter${ot}`, _t = `mouseleave${ot}`, bt = `dragstart${ot}`, vt = `load${ot}${rt}`, yt = `click${ot}${rt}`, wt = "carousel", At = "active", Et = ".active", Tt = ".carousel-item", Ct = Et + Tt, Ot = {
        [at]: ut,
        [lt]: dt
    }, xt = {
        interval: 5e3,
        keyboard: !0,
        pause: "hover",
        ride: !1,
        touch: !0,
        wrap: !0
    }, kt = {
        interval: "(number|boolean)",
        keyboard: "boolean",
        pause: "(string|boolean)",
        ride: "(boolean|string)",
        touch: "boolean",
        wrap: "boolean"
    };
    class Lt extends W {
        constructor(t, e){
            super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = z.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === wt && this.cycle();
        }
        static get Default() {
            return xt;
        }
        static get DefaultType() {
            return kt;
        }
        static get NAME() {
            return "carousel";
        }
        next() {
            this._slide(ct);
        }
        nextWhenVisible() {
            !document.hidden && a(this._element) && this.next();
        }
        prev() {
            this._slide(ht);
        }
        pause() {
            this._isSliding && s(this._element), this._clearInterval();
        }
        cycle() {
            this._clearInterval(), this._updateInterval(), this._interval = setInterval(()=>this.nextWhenVisible(), this._config.interval);
        }
        _maybeEnableCycle() {
            this._config.ride && (this._isSliding ? N.one(this._element, pt, ()=>this.cycle()) : this.cycle());
        }
        to(t) {
            const e = this._getItems();
            if (t > e.length - 1 || t < 0) return;
            if (this._isSliding) return void N.one(this._element, pt, ()=>this.to(t));
            const i = this._getItemIndex(this._getActive());
            if (i === t) return;
            const n = t > i ? ct : ht;
            this._slide(n, e[t]);
        }
        dispose() {
            this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
        }
        _configAfterMerge(t) {
            return t.defaultInterval = t.interval, t;
        }
        _addEventListeners() {
            this._config.keyboard && N.on(this._element, mt, (t)=>this._keydown(t)), "hover" === this._config.pause && (N.on(this._element, gt, ()=>this.pause()), N.on(this._element, _t, ()=>this._maybeEnableCycle())), this._config.touch && st.isSupported() && this._addTouchEventListeners();
        }
        _addTouchEventListeners() {
            for (const t of z.find(".carousel-item img", this._element))N.on(t, bt, (t)=>t.preventDefault());
            const t = {
                leftCallback: ()=>this._slide(this._directionToOrder(dt)),
                rightCallback: ()=>this._slide(this._directionToOrder(ut)),
                endCallback: ()=>{
                    "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(()=>this._maybeEnableCycle(), 500 + this._config.interval));
                }
            };
            this._swipeHelper = new st(this._element, t);
        }
        _keydown(t) {
            if (/input|textarea/i.test(t.target.tagName)) return;
            const e = Ot[t.key];
            e && (t.preventDefault(), this._slide(this._directionToOrder(e)));
        }
        _getItemIndex(t) {
            return this._getItems().indexOf(t);
        }
        _setActiveIndicatorElement(t) {
            if (!this._indicatorsElement) return;
            const e = z.findOne(Et, this._indicatorsElement);
            e.classList.remove(At), e.removeAttribute("aria-current");
            const i = z.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement);
            i && (i.classList.add(At), i.setAttribute("aria-current", "true"));
        }
        _updateInterval() {
            const t = this._activeElement || this._getActive();
            if (!t) return;
            const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
            this._config.interval = e || this._config.defaultInterval;
        }
        _slide(t, e = null) {
            if (this._isSliding) return;
            const i = this._getActive(), n = t === ct, s = e || b(this._getItems(), i, n, this._config.wrap);
            if (s === i) return;
            const o = this._getItemIndex(s), r = (e)=>N.trigger(this._element, e, {
                    relatedTarget: s,
                    direction: this._orderToDirection(t),
                    from: this._getItemIndex(i),
                    to: o
                });
            if (r(ft).defaultPrevented) return;
            if (!i || !s) return;
            const a = Boolean(this._interval);
            this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = s;
            const l = n ? "carousel-item-start" : "carousel-item-end", c = n ? "carousel-item-next" : "carousel-item-prev";
            s.classList.add(c), d(s), i.classList.add(l), s.classList.add(l), this._queueCallback(()=>{
                s.classList.remove(l, c), s.classList.add(At), i.classList.remove(At, c, l), this._isSliding = !1, r(pt);
            }, i, this._isAnimated()), a && this.cycle();
        }
        _isAnimated() {
            return this._element.classList.contains("slide");
        }
        _getActive() {
            return z.findOne(Ct, this._element);
        }
        _getItems() {
            return z.find(Tt, this._element);
        }
        _clearInterval() {
            this._interval && (clearInterval(this._interval), this._interval = null);
        }
        _directionToOrder(t) {
            return p() ? t === dt ? ht : ct : t === dt ? ct : ht;
        }
        _orderToDirection(t) {
            return p() ? t === ht ? dt : ut : t === ht ? ut : dt;
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Lt.getOrCreateInstance(this, t);
                if ("number" != typeof t) {
                    if ("string" == typeof t) {
                        if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                        e[t]();
                    }
                } else e.to(t);
            });
        }
    }
    N.on(document, yt, "[data-bs-slide], [data-bs-slide-to]", function(t) {
        const e = z.getElementFromSelector(this);
        if (!e || !e.classList.contains(wt)) return;
        t.preventDefault();
        const i = Lt.getOrCreateInstance(e), n = this.getAttribute("data-bs-slide-to");
        return n ? (i.to(n), void i._maybeEnableCycle()) : "next" === F.getDataAttribute(this, "slide") ? (i.next(), void i._maybeEnableCycle()) : (i.prev(), void i._maybeEnableCycle());
    }), N.on(window, vt, ()=>{
        const t = z.find('[data-bs-ride="carousel"]');
        for (const e of t)Lt.getOrCreateInstance(e);
    }), m(Lt);
    const St = ".bs.collapse", Dt = `show${St}`, $t = `shown${St}`, It = `hide${St}`, Nt = `hidden${St}`, Pt = `click${St}.data-api`, jt = "show", Mt = "collapse", Ft = "collapsing", Ht = `:scope .${Mt} .${Mt}`, Wt = '[data-bs-toggle="collapse"]', Bt = {
        parent: null,
        toggle: !0
    }, zt = {
        parent: "(null|element)",
        toggle: "boolean"
    };
    class Rt extends W {
        constructor(t, e){
            super(t, e), this._isTransitioning = !1, this._triggerArray = [];
            const i = z.find(Wt);
            for (const t of i){
                const e = z.getSelectorFromElement(t), i = z.find(e).filter((t)=>t === this._element);
                null !== e && i.length && this._triggerArray.push(t);
            }
            this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
        }
        static get Default() {
            return Bt;
        }
        static get DefaultType() {
            return zt;
        }
        static get NAME() {
            return "collapse";
        }
        toggle() {
            this._isShown() ? this.hide() : this.show();
        }
        show() {
            if (this._isTransitioning || this._isShown()) return;
            let t = [];
            if (this._config.parent && (t = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t)=>t !== this._element).map((t)=>Rt.getOrCreateInstance(t, {
                    toggle: !1
                }))), t.length && t[0]._isTransitioning) return;
            if (N.trigger(this._element, Dt).defaultPrevented) return;
            for (const e of t)e.hide();
            const e = this._getDimension();
            this._element.classList.remove(Mt), this._element.classList.add(Ft), this._element.style[e] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
            const i = `scroll${e[0].toUpperCase() + e.slice(1)}`;
            this._queueCallback(()=>{
                this._isTransitioning = !1, this._element.classList.remove(Ft), this._element.classList.add(Mt, jt), this._element.style[e] = "", N.trigger(this._element, $t);
            }, this._element, !0), this._element.style[e] = `${this._element[i]}px`;
        }
        hide() {
            if (this._isTransitioning || !this._isShown()) return;
            if (N.trigger(this._element, It).defaultPrevented) return;
            const t = this._getDimension();
            this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, d(this._element), this._element.classList.add(Ft), this._element.classList.remove(Mt, jt);
            for (const t of this._triggerArray){
                const e = z.getElementFromSelector(t);
                e && !this._isShown(e) && this._addAriaAndCollapsedClass([
                    t
                ], !1);
            }
            this._isTransitioning = !0, this._element.style[t] = "", this._queueCallback(()=>{
                this._isTransitioning = !1, this._element.classList.remove(Ft), this._element.classList.add(Mt), N.trigger(this._element, Nt);
            }, this._element, !0);
        }
        _isShown(t = this._element) {
            return t.classList.contains(jt);
        }
        _configAfterMerge(t) {
            return t.toggle = Boolean(t.toggle), t.parent = r(t.parent), t;
        }
        _getDimension() {
            return this._element.classList.contains("collapse-horizontal") ? "width" : "height";
        }
        _initializeChildren() {
            if (!this._config.parent) return;
            const t = this._getFirstLevelChildren(Wt);
            for (const e of t){
                const t = z.getElementFromSelector(e);
                t && this._addAriaAndCollapsedClass([
                    e
                ], this._isShown(t));
            }
        }
        _getFirstLevelChildren(t) {
            const e = z.find(Ht, this._config.parent);
            return z.find(t, this._config.parent).filter((t)=>!e.includes(t));
        }
        _addAriaAndCollapsedClass(t, e) {
            if (t.length) for (const i of t)i.classList.toggle("collapsed", !e), i.setAttribute("aria-expanded", e);
        }
        static jQueryInterface(t) {
            const e = {};
            return "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1), this.each(function() {
                const i = Rt.getOrCreateInstance(this, e);
                if ("string" == typeof t) {
                    if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
                    i[t]();
                }
            });
        }
    }
    N.on(document, Pt, Wt, function(t) {
        ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault();
        for (const t of z.getMultipleElementsFromSelector(this))Rt.getOrCreateInstance(t, {
            toggle: !1
        }).toggle();
    }), m(Rt);
    var qt = "top", Vt = "bottom", Kt = "right", Qt = "left", Xt = "auto", Yt = [
        qt,
        Vt,
        Kt,
        Qt
    ], Ut = "start", Gt = "end", Jt = "clippingParents", Zt = "viewport", te = "popper", ee = "reference", ie = Yt.reduce(function(t, e) {
        return t.concat([
            e + "-" + Ut,
            e + "-" + Gt
        ]);
    }, []), ne = [].concat(Yt, [
        Xt
    ]).reduce(function(t, e) {
        return t.concat([
            e,
            e + "-" + Ut,
            e + "-" + Gt
        ]);
    }, []), se = "beforeRead", oe = "read", re = "afterRead", ae = "beforeMain", le = "main", ce = "afterMain", he = "beforeWrite", de = "write", ue = "afterWrite", fe = [
        se,
        oe,
        re,
        ae,
        le,
        ce,
        he,
        de,
        ue
    ];
    function pe(t) {
        return t ? (t.nodeName || "").toLowerCase() : null;
    }
    function me(t) {
        if (null == t) return window;
        if ("[object Window]" !== t.toString()) {
            var e = t.ownerDocument;
            return e && e.defaultView || window;
        }
        return t;
    }
    function ge(t) {
        return t instanceof me(t).Element || t instanceof Element;
    }
    function _e(t) {
        return t instanceof me(t).HTMLElement || t instanceof HTMLElement;
    }
    function be(t) {
        return "undefined" != typeof ShadowRoot && (t instanceof me(t).ShadowRoot || t instanceof ShadowRoot);
    }
    const ve = {
        name: "applyStyles",
        enabled: !0,
        phase: "write",
        fn: function(t) {
            var e = t.state;
            Object.keys(e.elements).forEach(function(t) {
                var i = e.styles[t] || {}, n = e.attributes[t] || {}, s = e.elements[t];
                _e(s) && pe(s) && (Object.assign(s.style, i), Object.keys(n).forEach(function(t) {
                    var e = n[t];
                    !1 === e ? s.removeAttribute(t) : s.setAttribute(t, !0 === e ? "" : e);
                }));
            });
        },
        effect: function(t) {
            var e = t.state, i = {
                popper: {
                    position: e.options.strategy,
                    left: "0",
                    top: "0",
                    margin: "0"
                },
                arrow: {
                    position: "absolute"
                },
                reference: {}
            };
            return Object.assign(e.elements.popper.style, i.popper), e.styles = i, e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow), function() {
                Object.keys(e.elements).forEach(function(t) {
                    var n = e.elements[t], s = e.attributes[t] || {}, o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : i[t]).reduce(function(t, e) {
                        return t[e] = "", t;
                    }, {});
                    _e(n) && pe(n) && (Object.assign(n.style, o), Object.keys(s).forEach(function(t) {
                        n.removeAttribute(t);
                    }));
                });
            };
        },
        requires: [
            "computeStyles"
        ]
    };
    function ye(t) {
        return t.split("-")[0];
    }
    var we = Math.max, Ae = Math.min, Ee = Math.round;
    function Te() {
        var t = navigator.userAgentData;
        return null != t && t.brands && Array.isArray(t.brands) ? t.brands.map(function(t) {
            return t.brand + "/" + t.version;
        }).join(" ") : navigator.userAgent;
    }
    function Ce() {
        return !/^((?!chrome|android).)*safari/i.test(Te());
    }
    function Oe(t, e, i) {
        void 0 === e && (e = !1), void 0 === i && (i = !1);
        var n = t.getBoundingClientRect(), s = 1, o = 1;
        e && _e(t) && (s = t.offsetWidth > 0 && Ee(n.width) / t.offsetWidth || 1, o = t.offsetHeight > 0 && Ee(n.height) / t.offsetHeight || 1);
        var r = (ge(t) ? me(t) : window).visualViewport, a = !Ce() && i, l = (n.left + (a && r ? r.offsetLeft : 0)) / s, c = (n.top + (a && r ? r.offsetTop : 0)) / o, h = n.width / s, d = n.height / o;
        return {
            width: h,
            height: d,
            top: c,
            right: l + h,
            bottom: c + d,
            left: l,
            x: l,
            y: c
        };
    }
    function xe(t) {
        var e = Oe(t), i = t.offsetWidth, n = t.offsetHeight;
        return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
            x: t.offsetLeft,
            y: t.offsetTop,
            width: i,
            height: n
        };
    }
    function ke(t, e) {
        var i = e.getRootNode && e.getRootNode();
        if (t.contains(e)) return !0;
        if (i && be(i)) {
            var n = e;
            do {
                if (n && t.isSameNode(n)) return !0;
                n = n.parentNode || n.host;
            }while (n);
        }
        return !1;
    }
    function Le(t) {
        return me(t).getComputedStyle(t);
    }
    function Se(t) {
        return [
            "table",
            "td",
            "th"
        ].indexOf(pe(t)) >= 0;
    }
    function De(t) {
        return ((ge(t) ? t.ownerDocument : t.document) || window.document).documentElement;
    }
    function $e(t) {
        return "html" === pe(t) ? t : t.assignedSlot || t.parentNode || (be(t) ? t.host : null) || De(t);
    }
    function Ie(t) {
        return _e(t) && "fixed" !== Le(t).position ? t.offsetParent : null;
    }
    function Ne(t) {
        for(var e = me(t), i = Ie(t); i && Se(i) && "static" === Le(i).position;)i = Ie(i);
        return i && ("html" === pe(i) || "body" === pe(i) && "static" === Le(i).position) ? e : i || function(t) {
            var e = /firefox/i.test(Te());
            if (/Trident/i.test(Te()) && _e(t) && "fixed" === Le(t).position) return null;
            var i = $e(t);
            for(be(i) && (i = i.host); _e(i) && [
                "html",
                "body"
            ].indexOf(pe(i)) < 0;){
                var n = Le(i);
                if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== [
                    "transform",
                    "perspective"
                ].indexOf(n.willChange) || e && "filter" === n.willChange || e && n.filter && "none" !== n.filter) return i;
                i = i.parentNode;
            }
            return null;
        }(t) || e;
    }
    function Pe(t) {
        return [
            "top",
            "bottom"
        ].indexOf(t) >= 0 ? "x" : "y";
    }
    function je(t, e, i) {
        return we(t, Ae(e, i));
    }
    function Me(t) {
        return Object.assign({}, {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, t);
    }
    function Fe(t, e) {
        return e.reduce(function(e, i) {
            return e[i] = t, e;
        }, {});
    }
    const He = {
        name: "arrow",
        enabled: !0,
        phase: "main",
        fn: function(t) {
            var e, i = t.state, n = t.name, s = t.options, o = i.elements.arrow, r = i.modifiersData.popperOffsets, a = ye(i.placement), l = Pe(a), c = [
                Qt,
                Kt
            ].indexOf(a) >= 0 ? "height" : "width";
            if (o && r) {
                var h = function(t, e) {
                    return Me("number" != typeof (t = "function" == typeof t ? t(Object.assign({}, e.rects, {
                        placement: e.placement
                    })) : t) ? t : Fe(t, Yt));
                }(s.padding, i), d = xe(o), u = "y" === l ? qt : Qt, f = "y" === l ? Vt : Kt, p = i.rects.reference[c] + i.rects.reference[l] - r[l] - i.rects.popper[c], m = r[l] - i.rects.reference[l], g = Ne(o), _ = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0, b = p / 2 - m / 2, v = h[u], y = _ - d[c] - h[f], w = _ / 2 - d[c] / 2 + b, A = je(v, w, y), E = l;
                i.modifiersData[n] = ((e = {})[E] = A, e.centerOffset = A - w, e);
            }
        },
        effect: function(t) {
            var e = t.state, i = t.options.element, n = void 0 === i ? "[data-popper-arrow]" : i;
            null != n && ("string" != typeof n || (n = e.elements.popper.querySelector(n))) && ke(e.elements.popper, n) && (e.elements.arrow = n);
        },
        requires: [
            "popperOffsets"
        ],
        requiresIfExists: [
            "preventOverflow"
        ]
    };
    function We(t) {
        return t.split("-")[1];
    }
    var Be = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
    };
    function ze(t) {
        var e, i = t.popper, n = t.popperRect, s = t.placement, o = t.variation, r = t.offsets, a = t.position, l = t.gpuAcceleration, c = t.adaptive, h = t.roundOffsets, d = t.isFixed, u = r.x, f = void 0 === u ? 0 : u, p = r.y, m = void 0 === p ? 0 : p, g = "function" == typeof h ? h({
            x: f,
            y: m
        }) : {
            x: f,
            y: m
        };
        f = g.x, m = g.y;
        var _ = r.hasOwnProperty("x"), b = r.hasOwnProperty("y"), v = Qt, y = qt, w = window;
        if (c) {
            var A = Ne(i), E = "clientHeight", T = "clientWidth";
            A === me(i) && "static" !== Le(A = De(i)).position && "absolute" === a && (E = "scrollHeight", T = "scrollWidth"), (s === qt || (s === Qt || s === Kt) && o === Gt) && (y = Vt, m -= (d && A === w && w.visualViewport ? w.visualViewport.height : A[E]) - n.height, m *= l ? 1 : -1), s !== Qt && (s !== qt && s !== Vt || o !== Gt) || (v = Kt, f -= (d && A === w && w.visualViewport ? w.visualViewport.width : A[T]) - n.width, f *= l ? 1 : -1);
        }
        var C, O = Object.assign({
            position: a
        }, c && Be), x = !0 === h ? function(t, e) {
            var i = t.x, n = t.y, s = e.devicePixelRatio || 1;
            return {
                x: Ee(i * s) / s || 0,
                y: Ee(n * s) / s || 0
            };
        }({
            x: f,
            y: m
        }, me(i)) : {
            x: f,
            y: m
        };
        return f = x.x, m = x.y, l ? Object.assign({}, O, ((C = {})[y] = b ? "0" : "", C[v] = _ ? "0" : "", C.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", C)) : Object.assign({}, O, ((e = {})[y] = b ? m + "px" : "", e[v] = _ ? f + "px" : "", e.transform = "", e));
    }
    const Re = {
        name: "computeStyles",
        enabled: !0,
        phase: "beforeWrite",
        fn: function(t) {
            var e = t.state, i = t.options, n = i.gpuAcceleration, s = void 0 === n || n, o = i.adaptive, r = void 0 === o || o, a = i.roundOffsets, l = void 0 === a || a, c = {
                placement: ye(e.placement),
                variation: We(e.placement),
                popper: e.elements.popper,
                popperRect: e.rects.popper,
                gpuAcceleration: s,
                isFixed: "fixed" === e.options.strategy
            };
            null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, ze(Object.assign({}, c, {
                offsets: e.modifiersData.popperOffsets,
                position: e.options.strategy,
                adaptive: r,
                roundOffsets: l
            })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, ze(Object.assign({}, c, {
                offsets: e.modifiersData.arrow,
                position: "absolute",
                adaptive: !1,
                roundOffsets: l
            })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
                "data-popper-placement": e.placement
            });
        },
        data: {}
    };
    var qe = {
        passive: !0
    };
    const Ve = {
        name: "eventListeners",
        enabled: !0,
        phase: "write",
        fn: function() {},
        effect: function(t) {
            var e = t.state, i = t.instance, n = t.options, s = n.scroll, o = void 0 === s || s, r = n.resize, a = void 0 === r || r, l = me(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
            return o && c.forEach(function(t) {
                t.addEventListener("scroll", i.update, qe);
            }), a && l.addEventListener("resize", i.update, qe), function() {
                o && c.forEach(function(t) {
                    t.removeEventListener("scroll", i.update, qe);
                }), a && l.removeEventListener("resize", i.update, qe);
            };
        },
        data: {}
    };
    var Ke = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
    };
    function Qe(t) {
        return t.replace(/left|right|bottom|top/g, function(t) {
            return Ke[t];
        });
    }
    var Xe = {
        start: "end",
        end: "start"
    };
    function Ye(t) {
        return t.replace(/start|end/g, function(t) {
            return Xe[t];
        });
    }
    function Ue(t) {
        var e = me(t);
        return {
            scrollLeft: e.pageXOffset,
            scrollTop: e.pageYOffset
        };
    }
    function Ge(t) {
        return Oe(De(t)).left + Ue(t).scrollLeft;
    }
    function Je(t) {
        var e = Le(t), i = e.overflow, n = e.overflowX, s = e.overflowY;
        return /auto|scroll|overlay|hidden/.test(i + s + n);
    }
    function Ze(t) {
        return [
            "html",
            "body",
            "#document"
        ].indexOf(pe(t)) >= 0 ? t.ownerDocument.body : _e(t) && Je(t) ? t : Ze($e(t));
    }
    function ti(t, e) {
        var i;
        void 0 === e && (e = []);
        var n = Ze(t), s = n === (null == (i = t.ownerDocument) ? void 0 : i.body), o = me(n), r = s ? [
            o
        ].concat(o.visualViewport || [], Je(n) ? n : []) : n, a = e.concat(r);
        return s ? a : a.concat(ti($e(r)));
    }
    function ei(t) {
        return Object.assign({}, t, {
            left: t.x,
            top: t.y,
            right: t.x + t.width,
            bottom: t.y + t.height
        });
    }
    function ii(t, e, i) {
        return e === Zt ? ei(function(t, e) {
            var i = me(t), n = De(t), s = i.visualViewport, o = n.clientWidth, r = n.clientHeight, a = 0, l = 0;
            if (s) {
                o = s.width, r = s.height;
                var c = Ce();
                (c || !c && "fixed" === e) && (a = s.offsetLeft, l = s.offsetTop);
            }
            return {
                width: o,
                height: r,
                x: a + Ge(t),
                y: l
            };
        }(t, i)) : ge(e) ? function(t, e) {
            var i = Oe(t, !1, "fixed" === e);
            return i.top = i.top + t.clientTop, i.left = i.left + t.clientLeft, i.bottom = i.top + t.clientHeight, i.right = i.left + t.clientWidth, i.width = t.clientWidth, i.height = t.clientHeight, i.x = i.left, i.y = i.top, i;
        }(e, i) : ei(function(t) {
            var e, i = De(t), n = Ue(t), s = null == (e = t.ownerDocument) ? void 0 : e.body, o = we(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0), r = we(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0), a = -n.scrollLeft + Ge(t), l = -n.scrollTop;
            return "rtl" === Le(s || i).direction && (a += we(i.clientWidth, s ? s.clientWidth : 0) - o), {
                width: o,
                height: r,
                x: a,
                y: l
            };
        }(De(t)));
    }
    function ni(t) {
        var e, i = t.reference, n = t.element, s = t.placement, o = s ? ye(s) : null, r = s ? We(s) : null, a = i.x + i.width / 2 - n.width / 2, l = i.y + i.height / 2 - n.height / 2;
        switch(o){
            case qt:
                e = {
                    x: a,
                    y: i.y - n.height
                };
                break;
            case Vt:
                e = {
                    x: a,
                    y: i.y + i.height
                };
                break;
            case Kt:
                e = {
                    x: i.x + i.width,
                    y: l
                };
                break;
            case Qt:
                e = {
                    x: i.x - n.width,
                    y: l
                };
                break;
            default:
                e = {
                    x: i.x,
                    y: i.y
                };
        }
        var c = o ? Pe(o) : null;
        if (null != c) {
            var h = "y" === c ? "height" : "width";
            switch(r){
                case Ut:
                    e[c] = e[c] - (i[h] / 2 - n[h] / 2);
                    break;
                case Gt:
                    e[c] = e[c] + (i[h] / 2 - n[h] / 2);
            }
        }
        return e;
    }
    function si(t, e) {
        void 0 === e && (e = {});
        var i = e, n = i.placement, s = void 0 === n ? t.placement : n, o = i.strategy, r = void 0 === o ? t.strategy : o, a = i.boundary, l = void 0 === a ? Jt : a, c = i.rootBoundary, h = void 0 === c ? Zt : c, d = i.elementContext, u = void 0 === d ? te : d, f = i.altBoundary, p = void 0 !== f && f, m = i.padding, g = void 0 === m ? 0 : m, _ = Me("number" != typeof g ? g : Fe(g, Yt)), b = u === te ? ee : te, v = t.rects.popper, y = t.elements[p ? b : u], w = function(t, e, i, n) {
            var s = "clippingParents" === e ? function(t) {
                var e = ti($e(t)), i = [
                    "absolute",
                    "fixed"
                ].indexOf(Le(t).position) >= 0 && _e(t) ? Ne(t) : t;
                return ge(i) ? e.filter(function(t) {
                    return ge(t) && ke(t, i) && "body" !== pe(t);
                }) : [];
            }(t) : [].concat(e), o = [].concat(s, [
                i
            ]), r = o[0], a = o.reduce(function(e, i) {
                var s = ii(t, i, n);
                return e.top = we(s.top, e.top), e.right = Ae(s.right, e.right), e.bottom = Ae(s.bottom, e.bottom), e.left = we(s.left, e.left), e;
            }, ii(t, r, n));
            return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
        }(ge(y) ? y : y.contextElement || De(t.elements.popper), l, h, r), A = Oe(t.elements.reference), E = ni({
            reference: A,
            element: v,
            placement: s
        }), T = ei(Object.assign({}, v, E)), C = u === te ? T : A, O = {
            top: w.top - C.top + _.top,
            bottom: C.bottom - w.bottom + _.bottom,
            left: w.left - C.left + _.left,
            right: C.right - w.right + _.right
        }, x = t.modifiersData.offset;
        if (u === te && x) {
            var k = x[s];
            Object.keys(O).forEach(function(t) {
                var e = [
                    Kt,
                    Vt
                ].indexOf(t) >= 0 ? 1 : -1, i = [
                    qt,
                    Vt
                ].indexOf(t) >= 0 ? "y" : "x";
                O[t] += k[i] * e;
            });
        }
        return O;
    }
    function oi(t, e) {
        void 0 === e && (e = {});
        var i = e, n = i.placement, s = i.boundary, o = i.rootBoundary, r = i.padding, a = i.flipVariations, l = i.allowedAutoPlacements, c = void 0 === l ? ne : l, h = We(n), d = h ? a ? ie : ie.filter(function(t) {
            return We(t) === h;
        }) : Yt, u = d.filter(function(t) {
            return c.indexOf(t) >= 0;
        });
        0 === u.length && (u = d);
        var f = u.reduce(function(e, i) {
            return e[i] = si(t, {
                placement: i,
                boundary: s,
                rootBoundary: o,
                padding: r
            })[ye(i)], e;
        }, {});
        return Object.keys(f).sort(function(t, e) {
            return f[t] - f[e];
        });
    }
    const ri = {
        name: "flip",
        enabled: !0,
        phase: "main",
        fn: function(t) {
            var e = t.state, i = t.options, n = t.name;
            if (!e.modifiersData[n]._skip) {
                for(var s = i.mainAxis, o = void 0 === s || s, r = i.altAxis, a = void 0 === r || r, l = i.fallbackPlacements, c = i.padding, h = i.boundary, d = i.rootBoundary, u = i.altBoundary, f = i.flipVariations, p = void 0 === f || f, m = i.allowedAutoPlacements, g = e.options.placement, _ = ye(g), b = l || (_ !== g && p ? function(t) {
                    if (ye(t) === Xt) return [];
                    var e = Qe(t);
                    return [
                        Ye(t),
                        e,
                        Ye(e)
                    ];
                }(g) : [
                    Qe(g)
                ]), v = [
                    g
                ].concat(b).reduce(function(t, i) {
                    return t.concat(ye(i) === Xt ? oi(e, {
                        placement: i,
                        boundary: h,
                        rootBoundary: d,
                        padding: c,
                        flipVariations: p,
                        allowedAutoPlacements: m
                    }) : i);
                }, []), y = e.rects.reference, w = e.rects.popper, A = new Map, E = !0, T = v[0], C = 0; C < v.length; C++){
                    var O = v[C], x = ye(O), k = We(O) === Ut, L = [
                        qt,
                        Vt
                    ].indexOf(x) >= 0, S = L ? "width" : "height", D = si(e, {
                        placement: O,
                        boundary: h,
                        rootBoundary: d,
                        altBoundary: u,
                        padding: c
                    }), $ = L ? k ? Kt : Qt : k ? Vt : qt;
                    y[S] > w[S] && ($ = Qe($));
                    var I = Qe($), N = [];
                    if (o && N.push(D[x] <= 0), a && N.push(D[$] <= 0, D[I] <= 0), N.every(function(t) {
                        return t;
                    })) {
                        T = O, E = !1;
                        break;
                    }
                    A.set(O, N);
                }
                if (E) for(var P = function(t) {
                    var e = v.find(function(e) {
                        var i = A.get(e);
                        if (i) return i.slice(0, t).every(function(t) {
                            return t;
                        });
                    });
                    if (e) return T = e, "break";
                }, j = p ? 3 : 1; j > 0 && "break" !== P(j); j--);
                e.placement !== T && (e.modifiersData[n]._skip = !0, e.placement = T, e.reset = !0);
            }
        },
        requiresIfExists: [
            "offset"
        ],
        data: {
            _skip: !1
        }
    };
    function ai(t, e, i) {
        return void 0 === i && (i = {
            x: 0,
            y: 0
        }), {
            top: t.top - e.height - i.y,
            right: t.right - e.width + i.x,
            bottom: t.bottom - e.height + i.y,
            left: t.left - e.width - i.x
        };
    }
    function li(t) {
        return [
            qt,
            Kt,
            Vt,
            Qt
        ].some(function(e) {
            return t[e] >= 0;
        });
    }
    const ci = {
        name: "hide",
        enabled: !0,
        phase: "main",
        requiresIfExists: [
            "preventOverflow"
        ],
        fn: function(t) {
            var e = t.state, i = t.name, n = e.rects.reference, s = e.rects.popper, o = e.modifiersData.preventOverflow, r = si(e, {
                elementContext: "reference"
            }), a = si(e, {
                altBoundary: !0
            }), l = ai(r, n), c = ai(a, s, o), h = li(l), d = li(c);
            e.modifiersData[i] = {
                referenceClippingOffsets: l,
                popperEscapeOffsets: c,
                isReferenceHidden: h,
                hasPopperEscaped: d
            }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
                "data-popper-reference-hidden": h,
                "data-popper-escaped": d
            });
        }
    }, hi = {
        name: "offset",
        enabled: !0,
        phase: "main",
        requires: [
            "popperOffsets"
        ],
        fn: function(t) {
            var e = t.state, i = t.options, n = t.name, s = i.offset, o = void 0 === s ? [
                0,
                0
            ] : s, r = ne.reduce(function(t, i) {
                return t[i] = function(t, e, i) {
                    var n = ye(t), s = [
                        Qt,
                        qt
                    ].indexOf(n) >= 0 ? -1 : 1, o = "function" == typeof i ? i(Object.assign({}, e, {
                        placement: t
                    })) : i, r = o[0], a = o[1];
                    return r = r || 0, a = (a || 0) * s, [
                        Qt,
                        Kt
                    ].indexOf(n) >= 0 ? {
                        x: a,
                        y: r
                    } : {
                        x: r,
                        y: a
                    };
                }(i, e.rects, o), t;
            }, {}), a = r[e.placement], l = a.x, c = a.y;
            null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[n] = r;
        }
    }, di = {
        name: "popperOffsets",
        enabled: !0,
        phase: "read",
        fn: function(t) {
            var e = t.state, i = t.name;
            e.modifiersData[i] = ni({
                reference: e.rects.reference,
                element: e.rects.popper,
                placement: e.placement
            });
        },
        data: {}
    }, ui = {
        name: "preventOverflow",
        enabled: !0,
        phase: "main",
        fn: function(t) {
            var e = t.state, i = t.options, n = t.name, s = i.mainAxis, o = void 0 === s || s, r = i.altAxis, a = void 0 !== r && r, l = i.boundary, c = i.rootBoundary, h = i.altBoundary, d = i.padding, u = i.tether, f = void 0 === u || u, p = i.tetherOffset, m = void 0 === p ? 0 : p, g = si(e, {
                boundary: l,
                rootBoundary: c,
                padding: d,
                altBoundary: h
            }), _ = ye(e.placement), b = We(e.placement), v = !b, y = Pe(_), w = "x" === y ? "y" : "x", A = e.modifiersData.popperOffsets, E = e.rects.reference, T = e.rects.popper, C = "function" == typeof m ? m(Object.assign({}, e.rects, {
                placement: e.placement
            })) : m, O = "number" == typeof C ? {
                mainAxis: C,
                altAxis: C
            } : Object.assign({
                mainAxis: 0,
                altAxis: 0
            }, C), x = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, k = {
                x: 0,
                y: 0
            };
            if (A) {
                if (o) {
                    var L, S = "y" === y ? qt : Qt, D = "y" === y ? Vt : Kt, $ = "y" === y ? "height" : "width", I = A[y], N = I + g[S], P = I - g[D], j = f ? -T[$] / 2 : 0, M = b === Ut ? E[$] : T[$], F = b === Ut ? -T[$] : -E[$], H = e.elements.arrow, W = f && H ? xe(H) : {
                        width: 0,
                        height: 0
                    }, B = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }, z = B[S], R = B[D], q = je(0, E[$], W[$]), V = v ? E[$] / 2 - j - q - z - O.mainAxis : M - q - z - O.mainAxis, K = v ? -E[$] / 2 + j + q + R + O.mainAxis : F + q + R + O.mainAxis, Q = e.elements.arrow && Ne(e.elements.arrow), X = Q ? "y" === y ? Q.clientTop || 0 : Q.clientLeft || 0 : 0, Y = null != (L = null == x ? void 0 : x[y]) ? L : 0, U = I + K - Y, G = je(f ? Ae(N, I + V - Y - X) : N, I, f ? we(P, U) : P);
                    A[y] = G, k[y] = G - I;
                }
                if (a) {
                    var J, Z = "x" === y ? qt : Qt, tt = "x" === y ? Vt : Kt, et = A[w], it = "y" === w ? "height" : "width", nt = et + g[Z], st = et - g[tt], ot = -1 !== [
                        qt,
                        Qt
                    ].indexOf(_), rt = null != (J = null == x ? void 0 : x[w]) ? J : 0, at = ot ? nt : et - E[it] - T[it] - rt + O.altAxis, lt = ot ? et + E[it] + T[it] - rt - O.altAxis : st, ct = f && ot ? function(t, e, i) {
                        var n = je(t, e, i);
                        return n > i ? i : n;
                    }(at, et, lt) : je(f ? at : nt, et, f ? lt : st);
                    A[w] = ct, k[w] = ct - et;
                }
                e.modifiersData[n] = k;
            }
        },
        requiresIfExists: [
            "offset"
        ]
    };
    function fi(t, e, i) {
        void 0 === i && (i = !1);
        var n, s, o = _e(e), r = _e(e) && function(t) {
            var e = t.getBoundingClientRect(), i = Ee(e.width) / t.offsetWidth || 1, n = Ee(e.height) / t.offsetHeight || 1;
            return 1 !== i || 1 !== n;
        }(e), a = De(e), l = Oe(t, r, i), c = {
            scrollLeft: 0,
            scrollTop: 0
        }, h = {
            x: 0,
            y: 0
        };
        return (o || !o && !i) && (("body" !== pe(e) || Je(a)) && (c = (n = e) !== me(n) && _e(n) ? {
            scrollLeft: (s = n).scrollLeft,
            scrollTop: s.scrollTop
        } : Ue(n)), _e(e) ? ((h = Oe(e, !0)).x += e.clientLeft, h.y += e.clientTop) : a && (h.x = Ge(a))), {
            x: l.left + c.scrollLeft - h.x,
            y: l.top + c.scrollTop - h.y,
            width: l.width,
            height: l.height
        };
    }
    function pi(t) {
        var e = new Map, i = new Set, n = [];
        function s(t) {
            i.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach(function(t) {
                if (!i.has(t)) {
                    var n = e.get(t);
                    n && s(n);
                }
            }), n.push(t);
        }
        return t.forEach(function(t) {
            e.set(t.name, t);
        }), t.forEach(function(t) {
            i.has(t.name) || s(t);
        }), n;
    }
    var mi = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
    };
    function gi() {
        for(var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i];
        return !e.some(function(t) {
            return !(t && "function" == typeof t.getBoundingClientRect);
        });
    }
    function _i(t) {
        void 0 === t && (t = {});
        var e = t, i = e.defaultModifiers, n = void 0 === i ? [] : i, s = e.defaultOptions, o = void 0 === s ? mi : s;
        return function(t, e, i) {
            void 0 === i && (i = o);
            var s, r, a = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, mi, o),
                modifiersData: {},
                elements: {
                    reference: t,
                    popper: e
                },
                attributes: {},
                styles: {}
            }, l = [], c = !1, h = {
                state: a,
                setOptions: function(i) {
                    var s = "function" == typeof i ? i(a.options) : i;
                    d(), a.options = Object.assign({}, o, a.options, s), a.scrollParents = {
                        reference: ge(t) ? ti(t) : t.contextElement ? ti(t.contextElement) : [],
                        popper: ti(e)
                    };
                    var r, c, u = function(t) {
                        var e = pi(t);
                        return fe.reduce(function(t, i) {
                            return t.concat(e.filter(function(t) {
                                return t.phase === i;
                            }));
                        }, []);
                    }((r = [].concat(n, a.options.modifiers), c = r.reduce(function(t, e) {
                        var i = t[e.name];
                        return t[e.name] = i ? Object.assign({}, i, e, {
                            options: Object.assign({}, i.options, e.options),
                            data: Object.assign({}, i.data, e.data)
                        }) : e, t;
                    }, {}), Object.keys(c).map(function(t) {
                        return c[t];
                    })));
                    return a.orderedModifiers = u.filter(function(t) {
                        return t.enabled;
                    }), a.orderedModifiers.forEach(function(t) {
                        var e = t.name, i = t.options, n = void 0 === i ? {} : i, s = t.effect;
                        if ("function" == typeof s) {
                            var o = s({
                                state: a,
                                name: e,
                                instance: h,
                                options: n
                            });
                            l.push(o || function() {});
                        }
                    }), h.update();
                },
                forceUpdate: function() {
                    if (!c) {
                        var t = a.elements, e = t.reference, i = t.popper;
                        if (gi(e, i)) {
                            a.rects = {
                                reference: fi(e, Ne(i), "fixed" === a.options.strategy),
                                popper: xe(i)
                            }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(function(t) {
                                return a.modifiersData[t.name] = Object.assign({}, t.data);
                            });
                            for(var n = 0; n < a.orderedModifiers.length; n++)if (!0 !== a.reset) {
                                var s = a.orderedModifiers[n], o = s.fn, r = s.options, l = void 0 === r ? {} : r, d = s.name;
                                "function" == typeof o && (a = o({
                                    state: a,
                                    options: l,
                                    name: d,
                                    instance: h
                                }) || a);
                            } else a.reset = !1, n = -1;
                        }
                    }
                },
                update: (s = function() {
                    return new Promise(function(t) {
                        h.forceUpdate(), t(a);
                    });
                }, function() {
                    return r || (r = new Promise(function(t) {
                        Promise.resolve().then(function() {
                            r = void 0, t(s());
                        });
                    })), r;
                }),
                destroy: function() {
                    d(), c = !0;
                }
            };
            if (!gi(t, e)) return h;
            function d() {
                l.forEach(function(t) {
                    return t();
                }), l = [];
            }
            return h.setOptions(i).then(function(t) {
                !c && i.onFirstUpdate && i.onFirstUpdate(t);
            }), h;
        };
    }
    var bi = _i(), vi = _i({
        defaultModifiers: [
            Ve,
            di,
            Re,
            ve
        ]
    }), yi = _i({
        defaultModifiers: [
            Ve,
            di,
            Re,
            ve,
            hi,
            ri,
            ui,
            He,
            ci
        ]
    });
    const wi = Object.freeze(Object.defineProperty({
        __proto__: null,
        afterMain: ce,
        afterRead: re,
        afterWrite: ue,
        applyStyles: ve,
        arrow: He,
        auto: Xt,
        basePlacements: Yt,
        beforeMain: ae,
        beforeRead: se,
        beforeWrite: he,
        bottom: Vt,
        clippingParents: Jt,
        computeStyles: Re,
        createPopper: yi,
        createPopperBase: bi,
        createPopperLite: vi,
        detectOverflow: si,
        end: Gt,
        eventListeners: Ve,
        flip: ri,
        hide: ci,
        left: Qt,
        main: le,
        modifierPhases: fe,
        offset: hi,
        placements: ne,
        popper: te,
        popperGenerator: _i,
        popperOffsets: di,
        preventOverflow: ui,
        read: oe,
        reference: ee,
        right: Kt,
        start: Ut,
        top: qt,
        variationPlacements: ie,
        viewport: Zt,
        write: de
    }, Symbol.toStringTag, {
        value: "Module"
    })), Ai = "dropdown", Ei = ".bs.dropdown", Ti = ".data-api", Ci = "ArrowUp", Oi = "ArrowDown", xi = `hide${Ei}`, ki = `hidden${Ei}`, Li = `show${Ei}`, Si = `shown${Ei}`, Di = `click${Ei}${Ti}`, $i = `keydown${Ei}${Ti}`, Ii = `keyup${Ei}${Ti}`, Ni = "show", Pi = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', ji = `${Pi}.${Ni}`, Mi = ".dropdown-menu", Fi = p() ? "top-end" : "top-start", Hi = p() ? "top-start" : "top-end", Wi = p() ? "bottom-end" : "bottom-start", Bi = p() ? "bottom-start" : "bottom-end", zi = p() ? "left-start" : "right-start", Ri = p() ? "right-start" : "left-start", qi = {
        autoClose: !0,
        boundary: "clippingParents",
        display: "dynamic",
        offset: [
            0,
            2
        ],
        popperConfig: null,
        reference: "toggle"
    }, Vi = {
        autoClose: "(boolean|string)",
        boundary: "(string|element)",
        display: "string",
        offset: "(array|string|function)",
        popperConfig: "(null|object|function)",
        reference: "(string|element|object)"
    };
    class Ki extends W {
        constructor(t, e){
            super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = z.next(this._element, Mi)[0] || z.prev(this._element, Mi)[0] || z.findOne(Mi, this._parent), this._inNavbar = this._detectNavbar();
        }
        static get Default() {
            return qi;
        }
        static get DefaultType() {
            return Vi;
        }
        static get NAME() {
            return Ai;
        }
        toggle() {
            return this._isShown() ? this.hide() : this.show();
        }
        show() {
            if (l(this._element) || this._isShown()) return;
            const t = {
                relatedTarget: this._element
            };
            if (!N.trigger(this._element, Li, t).defaultPrevented) {
                if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (const t of [].concat(...document.body.children))N.on(t, "mouseover", h);
                this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Ni), this._element.classList.add(Ni), N.trigger(this._element, Si, t);
            }
        }
        hide() {
            if (l(this._element) || !this._isShown()) return;
            const t = {
                relatedTarget: this._element
            };
            this._completeHide(t);
        }
        dispose() {
            this._popper && this._popper.destroy(), super.dispose();
        }
        update() {
            this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
        }
        _completeHide(t) {
            if (!N.trigger(this._element, xi, t).defaultPrevented) {
                if ("ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children))N.off(t, "mouseover", h);
                this._popper && this._popper.destroy(), this._menu.classList.remove(Ni), this._element.classList.remove(Ni), this._element.setAttribute("aria-expanded", "false"), F.removeDataAttribute(this._menu, "popper"), N.trigger(this._element, ki, t), this._element.focus();
            }
        }
        _getConfig(t) {
            if ("object" == typeof (t = super._getConfig(t)).reference && !o(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError(`${Ai.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
            return t;
        }
        _createPopper() {
            if (void 0 === wi) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org/docs/v2/)");
            let t = this._element;
            "parent" === this._config.reference ? t = this._parent : o(this._config.reference) ? t = r(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference);
            const e = this._getPopperConfig();
            this._popper = yi(t, this._menu, e);
        }
        _isShown() {
            return this._menu.classList.contains(Ni);
        }
        _getPlacement() {
            const t = this._parent;
            if (t.classList.contains("dropend")) return zi;
            if (t.classList.contains("dropstart")) return Ri;
            if (t.classList.contains("dropup-center")) return "top";
            if (t.classList.contains("dropdown-center")) return "bottom";
            const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
            return t.classList.contains("dropup") ? e ? Hi : Fi : e ? Bi : Wi;
        }
        _detectNavbar() {
            return null !== this._element.closest(".navbar");
        }
        _getOffset() {
            const { offset: t } = this._config;
            return "string" == typeof t ? t.split(",").map((t)=>Number.parseInt(t, 10)) : "function" == typeof t ? (e)=>t(e, this._element) : t;
        }
        _getPopperConfig() {
            const t = {
                placement: this._getPlacement(),
                modifiers: [
                    {
                        name: "preventOverflow",
                        options: {
                            boundary: this._config.boundary
                        }
                    },
                    {
                        name: "offset",
                        options: {
                            offset: this._getOffset()
                        }
                    }
                ]
            };
            return (this._inNavbar || "static" === this._config.display) && (F.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [
                {
                    name: "applyStyles",
                    enabled: !1
                }
            ]), {
                ...t,
                ...g(this._config.popperConfig, [
                    void 0,
                    t
                ])
            };
        }
        _selectMenuItem({ key: t, target: e }) {
            const i = z.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((t)=>a(t));
            i.length && b(i, e, t === Oi, !i.includes(e)).focus();
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Ki.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t]();
                }
            });
        }
        static clearMenus(t) {
            if (2 === t.button || "keyup" === t.type && "Tab" !== t.key) return;
            const e = z.find(ji);
            for (const i of e){
                const e = Ki.getInstance(i);
                if (!e || !1 === e._config.autoClose) continue;
                const n = t.composedPath(), s = n.includes(e._menu);
                if (n.includes(e._element) || "inside" === e._config.autoClose && !s || "outside" === e._config.autoClose && s) continue;
                if (e._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName))) continue;
                const o = {
                    relatedTarget: e._element
                };
                "click" === t.type && (o.clickEvent = t), e._completeHide(o);
            }
        }
        static dataApiKeydownHandler(t) {
            const e = /input|textarea/i.test(t.target.tagName), i = "Escape" === t.key, n = [
                Ci,
                Oi
            ].includes(t.key);
            if (!n && !i) return;
            if (e && !i) return;
            t.preventDefault();
            const s = this.matches(Pi) ? this : z.prev(this, Pi)[0] || z.next(this, Pi)[0] || z.findOne(Pi, t.delegateTarget.parentNode), o = Ki.getOrCreateInstance(s);
            if (n) return t.stopPropagation(), o.show(), void o._selectMenuItem(t);
            o._isShown() && (t.stopPropagation(), o.hide(), s.focus());
        }
    }
    N.on(document, $i, Pi, Ki.dataApiKeydownHandler), N.on(document, $i, Mi, Ki.dataApiKeydownHandler), N.on(document, Di, Ki.clearMenus), N.on(document, Ii, Ki.clearMenus), N.on(document, Di, Pi, function(t) {
        t.preventDefault(), Ki.getOrCreateInstance(this).toggle();
    }), m(Ki);
    const Qi = "backdrop", Xi = "show", Yi = `mousedown.bs.${Qi}`, Ui = {
        className: "modal-backdrop",
        clickCallback: null,
        isAnimated: !1,
        isVisible: !0,
        rootElement: "body"
    }, Gi = {
        className: "string",
        clickCallback: "(function|null)",
        isAnimated: "boolean",
        isVisible: "boolean",
        rootElement: "(element|string)"
    };
    class Ji extends H {
        constructor(t){
            super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null;
        }
        static get Default() {
            return Ui;
        }
        static get DefaultType() {
            return Gi;
        }
        static get NAME() {
            return Qi;
        }
        show(t) {
            if (!this._config.isVisible) return void g(t);
            this._append();
            const e = this._getElement();
            this._config.isAnimated && d(e), e.classList.add(Xi), this._emulateAnimation(()=>{
                g(t);
            });
        }
        hide(t) {
            this._config.isVisible ? (this._getElement().classList.remove(Xi), this._emulateAnimation(()=>{
                this.dispose(), g(t);
            })) : g(t);
        }
        dispose() {
            this._isAppended && (N.off(this._element, Yi), this._element.remove(), this._isAppended = !1);
        }
        _getElement() {
            if (!this._element) {
                const t = document.createElement("div");
                t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t;
            }
            return this._element;
        }
        _configAfterMerge(t) {
            return t.rootElement = r(t.rootElement), t;
        }
        _append() {
            if (this._isAppended) return;
            const t = this._getElement();
            this._config.rootElement.append(t), N.on(t, Yi, ()=>{
                g(this._config.clickCallback);
            }), this._isAppended = !0;
        }
        _emulateAnimation(t) {
            _(t, this._getElement(), this._config.isAnimated);
        }
    }
    const Zi = ".bs.focustrap", tn = `focusin${Zi}`, en = `keydown.tab${Zi}`, nn = "backward", sn = {
        autofocus: !0,
        trapElement: null
    }, on = {
        autofocus: "boolean",
        trapElement: "element"
    };
    class rn extends H {
        constructor(t){
            super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null;
        }
        static get Default() {
            return sn;
        }
        static get DefaultType() {
            return on;
        }
        static get NAME() {
            return "focustrap";
        }
        activate() {
            this._isActive || (this._config.autofocus && this._config.trapElement.focus(), N.off(document, Zi), N.on(document, tn, (t)=>this._handleFocusin(t)), N.on(document, en, (t)=>this._handleKeydown(t)), this._isActive = !0);
        }
        deactivate() {
            this._isActive && (this._isActive = !1, N.off(document, Zi));
        }
        _handleFocusin(t) {
            const { trapElement: e } = this._config;
            if (t.target === document || t.target === e || e.contains(t.target)) return;
            const i = z.focusableChildren(e);
            0 === i.length ? e.focus() : this._lastTabNavDirection === nn ? i[i.length - 1].focus() : i[0].focus();
        }
        _handleKeydown(t) {
            "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? nn : "forward");
        }
    }
    const an = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", ln = ".sticky-top", cn = "padding-right", hn = "margin-right";
    class dn {
        constructor(){
            this._element = document.body;
        }
        getWidth() {
            const t = document.documentElement.clientWidth;
            return Math.abs(window.innerWidth - t);
        }
        hide() {
            const t = this.getWidth();
            this._disableOverFlow(), this._setElementAttributes(this._element, cn, (e)=>e + t), this._setElementAttributes(an, cn, (e)=>e + t), this._setElementAttributes(ln, hn, (e)=>e - t);
        }
        reset() {
            this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, cn), this._resetElementAttributes(an, cn), this._resetElementAttributes(ln, hn);
        }
        isOverflowing() {
            return this.getWidth() > 0;
        }
        _disableOverFlow() {
            this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
        }
        _setElementAttributes(t, e, i) {
            const n = this.getWidth();
            this._applyManipulationCallback(t, (t)=>{
                if (t !== this._element && window.innerWidth > t.clientWidth + n) return;
                this._saveInitialAttribute(t, e);
                const s = window.getComputedStyle(t).getPropertyValue(e);
                t.style.setProperty(e, `${i(Number.parseFloat(s))}px`);
            });
        }
        _saveInitialAttribute(t, e) {
            const i = t.style.getPropertyValue(e);
            i && F.setDataAttribute(t, e, i);
        }
        _resetElementAttributes(t, e) {
            this._applyManipulationCallback(t, (t)=>{
                const i = F.getDataAttribute(t, e);
                null !== i ? (F.removeDataAttribute(t, e), t.style.setProperty(e, i)) : t.style.removeProperty(e);
            });
        }
        _applyManipulationCallback(t, e) {
            if (o(t)) e(t);
            else for (const i of z.find(t, this._element))e(i);
        }
    }
    const un = ".bs.modal", fn = `hide${un}`, pn = `hidePrevented${un}`, mn = `hidden${un}`, gn = `show${un}`, _n = `shown${un}`, bn = `resize${un}`, vn = `click.dismiss${un}`, yn = `mousedown.dismiss${un}`, wn = `keydown.dismiss${un}`, An = `click${un}.data-api`, En = "modal-open", Tn = "show", Cn = "modal-static", On = {
        backdrop: !0,
        focus: !0,
        keyboard: !0
    }, xn = {
        backdrop: "(boolean|string)",
        focus: "boolean",
        keyboard: "boolean"
    };
    class kn extends W {
        constructor(t, e){
            super(t, e), this._dialog = z.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new dn, this._addEventListeners();
        }
        static get Default() {
            return On;
        }
        static get DefaultType() {
            return xn;
        }
        static get NAME() {
            return "modal";
        }
        toggle(t) {
            return this._isShown ? this.hide() : this.show(t);
        }
        show(t) {
            this._isShown || this._isTransitioning || N.trigger(this._element, gn, {
                relatedTarget: t
            }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(En), this._adjustDialog(), this._backdrop.show(()=>this._showElement(t)));
        }
        hide() {
            this._isShown && !this._isTransitioning && (N.trigger(this._element, fn).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(Tn), this._queueCallback(()=>this._hideModal(), this._element, this._isAnimated())));
        }
        dispose() {
            N.off(window, un), N.off(this._dialog, un), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
        }
        handleUpdate() {
            this._adjustDialog();
        }
        _initializeBackDrop() {
            return new Ji({
                isVisible: Boolean(this._config.backdrop),
                isAnimated: this._isAnimated()
            });
        }
        _initializeFocusTrap() {
            return new rn({
                trapElement: this._element
            });
        }
        _showElement(t) {
            document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
            const e = z.findOne(".modal-body", this._dialog);
            e && (e.scrollTop = 0), d(this._element), this._element.classList.add(Tn), this._queueCallback(()=>{
                this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, N.trigger(this._element, _n, {
                    relatedTarget: t
                });
            }, this._dialog, this._isAnimated());
        }
        _addEventListeners() {
            N.on(this._element, wn, (t)=>{
                "Escape" === t.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition());
            }), N.on(window, bn, ()=>{
                this._isShown && !this._isTransitioning && this._adjustDialog();
            }), N.on(this._element, yn, (t)=>{
                N.one(this._element, vn, (e)=>{
                    this._element === t.target && this._element === e.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition());
                });
            });
        }
        _hideModal() {
            this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(()=>{
                document.body.classList.remove(En), this._resetAdjustments(), this._scrollBar.reset(), N.trigger(this._element, mn);
            });
        }
        _isAnimated() {
            return this._element.classList.contains("fade");
        }
        _triggerBackdropTransition() {
            if (N.trigger(this._element, pn).defaultPrevented) return;
            const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._element.style.overflowY;
            "hidden" === e || this._element.classList.contains(Cn) || (t || (this._element.style.overflowY = "hidden"), this._element.classList.add(Cn), this._queueCallback(()=>{
                this._element.classList.remove(Cn), this._queueCallback(()=>{
                    this._element.style.overflowY = e;
                }, this._dialog);
            }, this._dialog), this._element.focus());
        }
        _adjustDialog() {
            const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), i = e > 0;
            if (i && !t) {
                const t = p() ? "paddingLeft" : "paddingRight";
                this._element.style[t] = `${e}px`;
            }
            if (!i && t) {
                const t = p() ? "paddingRight" : "paddingLeft";
                this._element.style[t] = `${e}px`;
            }
        }
        _resetAdjustments() {
            this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                const i = kn.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
                    i[t](e);
                }
            });
        }
    }
    N.on(document, An, '[data-bs-toggle="modal"]', function(t) {
        const e = z.getElementFromSelector(this);
        [
            "A",
            "AREA"
        ].includes(this.tagName) && t.preventDefault(), N.one(e, gn, (t)=>{
            t.defaultPrevented || N.one(e, mn, ()=>{
                a(this) && this.focus();
            });
        });
        const i = z.findOne(".modal.show");
        i && kn.getInstance(i).hide(), kn.getOrCreateInstance(e).toggle(this);
    }), R(kn), m(kn);
    const Ln = ".bs.offcanvas", Sn = ".data-api", Dn = `load${Ln}${Sn}`, $n = "show", In = "showing", Nn = "hiding", Pn = ".offcanvas.show", jn = `show${Ln}`, Mn = `shown${Ln}`, Fn = `hide${Ln}`, Hn = `hidePrevented${Ln}`, Wn = `hidden${Ln}`, Bn = `resize${Ln}`, zn = `click${Ln}${Sn}`, Rn = `keydown.dismiss${Ln}`, qn = {
        backdrop: !0,
        keyboard: !0,
        scroll: !1
    }, Vn = {
        backdrop: "(boolean|string)",
        keyboard: "boolean",
        scroll: "boolean"
    };
    class Kn extends W {
        constructor(t, e){
            super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
        }
        static get Default() {
            return qn;
        }
        static get DefaultType() {
            return Vn;
        }
        static get NAME() {
            return "offcanvas";
        }
        toggle(t) {
            return this._isShown ? this.hide() : this.show(t);
        }
        show(t) {
            this._isShown || N.trigger(this._element, jn, {
                relatedTarget: t
            }).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || (new dn).hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(In), this._queueCallback(()=>{
                this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add($n), this._element.classList.remove(In), N.trigger(this._element, Mn, {
                    relatedTarget: t
                });
            }, this._element, !0));
        }
        hide() {
            this._isShown && (N.trigger(this._element, Fn).defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(Nn), this._backdrop.hide(), this._queueCallback(()=>{
                this._element.classList.remove($n, Nn), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || (new dn).reset(), N.trigger(this._element, Wn);
            }, this._element, !0)));
        }
        dispose() {
            this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
        }
        _initializeBackDrop() {
            const t = Boolean(this._config.backdrop);
            return new Ji({
                className: "offcanvas-backdrop",
                isVisible: t,
                isAnimated: !0,
                rootElement: this._element.parentNode,
                clickCallback: t ? ()=>{
                    "static" !== this._config.backdrop ? this.hide() : N.trigger(this._element, Hn);
                } : null
            });
        }
        _initializeFocusTrap() {
            return new rn({
                trapElement: this._element
            });
        }
        _addEventListeners() {
            N.on(this._element, Rn, (t)=>{
                "Escape" === t.key && (this._config.keyboard ? this.hide() : N.trigger(this._element, Hn));
            });
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Kn.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                    e[t](this);
                }
            });
        }
    }
    N.on(document, zn, '[data-bs-toggle="offcanvas"]', function(t) {
        const e = z.getElementFromSelector(this);
        if ([
            "A",
            "AREA"
        ].includes(this.tagName) && t.preventDefault(), l(this)) return;
        N.one(e, Wn, ()=>{
            a(this) && this.focus();
        });
        const i = z.findOne(Pn);
        i && i !== e && Kn.getInstance(i).hide(), Kn.getOrCreateInstance(e).toggle(this);
    }), N.on(window, Dn, ()=>{
        for (const t of z.find(Pn))Kn.getOrCreateInstance(t).show();
    }), N.on(window, Bn, ()=>{
        for (const t of z.find("[aria-modal][class*=show][class*=offcanvas-]"))"fixed" !== getComputedStyle(t).position && Kn.getOrCreateInstance(t).hide();
    }), R(Kn), m(Kn);
    const Qn = {
        "*": [
            "class",
            "dir",
            "id",
            "lang",
            "role",
            /^aria-[\w-]*$/i
        ],
        a: [
            "target",
            "href",
            "title",
            "rel"
        ],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        dd: [],
        div: [],
        dl: [],
        dt: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: [
            "src",
            "srcset",
            "alt",
            "title",
            "width",
            "height"
        ],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
    }, Xn = new Set([
        "background",
        "cite",
        "href",
        "itemtype",
        "longdesc",
        "poster",
        "src",
        "xlink:href"
    ]), Yn = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, Un = (t, e)=>{
        const i = t.nodeName.toLowerCase();
        return e.includes(i) ? !Xn.has(i) || Boolean(Yn.test(t.nodeValue)) : e.filter((t)=>t instanceof RegExp).some((t)=>t.test(i));
    }, Gn = {
        allowList: Qn,
        content: {},
        extraClass: "",
        html: !1,
        sanitize: !0,
        sanitizeFn: null,
        template: "<div></div>"
    }, Jn = {
        allowList: "object",
        content: "object",
        extraClass: "(string|function)",
        html: "boolean",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        template: "string"
    }, Zn = {
        entry: "(string|element|function|null)",
        selector: "(string|element)"
    };
    class ts extends H {
        constructor(t){
            super(), this._config = this._getConfig(t);
        }
        static get Default() {
            return Gn;
        }
        static get DefaultType() {
            return Jn;
        }
        static get NAME() {
            return "TemplateFactory";
        }
        getContent() {
            return Object.values(this._config.content).map((t)=>this._resolvePossibleFunction(t)).filter(Boolean);
        }
        hasContent() {
            return this.getContent().length > 0;
        }
        changeContent(t) {
            return this._checkContent(t), this._config.content = {
                ...this._config.content,
                ...t
            }, this;
        }
        toHtml() {
            const t = document.createElement("div");
            t.innerHTML = this._maybeSanitize(this._config.template);
            for (const [e, i] of Object.entries(this._config.content))this._setContent(t, i, e);
            const e = t.children[0], i = this._resolvePossibleFunction(this._config.extraClass);
            return i && e.classList.add(...i.split(" ")), e;
        }
        _typeCheckConfig(t) {
            super._typeCheckConfig(t), this._checkContent(t.content);
        }
        _checkContent(t) {
            for (const [e, i] of Object.entries(t))super._typeCheckConfig({
                selector: e,
                entry: i
            }, Zn);
        }
        _setContent(t, e, i) {
            const n = z.findOne(i, t);
            n && ((e = this._resolvePossibleFunction(e)) ? o(e) ? this._putElementInTemplate(r(e), n) : this._config.html ? n.innerHTML = this._maybeSanitize(e) : n.textContent = e : n.remove());
        }
        _maybeSanitize(t) {
            return this._config.sanitize ? function(t, e, i) {
                if (!t.length) return t;
                if (i && "function" == typeof i) return i(t);
                const n = (new window.DOMParser).parseFromString(t, "text/html"), s = [].concat(...n.body.querySelectorAll("*"));
                for (const t of s){
                    const i = t.nodeName.toLowerCase();
                    if (!Object.keys(e).includes(i)) {
                        t.remove();
                        continue;
                    }
                    const n = [].concat(...t.attributes), s = [].concat(e["*"] || [], e[i] || []);
                    for (const e of n)Un(e, s) || t.removeAttribute(e.nodeName);
                }
                return n.body.innerHTML;
            }(t, this._config.allowList, this._config.sanitizeFn) : t;
        }
        _resolvePossibleFunction(t) {
            return g(t, [
                void 0,
                this
            ]);
        }
        _putElementInTemplate(t, e) {
            if (this._config.html) return e.innerHTML = "", void e.append(t);
            e.textContent = t.textContent;
        }
    }
    const es = new Set([
        "sanitize",
        "allowList",
        "sanitizeFn"
    ]), is = "fade", ns = "show", ss = ".tooltip-inner", os = ".modal", rs = "hide.bs.modal", as = "hover", ls = "focus", cs = "click", hs = {
        AUTO: "auto",
        TOP: "top",
        RIGHT: p() ? "left" : "right",
        BOTTOM: "bottom",
        LEFT: p() ? "right" : "left"
    }, ds = {
        allowList: Qn,
        animation: !0,
        boundary: "clippingParents",
        container: !1,
        customClass: "",
        delay: 0,
        fallbackPlacements: [
            "top",
            "right",
            "bottom",
            "left"
        ],
        html: !1,
        offset: [
            0,
            6
        ],
        placement: "top",
        popperConfig: null,
        sanitize: !0,
        sanitizeFn: null,
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        title: "",
        trigger: "hover focus"
    }, us = {
        allowList: "object",
        animation: "boolean",
        boundary: "(string|element)",
        container: "(string|element|boolean)",
        customClass: "(string|function)",
        delay: "(number|object)",
        fallbackPlacements: "array",
        html: "boolean",
        offset: "(array|string|function)",
        placement: "(string|function)",
        popperConfig: "(null|object|function)",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        selector: "(string|boolean)",
        template: "string",
        title: "(string|element|function)",
        trigger: "string"
    };
    class fs extends W {
        constructor(t, e){
            if (void 0 === wi) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org/docs/v2/)");
            super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle();
        }
        static get Default() {
            return ds;
        }
        static get DefaultType() {
            return us;
        }
        static get NAME() {
            return "tooltip";
        }
        enable() {
            this._isEnabled = !0;
        }
        disable() {
            this._isEnabled = !1;
        }
        toggleEnabled() {
            this._isEnabled = !this._isEnabled;
        }
        toggle() {
            this._isEnabled && (this._isShown() ? this._leave() : this._enter());
        }
        dispose() {
            clearTimeout(this._timeout), N.off(this._element.closest(os), rs, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose();
        }
        show() {
            if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
            if (!this._isWithContent() || !this._isEnabled) return;
            const t = N.trigger(this._element, this.constructor.eventName("show")), e = (c(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
            if (t.defaultPrevented || !e) return;
            this._disposePopper();
            const i = this._getTipElement();
            this._element.setAttribute("aria-describedby", i.getAttribute("id"));
            const { container: n } = this._config;
            if (this._element.ownerDocument.documentElement.contains(this.tip) || (n.append(i), N.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i), i.classList.add(ns), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children))N.on(t, "mouseover", h);
            this._queueCallback(()=>{
                N.trigger(this._element, this.constructor.eventName("shown")), !1 === this._isHovered && this._leave(), this._isHovered = !1;
            }, this.tip, this._isAnimated());
        }
        hide() {
            if (this._isShown() && !N.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
                if (this._getTipElement().classList.remove(ns), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children))N.off(t, "mouseover", h);
                this._activeTrigger[cs] = !1, this._activeTrigger[ls] = !1, this._activeTrigger[as] = !1, this._isHovered = null, this._queueCallback(()=>{
                    this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), N.trigger(this._element, this.constructor.eventName("hidden")));
                }, this.tip, this._isAnimated());
            }
        }
        update() {
            this._popper && this._popper.update();
        }
        _isWithContent() {
            return Boolean(this._getTitle());
        }
        _getTipElement() {
            return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
        }
        _createTipElement(t) {
            const e = this._getTemplateFactory(t).toHtml();
            if (!e) return null;
            e.classList.remove(is, ns), e.classList.add(`bs-${this.constructor.NAME}-auto`);
            const i = ((t)=>{
                do t += Math.floor(1e6 * Math.random());
                while (document.getElementById(t));
                return t;
            })(this.constructor.NAME).toString();
            return e.setAttribute("id", i), this._isAnimated() && e.classList.add(is), e;
        }
        setContent(t) {
            this._newContent = t, this._isShown() && (this._disposePopper(), this.show());
        }
        _getTemplateFactory(t) {
            return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new ts({
                ...this._config,
                content: t,
                extraClass: this._resolvePossibleFunction(this._config.customClass)
            }), this._templateFactory;
        }
        _getContentForTemplate() {
            return {
                [ss]: this._getTitle()
            };
        }
        _getTitle() {
            return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
        }
        _initializeOnDelegatedTarget(t) {
            return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig());
        }
        _isAnimated() {
            return this._config.animation || this.tip && this.tip.classList.contains(is);
        }
        _isShown() {
            return this.tip && this.tip.classList.contains(ns);
        }
        _createPopper(t) {
            const e = g(this._config.placement, [
                this,
                t,
                this._element
            ]), i = hs[e.toUpperCase()];
            return yi(this._element, t, this._getPopperConfig(i));
        }
        _getOffset() {
            const { offset: t } = this._config;
            return "string" == typeof t ? t.split(",").map((t)=>Number.parseInt(t, 10)) : "function" == typeof t ? (e)=>t(e, this._element) : t;
        }
        _resolvePossibleFunction(t) {
            return g(t, [
                this._element,
                this._element
            ]);
        }
        _getPopperConfig(t) {
            const e = {
                placement: t,
                modifiers: [
                    {
                        name: "flip",
                        options: {
                            fallbackPlacements: this._config.fallbackPlacements
                        }
                    },
                    {
                        name: "offset",
                        options: {
                            offset: this._getOffset()
                        }
                    },
                    {
                        name: "preventOverflow",
                        options: {
                            boundary: this._config.boundary
                        }
                    },
                    {
                        name: "arrow",
                        options: {
                            element: `.${this.constructor.NAME}-arrow`
                        }
                    },
                    {
                        name: "preSetPlacement",
                        enabled: !0,
                        phase: "beforeMain",
                        fn: (t)=>{
                            this._getTipElement().setAttribute("data-popper-placement", t.state.placement);
                        }
                    }
                ]
            };
            return {
                ...e,
                ...g(this._config.popperConfig, [
                    void 0,
                    e
                ])
            };
        }
        _setListeners() {
            const t = this._config.trigger.split(" ");
            for (const e of t)if ("click" === e) N.on(this._element, this.constructor.eventName("click"), this._config.selector, (t)=>{
                const e = this._initializeOnDelegatedTarget(t);
                e._activeTrigger[cs] = !(e._isShown() && e._activeTrigger[cs]), e.toggle();
            });
            else if ("manual" !== e) {
                const t = e === as ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), i = e === as ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
                N.on(this._element, t, this._config.selector, (t)=>{
                    const e = this._initializeOnDelegatedTarget(t);
                    e._activeTrigger["focusin" === t.type ? ls : as] = !0, e._enter();
                }), N.on(this._element, i, this._config.selector, (t)=>{
                    const e = this._initializeOnDelegatedTarget(t);
                    e._activeTrigger["focusout" === t.type ? ls : as] = e._element.contains(t.relatedTarget), e._leave();
                });
            }
            this._hideModalHandler = ()=>{
                this._element && this.hide();
            }, N.on(this._element.closest(os), rs, this._hideModalHandler);
        }
        _fixTitle() {
            const t = this._element.getAttribute("title");
            t && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t), this._element.setAttribute("data-bs-original-title", t), this._element.removeAttribute("title"));
        }
        _enter() {
            this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout(()=>{
                this._isHovered && this.show();
            }, this._config.delay.show));
        }
        _leave() {
            this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(()=>{
                this._isHovered || this.hide();
            }, this._config.delay.hide));
        }
        _setTimeout(t, e) {
            clearTimeout(this._timeout), this._timeout = setTimeout(t, e);
        }
        _isWithActiveTrigger() {
            return Object.values(this._activeTrigger).includes(!0);
        }
        _getConfig(t) {
            const e = F.getDataAttributes(this._element);
            for (const t of Object.keys(e))es.has(t) && delete e[t];
            return t = {
                ...e,
                ..."object" == typeof t && t ? t : {}
            }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
        }
        _configAfterMerge(t) {
            return t.container = !1 === t.container ? document.body : r(t.container), "number" == typeof t.delay && (t.delay = {
                show: t.delay,
                hide: t.delay
            }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), t;
        }
        _getDelegateConfig() {
            const t = {};
            for (const [e, i] of Object.entries(this._config))this.constructor.Default[e] !== i && (t[e] = i);
            return t.selector = !1, t.trigger = "manual", t;
        }
        _disposePopper() {
            this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null);
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = fs.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t]();
                }
            });
        }
    }
    m(fs);
    const ps = ".popover-header", ms = ".popover-body", gs = {
        ...fs.Default,
        content: "",
        offset: [
            0,
            8
        ],
        placement: "right",
        template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
        trigger: "click"
    }, _s = {
        ...fs.DefaultType,
        content: "(null|string|element|function)"
    };
    class bs extends fs {
        static get Default() {
            return gs;
        }
        static get DefaultType() {
            return _s;
        }
        static get NAME() {
            return "popover";
        }
        _isWithContent() {
            return this._getTitle() || this._getContent();
        }
        _getContentForTemplate() {
            return {
                [ps]: this._getTitle(),
                [ms]: this._getContent()
            };
        }
        _getContent() {
            return this._resolvePossibleFunction(this._config.content);
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = bs.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t]();
                }
            });
        }
    }
    m(bs);
    const vs = ".bs.scrollspy", ys = `activate${vs}`, ws = `click${vs}`, As = `load${vs}.data-api`, Es = "active", Ts = "[href]", Cs = ".nav-link", Os = `${Cs}, .nav-item > ${Cs}, .list-group-item`, xs = {
        offset: null,
        rootMargin: "0px 0px -25%",
        smoothScroll: !1,
        target: null,
        threshold: [
            .1,
            .5,
            1
        ]
    }, ks = {
        offset: "(number|null)",
        rootMargin: "string",
        smoothScroll: "boolean",
        target: "element",
        threshold: "array"
    };
    class Ls extends W {
        constructor(t, e){
            super(t, e), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
                visibleEntryTop: 0,
                parentScrollTop: 0
            }, this.refresh();
        }
        static get Default() {
            return xs;
        }
        static get DefaultType() {
            return ks;
        }
        static get NAME() {
            return "scrollspy";
        }
        refresh() {
            this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
            for (const t of this._observableSections.values())this._observer.observe(t);
        }
        dispose() {
            this._observer.disconnect(), super.dispose();
        }
        _configAfterMerge(t) {
            return t.target = r(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, "string" == typeof t.threshold && (t.threshold = t.threshold.split(",").map((t)=>Number.parseFloat(t))), t;
        }
        _maybeEnableSmoothScroll() {
            this._config.smoothScroll && (N.off(this._config.target, ws), N.on(this._config.target, ws, Ts, (t)=>{
                const e = this._observableSections.get(t.target.hash);
                if (e) {
                    t.preventDefault();
                    const i = this._rootElement || window, n = e.offsetTop - this._element.offsetTop;
                    if (i.scrollTo) return void i.scrollTo({
                        top: n,
                        behavior: "smooth"
                    });
                    i.scrollTop = n;
                }
            }));
        }
        _getNewObserver() {
            const t = {
                root: this._rootElement,
                threshold: this._config.threshold,
                rootMargin: this._config.rootMargin
            };
            return new IntersectionObserver((t)=>this._observerCallback(t), t);
        }
        _observerCallback(t) {
            const e = (t)=>this._targetLinks.get(`#${t.target.id}`), i = (t)=>{
                this._previousScrollData.visibleEntryTop = t.target.offsetTop, this._process(e(t));
            }, n = (this._rootElement || document.documentElement).scrollTop, s = n >= this._previousScrollData.parentScrollTop;
            this._previousScrollData.parentScrollTop = n;
            for (const o of t){
                if (!o.isIntersecting) {
                    this._activeTarget = null, this._clearActiveClass(e(o));
                    continue;
                }
                const t = o.target.offsetTop >= this._previousScrollData.visibleEntryTop;
                if (s && t) {
                    if (i(o), !n) return;
                } else s || t || i(o);
            }
        }
        _initializeTargetsAndObservables() {
            this._targetLinks = new Map, this._observableSections = new Map;
            const t = z.find(Ts, this._config.target);
            for (const e of t){
                if (!e.hash || l(e)) continue;
                const t = z.findOne(decodeURI(e.hash), this._element);
                a(t) && (this._targetLinks.set(decodeURI(e.hash), e), this._observableSections.set(e.hash, t));
            }
        }
        _process(t) {
            this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(Es), this._activateParents(t), N.trigger(this._element, ys, {
                relatedTarget: t
            }));
        }
        _activateParents(t) {
            if (t.classList.contains("dropdown-item")) z.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(Es);
            else for (const e of z.parents(t, ".nav, .list-group"))for (const t of z.prev(e, Os))t.classList.add(Es);
        }
        _clearActiveClass(t) {
            t.classList.remove(Es);
            const e = z.find(`${Ts}.${Es}`, t);
            for (const t of e)t.classList.remove(Es);
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Ls.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                    e[t]();
                }
            });
        }
    }
    N.on(window, As, ()=>{
        for (const t of z.find('[data-bs-spy="scroll"]'))Ls.getOrCreateInstance(t);
    }), m(Ls);
    const Ss = ".bs.tab", Ds = `hide${Ss}`, $s = `hidden${Ss}`, Is = `show${Ss}`, Ns = `shown${Ss}`, Ps = `click${Ss}`, js = `keydown${Ss}`, Ms = `load${Ss}`, Fs = "ArrowLeft", Hs = "ArrowRight", Ws = "ArrowUp", Bs = "ArrowDown", zs = "Home", Rs = "End", qs = "active", Vs = "fade", Ks = "show", Qs = ".dropdown-toggle", Xs = `:not(${Qs})`, Ys = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', Us = `.nav-link${Xs}, .list-group-item${Xs}, [role="tab"]${Xs}, ${Ys}`, Gs = `.${qs}[data-bs-toggle="tab"], .${qs}[data-bs-toggle="pill"], .${qs}[data-bs-toggle="list"]`;
    class Js extends W {
        constructor(t){
            super(t), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), N.on(this._element, js, (t)=>this._keydown(t)));
        }
        static get NAME() {
            return "tab";
        }
        show() {
            const t = this._element;
            if (this._elemIsActive(t)) return;
            const e = this._getActiveElem(), i = e ? N.trigger(e, Ds, {
                relatedTarget: t
            }) : null;
            N.trigger(t, Is, {
                relatedTarget: e
            }).defaultPrevented || i && i.defaultPrevented || (this._deactivate(e, t), this._activate(t, e));
        }
        _activate(t, e) {
            t && (t.classList.add(qs), this._activate(z.getElementFromSelector(t)), this._queueCallback(()=>{
                "tab" === t.getAttribute("role") ? (t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), N.trigger(t, Ns, {
                    relatedTarget: e
                })) : t.classList.add(Ks);
            }, t, t.classList.contains(Vs)));
        }
        _deactivate(t, e) {
            t && (t.classList.remove(qs), t.blur(), this._deactivate(z.getElementFromSelector(t)), this._queueCallback(()=>{
                "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), N.trigger(t, $s, {
                    relatedTarget: e
                })) : t.classList.remove(Ks);
            }, t, t.classList.contains(Vs)));
        }
        _keydown(t) {
            if (![
                Fs,
                Hs,
                Ws,
                Bs,
                zs,
                Rs
            ].includes(t.key)) return;
            t.stopPropagation(), t.preventDefault();
            const e = this._getChildren().filter((t)=>!l(t));
            let i;
            if ([
                zs,
                Rs
            ].includes(t.key)) i = e[t.key === zs ? 0 : e.length - 1];
            else {
                const n = [
                    Hs,
                    Bs
                ].includes(t.key);
                i = b(e, t.target, n, !0);
            }
            i && (i.focus({
                preventScroll: !0
            }), Js.getOrCreateInstance(i).show());
        }
        _getChildren() {
            return z.find(Us, this._parent);
        }
        _getActiveElem() {
            return this._getChildren().find((t)=>this._elemIsActive(t)) || null;
        }
        _setInitialAttributes(t, e) {
            this._setAttributeIfNotExists(t, "role", "tablist");
            for (const t of e)this._setInitialAttributesOnChild(t);
        }
        _setInitialAttributesOnChild(t) {
            t = this._getInnerElement(t);
            const e = this._elemIsActive(t), i = this._getOuterElement(t);
            t.setAttribute("aria-selected", e), i !== t && this._setAttributeIfNotExists(i, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t);
        }
        _setInitialAttributesOnTargetPanel(t) {
            const e = z.getElementFromSelector(t);
            e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `${t.id}`));
        }
        _toggleDropDown(t, e) {
            const i = this._getOuterElement(t);
            if (!i.classList.contains("dropdown")) return;
            const n = (t, n)=>{
                const s = z.findOne(t, i);
                s && s.classList.toggle(n, e);
            };
            n(Qs, qs), n(".dropdown-menu", Ks), i.setAttribute("aria-expanded", e);
        }
        _setAttributeIfNotExists(t, e, i) {
            t.hasAttribute(e) || t.setAttribute(e, i);
        }
        _elemIsActive(t) {
            return t.classList.contains(qs);
        }
        _getInnerElement(t) {
            return t.matches(Us) ? t : z.findOne(Us, t);
        }
        _getOuterElement(t) {
            return t.closest(".nav-item, .list-group-item") || t;
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Js.getOrCreateInstance(this);
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                    e[t]();
                }
            });
        }
    }
    N.on(document, Ps, Ys, function(t) {
        [
            "A",
            "AREA"
        ].includes(this.tagName) && t.preventDefault(), l(this) || Js.getOrCreateInstance(this).show();
    }), N.on(window, Ms, ()=>{
        for (const t of z.find(Gs))Js.getOrCreateInstance(t);
    }), m(Js);
    const Zs = ".bs.toast", to = `mouseover${Zs}`, eo = `mouseout${Zs}`, io = `focusin${Zs}`, no = `focusout${Zs}`, so = `hide${Zs}`, oo = `hidden${Zs}`, ro = `show${Zs}`, ao = `shown${Zs}`, lo = "hide", co = "show", ho = "showing", uo = {
        animation: "boolean",
        autohide: "boolean",
        delay: "number"
    }, fo = {
        animation: !0,
        autohide: !0,
        delay: 5e3
    };
    class po extends W {
        constructor(t, e){
            super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners();
        }
        static get Default() {
            return fo;
        }
        static get DefaultType() {
            return uo;
        }
        static get NAME() {
            return "toast";
        }
        show() {
            N.trigger(this._element, ro).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(lo), d(this._element), this._element.classList.add(co, ho), this._queueCallback(()=>{
                this._element.classList.remove(ho), N.trigger(this._element, ao), this._maybeScheduleHide();
            }, this._element, this._config.animation));
        }
        hide() {
            this.isShown() && (N.trigger(this._element, so).defaultPrevented || (this._element.classList.add(ho), this._queueCallback(()=>{
                this._element.classList.add(lo), this._element.classList.remove(ho, co), N.trigger(this._element, oo);
            }, this._element, this._config.animation)));
        }
        dispose() {
            this._clearTimeout(), this.isShown() && this._element.classList.remove(co), super.dispose();
        }
        isShown() {
            return this._element.classList.contains(co);
        }
        _maybeScheduleHide() {
            this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(()=>{
                this.hide();
            }, this._config.delay)));
        }
        _onInteraction(t, e) {
            switch(t.type){
                case "mouseover":
                case "mouseout":
                    this._hasMouseInteraction = e;
                    break;
                case "focusin":
                case "focusout":
                    this._hasKeyboardInteraction = e;
            }
            if (e) return void this._clearTimeout();
            const i = t.relatedTarget;
            this._element === i || this._element.contains(i) || this._maybeScheduleHide();
        }
        _setListeners() {
            N.on(this._element, to, (t)=>this._onInteraction(t, !0)), N.on(this._element, eo, (t)=>this._onInteraction(t, !1)), N.on(this._element, io, (t)=>this._onInteraction(t, !0)), N.on(this._element, no, (t)=>this._onInteraction(t, !1));
        }
        _clearTimeout() {
            clearTimeout(this._timeout), this._timeout = null;
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = po.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t](this);
                }
            });
        }
    }
    return R(po), m(po), {
        Alert: Q,
        Button: Y,
        Carousel: Lt,
        Collapse: Rt,
        Dropdown: Ki,
        Modal: kn,
        Offcanvas: Kn,
        Popover: bs,
        ScrollSpy: Ls,
        Tab: Js,
        Toast: po,
        Tooltip: fs
    };
});

},{}],"01U1t":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPCanvas);
var _langJs = require("../languages/lang.js");
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
var _keymasterJs = require("../../lib/keymaster.js");
var _keymasterJsDefault = parcelHelpers.interopDefault(_keymasterJs);
var _cprectJs = require("../util/CPRect.js");
var _cprectJsDefault = parcelHelpers.interopDefault(_cprectJs);
var _cptransformJs = require("../util/CPTransform.js");
var _cptransformJsDefault = parcelHelpers.interopDefault(_cptransformJs);
var _cpbezierJs = require("../util/CPBezier.js");
var _cpbezierJsDefault = parcelHelpers.interopDefault(_cpbezierJs);
var _throttleDebounceJs = require("../util/throttle-debounce.js");
var _cppolygonJs = require("../util/CPPolygon.js");
var _cppolygonJsDefault = parcelHelpers.interopDefault(_cppolygonJs);
var _cppolyfillJs = require("../util/CPPolyfill.js");
var _cpvectorJs = require("../util/CPVector.js");
var _cpvectorJsDefault = parcelHelpers.interopDefault(_cpvectorJs);
var _chickenPaintJs = require("../ChickenPaint.js");
var _chickenPaintJsDefault = parcelHelpers.interopDefault(_chickenPaintJs);
var _cpbrushInfoJs = require("../engine/CPBrushInfo.js");
var _cpbrushInfoJsDefault = parcelHelpers.interopDefault(_cpbrushInfoJs);
var _cplayerGroupJs = require("../engine/CPLayerGroup.js");
var _cplayerGroupJsDefault = parcelHelpers.interopDefault(_cplayerGroupJs);
var _cpmaskViewJs = require("../engine/CPMaskView.js");
var _cpmaskViewJsDefault = parcelHelpers.interopDefault(_cpmaskViewJs);
var _cpguiutilsJs = require("./CPGUIUtils.js");
var _cpscrollbarJs = require("./CPScrollbar.js");
var _cpscrollbarJsDefault = parcelHelpers.interopDefault(_cpscrollbarJs);
var _cpcolorJs = require("../util/CPColor.js");
var _cpcolorJsDefault = parcelHelpers.interopDefault(_cpcolorJs);
function CPModeStack() {
    this.modes = [];
}
/* We have two distinguished mode indexes which correspond to the CPDefaultMode and the mode that the user has selected
 * in the tool palette (the global drawing mode). On top of that are other transient modes.
 */ CPModeStack.MODE_INDEX_DEFAULT = 0;
CPModeStack.MODE_INDEX_USER = 1;
CPModeStack.prototype.setMode = function(index, newMode) {
    var oldMode = this.modes[index];
    if (oldMode == newMode) return;
    if (oldMode) oldMode.leave();
    this.modes[index] = newMode;
    newMode.enter();
};
CPModeStack.prototype.setDefaultMode = function(newMode) {
    newMode.transient = false;
    newMode.capture = false;
    this.setMode(CPModeStack.MODE_INDEX_DEFAULT, newMode);
};
CPModeStack.prototype.setUserMode = function(newMode) {
    // Leave any transient modes that were on top of the user mode
    for(var i = this.modes.length - 1; i > CPModeStack.MODE_INDEX_USER; i--){
        this.modes[i].leave();
        this.modes.splice(i, 1);
    }
    newMode.transient = false;
    newMode.capture = false;
    this.setMode(CPModeStack.MODE_INDEX_USER, newMode);
};
/**
 * Deliver the event with the given name and array of parameters to the mode stack.
 *
 * @param event
 * @param params
 * @returns {boolean} True if any mode captured the event
 */ CPModeStack.prototype.deliverEvent = function(event, params) {
    for(var i = this.modes.length - 1; i >= 0; i--){
        var mode = this.modes[i];
        if (mode[event].apply(mode, params) || mode.capture && event != "paint") /* If the event was handled, don't try to deliver it to anything further up the stack */ return true;
    }
    return false;
};
// We can call these routines to deliver events that bubble up the mode stack
for (let eventName of [
    "mouseDown",
    "mouseUp"
])CPModeStack.prototype[eventName] = function(e, button, pressure) {
    this.deliverEvent(eventName, [
        e,
        button,
        pressure
    ]);
};
for (let eventName of [
    "mouseDrag",
    "mouseMove"
])CPModeStack.prototype[eventName] = function(e, pressure) {
    this.deliverEvent(eventName, [
        e,
        pressure
    ]);
};
for (let eventName of [
    "keyDown",
    "keyUp"
])CPModeStack.prototype[eventName] = function(e) {
    if (this.deliverEvent(eventName, [
        e
    ])) // Swallow handled keypresses
    e.preventDefault();
};
CPModeStack.prototype.paint = function(context) {
    this.deliverEvent("paint", [
        context
    ]);
};
/**
 * Add a mode to the top of the mode stack.
 *
 * @param mode {CPMode}
 * @param transient {boolean} Set to true if the mode is expected to remove itself from stack upon completion.
 */ CPModeStack.prototype.push = function(mode, transient) {
    var previousTop = this.peek();
    if (previousTop) previousTop.suspend();
    mode.transient = transient;
    mode.capture = false;
    mode.enter();
    this.modes.push(mode);
};
CPModeStack.prototype.peek = function() {
    if (this.modes.length > 0) return this.modes[this.modes.length - 1];
    else return null;
};
/**
 * Remove the node at the top of the stack and return the new top of the stack.
 *
 * @returns {*}
 */ CPModeStack.prototype.pop = function() {
    var outgoingMode = this.modes.pop(), newTop = this.peek();
    if (outgoingMode) outgoingMode.leave();
    if (newTop) newTop.resume();
    return newTop;
};
function CPCanvas(controller) {
    const BUTTON_PRIMARY = 0, BUTTON_WHEEL = 1, BUTTON_SECONDARY = 2, MIN_ZOOM = 0.1, MAX_ZOOM = 8.0, CURSOR_DEFAULT = "default", CURSOR_PANNABLE = "grab", CURSOR_PANNING = "grabbing", CURSOR_CROSSHAIR = "crosshair", CURSOR_MOVE = "move", CURSOR_NESW_RESIZE = "nesw-resize", CURSOR_NWSE_RESIZE = "nwse-resize", CURSOR_NS_RESIZE = "ns-resize", CURSOR_EW_RESIZE = "ew-resize", CURSOR_ZOOM_IN = "zoom-in";
    let that = this, canvasContainer = document.createElement("div"), canvasContainerTop = document.createElement("div"), canvasContainerBottom = document.createElement("div"), // Our canvas that fills the entire screen
    canvas = document.createElement("canvas"), canvasContext = canvas.getContext("2d"), // Our cache of the artwork's fusion to be drawn onto our main canvas using our current transform
    artworkCanvas = document.createElement("canvas"), artworkCanvasContext = artworkCanvas.getContext("2d"), checkerboardPattern = (0, _cpguiutilsJs.createCheckerboardPattern)(canvasContext), artwork = controller.getArtwork(), // Canvas transformations
    zoom = 1, offsetX = 0, offsetY = 0, canvasRotation = 0.0, transform = new (0, _cptransformJsDefault.default)(), interpolation = false, // Grid options
    showGrid = false, gridSize = 32, mouseX = 0, mouseY = 0, mouseIn = false, mouseDown = [
        false,
        false,
        false
    ], sawPen = false, isPinchZoomAllowed = false, isTouchInputAllowed = false, sawTouchWithPressure = false, /* The area of the document that should have its layers fused and repainted to the screen
         * (i.e. an area modified by drawing tools).
         *
         * Initially set to the size of the artwork so we can repaint the whole thing.
         */ artworkUpdateRegion = artwork.getBounds(), /**
         * The area of the canvas that should be repainted to the screen during the next repaint internal (in canvas
         * coordinates).
         */ repaintRegion = new (0, _cprectJsDefault.default)(0, 0, 0, 0), scheduledRepaint = false, /**
         * If we're viewing a single mask on its own instead of the document fusion, we store that view here.
         *
         * @type {CPMaskView}
         */ maskView, //
    // Modes system: modes control the way the GUI is reacting to the user input
    // All the tools are implemented through modes
    //
    defaultMode, colorPickerMode, panMode, rotateCanvasMode, floodFillMode, gradientFillMode, rectSelectionMode, moveToolMode, transformMode, // this must correspond to the stroke modes defined in CPToolInfo
    drawingModes = [], modeStack = new CPModeStack(), curDrawMode, horzScroll = new (0, _cpscrollbarJsDefault.default)(false), vertScroll = new (0, _cpscrollbarJsDefault.default)(true);
    Math.sign = Math.sign || function(x) {
        x = +x; // convert to a number
        if (x === 0 || isNaN(x)) return x;
        return x > 0 ? 1 : -1;
    };
    // Parent class with empty event handlers for those drawing modes that don't need every event
    function CPMode() {}
    /**
     * True if this mode will be exiting the mode stack as soon as the current interation is complete.
     *
     * @type {boolean}
     */ CPMode.prototype.transient = false;
    /**
     * If true, no input events will be sent to any modes underneath this one (event stream is captured).
     *
     * Painting events will continue to bubble.
     *
     * @type {boolean}
     */ CPMode.prototype.capture = false;
    CPMode.prototype.enter = function() {
        setCursor(CURSOR_DEFAULT);
    };
    CPMode.prototype.leave = function() {
        this.capture = false;
    };
    CPMode.prototype.mouseMove = CPMode.prototype.paint = CPMode.prototype.mouseDown = CPMode.prototype.mouseDrag = CPMode.prototype.mouseUp = CPMode.prototype.keyDown = CPMode.prototype.suspend = CPMode.prototype.resume = CPMode.prototype.keyUp = function() {};
    //
    // Default UI Mode when not doing anything: used to start the other modes
    //
    function CPDefaultMode() {}
    CPDefaultMode.prototype = Object.create(CPMode.prototype);
    CPDefaultMode.prototype.constructor = CPDefaultMode;
    CPDefaultMode.prototype.mouseDown = function(e, button, pressure) {
        var spacePressed = (0, _keymasterJsDefault.default).isPressed("space");
        if (!spacePressed && (button == BUTTON_SECONDARY || button == BUTTON_PRIMARY && e.altKey)) {
            modeStack.push(colorPickerMode, true);
            // Avoid infinite recursion by only delivering the event to the new mode (don't let it bubble back to us!)
            modeStack.peek().mouseDown(e, button, pressure);
        } else if (!spacePressed && button == BUTTON_PRIMARY && !e.altKey && (0, _keymasterJsDefault.default).isPressed("r")) {
            modeStack.push(rotateCanvasMode, true);
            modeStack.peek().mouseDown(e, button, pressure);
        } else if (button == BUTTON_WHEEL || !e.altKey && !e.ctrlKey && !(0, _keymasterJsDefault.default).isPressed("z") && spacePressed && button == BUTTON_PRIMARY) {
            modeStack.push(panMode, true);
            modeStack.peek().mouseDown(e, button, pressure);
        }
    };
    let previousMode = null; // 以前のモードを記憶して、あとで復帰させる
    CPDefaultMode.prototype.keyDown = function(e) {
        if (!e.altKey && (!e.ctrlKey && (0, _keymasterJsDefault.default).isPressed("z") || e.ctrlKey && (0, _keymasterJsDefault.default).isPressed("space"))) {
            setCursor(CURSOR_ZOOM_IN);
            // console.log("Zooming in with Ctrl+Space or Ctrl+Z");
            if (modeStack.peek() === curDrawMode) {
                previousMode = curDrawMode;
                modeStack.pop();
            }
            e.preventDefault();
            return true;
        } else if (//回転
        e.key.toLowerCase() === "r" && e.key !== " ") {
            modeStack.push(rotateCanvasMode, true);
            modeStack.peek().keyDown(e);
            return true;
        } else if (e.key === " " && (!e.ctrlKey || e.key.toLowerCase() !== "z")) {
            //スペースキーのみの時は通常のパン
            // We can start the pan mode before the mouse button is even pressed, so that the "grabbable" cursor appears
            modeStack.push(panMode, true);
            modeStack.peek().keyDown(e);
            e.preventDefault();
            return true;
        }
        if (modeStack.peek() === rectSelectionMode || modeStack.peek() === moveToolMode) {
            if (e.key === "Enter") {
                controller.actionPerformed({
                    action: "CPTransform"
                });
                e.preventDefault();
            }
        } else if (modeStack.peek() === panMode || modeStack.peek() === rotateCanvasMode) {
            if (e.key === "Enter") {
                controller.actionPerformed({
                    action: "CPResetZoomAndRotation"
                });
                e.preventDefault();
            }
        }
        return false;
    };
    CPDefaultMode.prototype.keyUp = function(e) {
        if (e.key === " " || e.key.toLowerCase() === "control" || e.key.toLowerCase() === "z") {
            setCursor(CURSOR_DEFAULT); // ズーム解除時にカーソルを戻す
            if (previousMode) {
                modeStack.setUserMode(previousMode); // 元モード復帰
                previousMode = null;
            }
            e.preventDefault(); // 既定動作キャンセル
        }
    };
    /**
     * A base for the three drawing modes, so they can all share the same brush-preview-circle drawing behaviour.
     *
     * @constructor
     */ function CPDrawingMode() {
        this.shouldPaintBrushPreview = false;
        /* The last rectangle we dirtied with a brush preview circle, or null if one hasn't been drawn yet */ this.oldPreviewRect = null;
    }
    CPDrawingMode.prototype = Object.create(CPMode.prototype);
    CPDrawingMode.prototype.constructor = CPDrawingMode;
    /**
     * Get a rectangle that encloses the preview brush, in screen coordinates.
     */ CPDrawingMode.prototype.getBrushPreviewOval = function() {
        var brushSize = controller.getBrushSize() * zoom;
        const halfBrushSize = brushSize / 2;
        return new (0, _cprectJsDefault.default)(mouseX - halfBrushSize, mouseY - halfBrushSize, mouseX + halfBrushSize, mouseY + halfBrushSize);
    };
    /**
     * Queues up the brush preview oval to be drawn.
     */ CPDrawingMode.prototype.queueBrushPreview = function() {
        /* If we're not the top-most mode, it's unlikely that left clicking will drawing for us, so don't consider
         * painting the brush preview
         */ if (modeStack.peek() != this) return;
        this.shouldPaintBrushPreview = true;
        var rect = this.getBrushPreviewOval();
        rect.grow(2, 2);
        // If a brush preview was drawn previously, stretch the repaint region to remove that old copy
        if (this.oldPreviewRect != null) {
            rect.union(this.oldPreviewRect);
            this.oldPreviewRect = null;
        }
        repaintRect(rect);
    };
    /**
     * Erase the brush preview if one had been drawn
     */ CPDrawingMode.prototype.eraseBrushPreview = function() {
        this.shouldPaintBrushPreview = false;
        if (this.oldPreviewRect != null) {
            repaintRect(this.oldPreviewRect);
            this.oldPreviewRect = null;
        }
    };
    CPDrawingMode.prototype.mouseMove = function(e, pressure) {
        this.queueBrushPreview();
    };
    CPDrawingMode.prototype.enter = function() {
        CPMode.prototype.enter.call(this);
        if (mouseIn) this.queueBrushPreview();
    };
    CPDrawingMode.prototype.leave = function() {
        CPMode.prototype.leave.call(this);
        this.eraseBrushPreview();
    };
    CPDrawingMode.prototype.suspend = CPDrawingMode.prototype.leave;
    CPDrawingMode.prototype.resume = CPDrawingMode.prototype.enter;
    CPDrawingMode.prototype.paint = function() {
        if (this.shouldPaintBrushPreview) {
            //円カーソルを表示
            this.shouldPaintBrushPreview = false;
            var r = this.getBrushPreviewOval();
            canvasContext.beginPath();
            canvasContext.arc((r.left + r.right) / 2, (r.top + r.bottom) / 2, r.getWidth() / 2, 0, Math.PI * 2);
            canvasContext.stroke();
            r.grow(2, 2);
            if (this.oldPreviewRect == null) this.oldPreviewRect = r;
            else this.oldPreviewRect.union(r);
        }
    };
    function CPFreehandMode() {
        CPDrawingMode.call(this);
        this.smoothMouse = {
            x: 0.0,
            y: 0.0
        };
    }
    CPFreehandMode.prototype = Object.create(CPDrawingMode.prototype);
    CPFreehandMode.prototype.constructor = CPFreehandMode;
    CPFreehandMode.prototype.mouseDown = function(e, button, pressure) {
        if (!this.capture && button == BUTTON_PRIMARY && !e.altKey && !(0, _keymasterJsDefault.default).isPressed("space") && shouldDrawToThisLayer()) {
            var pf = coordToDocument({
                x: mouseX,
                y: mouseY
            });
            this.eraseBrushPreview();
            if (artwork.beginStroke(pf.x, pf.y, pressure)) {
                this.capture = true;
                this.smoothMouse = pf;
                return true;
            }
        }
    };
    CPFreehandMode.prototype.mouseDrag = function(e, pressure) {
        if (typeof navigator.maxTouchPoints !== "number" || navigator.maxTouchPoints < 3) //タッチデバイスでは無い時に
        CPDrawingMode.prototype.mouseMove.call(this, e, pressure); //円カーソルをmouseDrag時に表示
        if (this.capture) {
            var pf = coordToDocument({
                x: mouseX,
                y: mouseY
            }), smoothing = Math.min(0.999, Math.pow(controller.getBrushInfo().smoothing, 0.3));
            const smoothingFactor = 1.0 - smoothing;
            this.smoothMouse.x = smoothingFactor * pf.x + smoothing * this.smoothMouse.x;
            this.smoothMouse.y = smoothingFactor * pf.y + smoothing * this.smoothMouse.y;
            artwork.continueStroke(this.smoothMouse.x, this.smoothMouse.y, pressure);
            return true;
        } else this.mouseMove(e);
    };
    CPFreehandMode.prototype.mouseUp = function(e, button, pressure) {
        if (this.capture) {
            if (button == BUTTON_PRIMARY) {
                this.capture = false;
                artwork.endStroke();
            }
            return true;
        }
    };
    function CPLineMode() {
        var dragLineFrom, dragLineTo, LINE_PREVIEW_WIDTH = 1;
        this.mouseDown = function(e, button, pressure) {
            if (!this.capture && button == BUTTON_PRIMARY && !e.altKey && !(0, _keymasterJsDefault.default).isPressed("space") && shouldDrawToThisLayer()) {
                this.capture = true;
                dragLineFrom = dragLineTo = {
                    x: mouseX + 0.5,
                    y: mouseY + 0.5
                };
                this.eraseBrushPreview();
                return true;
            }
        };
        this.mouseDrag = function(e) {
            if (this.capture) {
                var invalidateRect = new (0, _cprectJsDefault.default)(Math.min(dragLineFrom.x, dragLineTo.x) - LINE_PREVIEW_WIDTH - 1, Math.min(dragLineFrom.y, dragLineTo.y) - LINE_PREVIEW_WIDTH - 1, Math.max(dragLineFrom.x, dragLineTo.x) + LINE_PREVIEW_WIDTH + 1 + 1, Math.max(dragLineFrom.y, dragLineTo.y) + LINE_PREVIEW_WIDTH + 1 + 1);
                dragLineTo = {
                    x: mouseX + 0.5,
                    y: mouseY + 0.5
                }; // Target centre of pixel
                if (e.shiftKey) {
                    // Snap to nearest 45 degrees
                    var snap = Math.PI / 4, angle = Math.round(Math.atan2(dragLineTo.y - dragLineFrom.y, dragLineTo.x - dragLineFrom.x) / snap);
                    switch(angle){
                        case 0:
                        case 4:
                            dragLineTo.y = dragLineFrom.y;
                            break;
                        case 2:
                        case 6:
                            dragLineTo.x = dragLineFrom.x;
                            break;
                        default:
                            angle *= snap;
                            var length = Math.sqrt((dragLineTo.y - dragLineFrom.y) * (dragLineTo.y - dragLineFrom.y) + (dragLineTo.x - dragLineFrom.x) * (dragLineTo.x - dragLineFrom.x));
                            dragLineTo.x = dragLineFrom.x + length * Math.cos(angle);
                            dragLineTo.y = dragLineFrom.y + length * Math.sin(angle);
                    }
                }
                // The new line position
                invalidateRect.union(new (0, _cprectJsDefault.default)(Math.min(dragLineFrom.x, dragLineTo.x) - LINE_PREVIEW_WIDTH - 1, Math.min(dragLineFrom.y, dragLineTo.y) - LINE_PREVIEW_WIDTH - 1, Math.max(dragLineFrom.x, dragLineTo.x) + LINE_PREVIEW_WIDTH + 1 + 1, Math.max(dragLineFrom.y, dragLineTo.y) + LINE_PREVIEW_WIDTH + 1 + 1));
                repaintRect(invalidateRect);
                return true;
            } else this.mouseMove.call(this, e);
        };
        this.mouseUp = function(e, button, pressure) {
            if (this.capture && button == BUTTON_PRIMARY) {
                var from = coordToDocument(dragLineFrom), to = coordToDocument(dragLineTo);
                this.capture = false;
                this.drawLine(from, to);
                var invalidateRect = new (0, _cprectJsDefault.default)(Math.min(dragLineFrom.x, dragLineTo.x) - LINE_PREVIEW_WIDTH - 1, Math.min(dragLineFrom.y, dragLineTo.y) - LINE_PREVIEW_WIDTH - 1, Math.max(dragLineFrom.x, dragLineTo.x) + LINE_PREVIEW_WIDTH + 1 + 1, Math.max(dragLineFrom.y, dragLineTo.y) + LINE_PREVIEW_WIDTH + 1 + 1);
                repaintRect(invalidateRect);
                return true;
            }
        };
        this.paint = function() {
            if (this.capture) {
                canvasContext.lineWidth = LINE_PREVIEW_WIDTH;
                canvasContext.beginPath();
                canvasContext.moveTo(dragLineFrom.x, dragLineFrom.y);
                canvasContext.lineTo(dragLineTo.x, dragLineTo.y);
                canvasContext.stroke();
            } else // Draw the regular brush preview circle
            CPDrawingMode.prototype.paint.call(this);
        };
        CPDrawingMode.call(this);
    }
    CPLineMode.prototype = Object.create(CPDrawingMode.prototype);
    CPLineMode.prototype.constructor = CPLineMode;
    CPLineMode.prototype.drawLine = function(from, to) {
        artwork.beginStroke(from.x, from.y, 1);
        artwork.continueStroke(to.x, to.y, 1);
        artwork.endStroke();
    };
    function CPBezierMode() {
        const BEZIER_POINTS = 500, BEZIER_POINTS_PREVIEW = 100, BEZIER_STATE_INITIAL = 0, BEZIER_STATE_POINT_1 = 1, BEZIER_STATE_POINT_2 = 2;
        let dragBezierMode = BEZIER_STATE_INITIAL, dragBezierP0, dragBezierP1, dragBezierP2, dragBezierP3;
        this.mouseDown = function(e, button, pressure) {
            if (!this.capture && button == BUTTON_PRIMARY && !e.altKey && !(0, _keymasterJsDefault.default).isPressed("space") && shouldDrawToThisLayer()) {
                let p = coordToDocument({
                    x: mouseX,
                    y: mouseY
                });
                dragBezierMode = BEZIER_STATE_INITIAL;
                dragBezierP0 = dragBezierP1 = dragBezierP2 = dragBezierP3 = p;
                this.capture = true;
                this.eraseBrushPreview();
                return true;
            }
        };
        // Handles the first part of the Bezier where the user drags out a straight line
        this.mouseDrag = function(e) {
            if (this.capture && dragBezierMode === BEZIER_STATE_INITIAL) {
                let p = coordToDocument({
                    x: mouseX,
                    y: mouseY
                });
                dragBezierP2 = dragBezierP3 = p;
                that.repaintAll();
                return true;
            } else this.mouseMove.call(this, e);
        };
        this.mouseUp = function(e, button, pressure) {
            if (this.capture && button == BUTTON_PRIMARY) {
                switch(dragBezierMode){
                    case BEZIER_STATE_INITIAL:
                        dragBezierMode = BEZIER_STATE_POINT_1;
                        break;
                    case BEZIER_STATE_POINT_1:
                        dragBezierMode = BEZIER_STATE_POINT_2;
                        break;
                    case BEZIER_STATE_POINT_2:
                        this.capture = false;
                        let p0 = dragBezierP0, p1 = dragBezierP1, p2 = dragBezierP2, p3 = dragBezierP3, bezier = new (0, _cpbezierJsDefault.default)();
                        bezier.x0 = p0.x;
                        bezier.y0 = p0.y;
                        bezier.x1 = p1.x;
                        bezier.y1 = p1.y;
                        bezier.x2 = p2.x;
                        bezier.y2 = p2.y;
                        bezier.x3 = p3.x;
                        bezier.y3 = p3.y;
                        let x = new Array(BEZIER_POINTS), y = new Array(BEZIER_POINTS);
                        bezier.compute(x, y, BEZIER_POINTS);
                        artwork.beginStroke(x[0], y[0], 1);
                        for(let i = 1; i < BEZIER_POINTS; i++)artwork.continueStroke(x[i], y[i], 1);
                        artwork.endStroke();
                        that.repaintAll();
                }
                return true;
            }
        };
        this.mouseMove = function(e, pressure) {
            if (this.capture) {
                let p = coordToDocument({
                    x: mouseX,
                    y: mouseY
                });
                if (dragBezierMode == BEZIER_STATE_POINT_1) dragBezierP1 = p;
                else if (dragBezierMode == BEZIER_STATE_POINT_2) dragBezierP2 = p;
                that.repaintAll(); // FIXME: repaint only the bezier region
                return true;
            } else // Draw the normal brush preview while not in the middle of a bezier operation
            CPDrawingMode.prototype.mouseMove.call(this, e, pressure);
        };
        this.paint = function() {
            if (this.capture) {
                let bezier = new (0, _cpbezierJsDefault.default)(), p0 = coordToDisplay(dragBezierP0), p1 = coordToDisplay(dragBezierP1), p2 = coordToDisplay(dragBezierP2), p3 = coordToDisplay(dragBezierP3);
                bezier.x0 = p0.x;
                bezier.y0 = p0.y;
                bezier.x1 = p1.x;
                bezier.y1 = p1.y;
                bezier.x2 = p2.x;
                bezier.y2 = p2.y;
                bezier.x3 = p3.x;
                bezier.y3 = p3.y;
                let x = new Array(BEZIER_POINTS_PREVIEW), y = new Array(BEZIER_POINTS_PREVIEW);
                bezier.compute(x, y, BEZIER_POINTS_PREVIEW);
                canvasContext.beginPath();
                canvasContext.moveTo(x[0], y[0]);
                for(let i = 1; i < BEZIER_POINTS_PREVIEW; i++)canvasContext.lineTo(x[i], y[i]);
                canvasContext.moveTo(~~p0.x, ~~p0.y);
                canvasContext.lineTo(~~p1.x, ~~p1.y);
                canvasContext.moveTo(~~p2.x, ~~p2.y);
                canvasContext.lineTo(~~p3.x, ~~p3.y);
                canvasContext.stroke();
            } else // Paint the regular brush preview
            CPDrawingMode.prototype.paint.call(this);
        };
        CPDrawingMode.call(this);
    }
    CPBezierMode.prototype = Object.create(CPDrawingMode.prototype);
    CPBezierMode.prototype.constructor = CPBezierMode;
    function CPColorPickerMode() {
        var mouseButton;
        this.mouseDown = function(e, button, pressure) {
            if (this.capture) return true;
            else if (!(0, _keymasterJsDefault.default).isPressed("space") && (button == BUTTON_PRIMARY && (!this.transient || e.altKey) || button == BUTTON_SECONDARY)) {
                mouseButton = button;
                this.capture = true;
                setCursor(CURSOR_CROSSHAIR);
                this.mouseDrag(e);
                return true;
            } else if (this.transient) // If we're not sampling and we get a button not intended for us, we probably shouldn't be on the stack
            modeStack.pop();
        };
        this.mouseDrag = function(e) {
            if (this.capture) {
                var pf = coordToDocument({
                    x: mouseX,
                    y: mouseY
                });
                if (artwork.isPointWithin(pf.x, pf.y)) controller.setCurColor(new (0, _cpcolorJsDefault.default)(artwork.colorPicker(pf.x, pf.y)));
                return true;
            }
        };
        this.mouseUp = function(e, button, pressure) {
            if (this.capture && button == mouseButton) {
                mouseButton = -1;
                this.capture = false;
                setCursor(CURSOR_DEFAULT);
                if (this.transient) modeStack.pop();
                return true;
            }
        };
        this.enter = function() {
            CPMode.prototype.enter.call(this);
            mouseButton = -1;
        };
    }
    CPColorPickerMode.prototype = Object.create(CPMode.prototype);
    CPColorPickerMode.prototype.constructor = CPColorPickerMode;
    function CPPanCanvasMode() {
        var panningX, panningY, panningOffset, panningButton;
        this.keyDown = function(e) {
            if (!e.ctrlKey && e.key === " ") {
                // If we're not already panning, then advertise that a left-click would pan
                if (!this.capture) setCursor(CURSOR_PANNABLE);
                return true;
            }
        };
        this.keyUp = function(e) {
            if (this.transient && panningButton != BUTTON_WHEEL && e.key === " ") {
                setCursor(CURSOR_DEFAULT);
                modeStack.pop(); // yield control to the default mode
                return true;
            }
        };
        this.mouseDown = function(e, button, pressure) {
            if (this.capture) return true;
            else if (button == BUTTON_WHEEL || (0, _keymasterJsDefault.default).isPressed("space") && !e.ctrlKey && button == BUTTON_PRIMARY || !this.transient && button == BUTTON_PRIMARY) {
                this.capture = true;
                panningButton = button;
                panningX = e.pageX;
                panningY = e.pageY;
                panningOffset = that.getOffset();
                setCursor(CURSOR_PANNING);
                return true;
            } else if (this.transient) // If we're not panning and we get a button not intended for us, we probably shouldn't be on the stack
            modeStack.pop();
        };
        this.mouseDrag = function(e) {
            // if (key.isPressed("q")) return; // キーボードのQキーが押されている場合は何もしない
            if (this.capture) {
                that.setOffset(panningOffset.x + e.pageX - panningX, panningOffset.y + e.pageY - panningY);
                return true;
            }
        };
        this.mouseUp = function(e, button, pressure) {
            if (this.capture && button == panningButton) {
                panningButton = -1;
                this.capture = false;
                // 他モードに切り替わってたら何もしない
                if (modeStack.peek() !== this) return true;
                if (this.transient && !(0, _keymasterJsDefault.default).isPressed("space")) {
                    setCursor(CURSOR_DEFAULT);
                    modeStack.pop();
                } else setCursor(CURSOR_PANNABLE);
                return true;
            }
        };
        this.enter = function() {
            setCursor(CURSOR_PANNABLE);
        };
    }
    CPPanCanvasMode.prototype = Object.create(CPMode.prototype);
    CPPanCanvasMode.prototype.constructor = CPPanCanvasMode;
    function CPFloodFillMode() {}
    CPFloodFillMode.prototype = Object.create(CPMode.prototype);
    CPFloodFillMode.prototype.constructor = CPFloodFillMode;
    CPFloodFillMode.prototype.mouseDown = function(e, button, pressure) {
        if (button == BUTTON_PRIMARY && !e.altKey && !(0, _keymasterJsDefault.default).isPressed("space") && shouldDrawToThisLayer()) {
            var pf = coordToDocument({
                x: mouseX,
                y: mouseY
            });
            if (artwork.isPointWithin(pf.x, pf.y)) {
                artwork.floodFill(pf.x, pf.y);
                that.repaintAll();
            }
            return true;
        }
    };
    function CPRectSelectionMode() {
        var firstClick, curRect = new (0, _cprectJsDefault.default)(0, 0, 0, 0), selectingButton = -1;
        let maintainAspectCheckd = false;
        this.mouseDown = function(e, button, pressure) {
            const maintainAspectCheckbox = document.getElementById("chickenpaint-s-maintainAspectCheckbox");
            if (maintainAspectCheckbox && maintainAspectCheckbox instanceof HTMLInputElement) maintainAspectCheckd = maintainAspectCheckbox.checked;
            if (!this.capture && button == BUTTON_PRIMARY && !e.altKey && !(0, _keymasterJsDefault.default).isPressed("space")) {
                var p = coordToDocumentInt({
                    x: mouseX,
                    y: mouseY
                });
                selectingButton = button;
                curRect.makeEmpty();
                firstClick = p;
                that.repaintAll();
                this.capture = true;
                return true;
            }
        };
        this.mouseDrag = function(e) {
            if (!this.capture) return false;
            let p = coordToDocumentInt({
                x: mouseX,
                y: mouseY
            });
            let square = e.shiftKey || maintainAspectCheckd;
            let squareDist = ~~Math.max(Math.abs(p.x - firstClick.x), Math.abs(p.y - firstClick.y));
            if (p.x >= firstClick.x) {
                curRect.left = firstClick.x;
                curRect.right = (square ? firstClick.x + squareDist : p.x) + 1;
            } else {
                curRect.left = square ? firstClick.x - squareDist : p.x;
                curRect.right = firstClick.x + 1;
            }
            if (p.y >= firstClick.y) {
                curRect.top = firstClick.y;
                curRect.bottom = (square ? firstClick.y + squareDist : p.y) + 1;
            } else {
                curRect.top = square ? firstClick.y - squareDist : p.y;
                curRect.bottom = firstClick.y + 1;
            }
            that.repaintAll();
            return true;
        };
        this.mouseUp = function(e, button, pressure) {
            if (this.capture && button == selectingButton) {
                artwork.rectangleSelection(curRect);
                curRect.makeEmpty();
                that.repaintAll();
                this.capture = false;
                selectingButton = -1;
                return true;
            }
        };
        this.paint = function() {
            if (!curRect.isEmpty()) {
                canvasContext.lineWidth = 1;
                plotSelectionRect(canvasContext, curRect);
            }
        };
    }
    CPRectSelectionMode.prototype = Object.create(CPMode.prototype);
    CPRectSelectionMode.prototype.constructor = CPRectSelectionMode;
    function CPMoveToolMode() {
        var lastPoint, copyMode, firstMove = false;
        this.mouseDown = function(e, button, pressure) {
            if (!this.capture && button == BUTTON_PRIMARY && !(0, _keymasterJsDefault.default).isPressed("space") && checkCurrentLayerIsVisible()) {
                lastPoint = coordToDocument({
                    x: mouseX,
                    y: mouseY
                });
                copyMode = e.altKey;
                firstMove = true;
                this.capture = true;
                return true;
            }
        };
        this.mouseDrag = (0, _throttleDebounceJs.throttle)(25, function(e) {
            if (this.capture) {
                var p = coordToDocument({
                    x: mouseX,
                    y: mouseY
                }), moveFloat = {
                    x: p.x - lastPoint.x,
                    y: p.y - lastPoint.y
                }, moveInt = {
                    x: ~~moveFloat.x,
                    y: ~~moveFloat.y
                }; // Round towards zero
                if (moveInt.x != 0 || moveInt.y != 0) {
                    artwork.move(moveInt.x, moveInt.y, copyMode && firstMove);
                    firstMove = false;
                }
                /*
                 * Nudge the last point by the remainder we weren't able to move this iteration (due to move() only
                 * accepting integer offsets). This'll carry that fractional part of the move over for next iteration.
                 */ lastPoint.x = p.x - (moveFloat.x - moveInt.x);
                lastPoint.y = p.y - (moveFloat.y - moveInt.y);
                return true;
            }
        });
        this.mouseUp = function(e, button, pressure) {
            if (this.capture && button == BUTTON_PRIMARY) {
                this.capture = false;
                if (this.transient) modeStack.pop();
                return true;
            }
        };
    }
    CPMoveToolMode.prototype = Object.create(CPMode.prototype);
    CPMoveToolMode.prototype.constructor = CPMoveToolMode;
    CPMoveToolMode.prototype.mouseMove = function(e) {
        // 他のモードがトップなら何もしない
        if (modeStack.peek() !== this) return true;
        if (!(0, _keymasterJsDefault.default).isPressed("r") || !(0, _keymasterJsDefault.default).isPressed("space")) setCursor(CURSOR_MOVE);
        return true;
    };
    CPMoveToolMode.prototype.enter = function() {
        if (!(0, _keymasterJsDefault.default).isPressed("r") || !(0, _keymasterJsDefault.default).isPressed("space")) setCursor(CURSOR_MOVE);
    };
    function CPTransformMode() {
        const HANDLE_RADIUS = 3, DRAG_NONE = -1, DRAG_ROTATE = -2, DRAG_MOVE = -3, DRAG_NW_CORNER = 0, DRAG_N_EDGE = 1, DRAG_NE_CORNER = 2, DRAG_E_EDGE = 3, DRAG_SE_CORNER = 4, DRAG_S_EDGE = 5, DRAG_SW_CORNER = 6, DRAG_W_EDGE = 7;
        var /** @type {CPTransform} The current transformation */ affine, /** @type {CPRect} The initial document rectangle to transform */ srcRect, /** @type {CPPolygon} The initial transform rect */ origCornerPoints, /** @type {CPPolygon} The current corners of the transform rect in document space */ cornerPoints, draggingMode = DRAG_NONE, lastDragPointDisplay, lastDragPointDoc, // Keep track of how many degrees we've rotated so far during this transformation
        rotationAccumulator;
        /**
         * Get the polygon that represents the current transform result area in display coordinates.
         *
         * @returns {CPPolygon}
         */ function cornersToDisplayPolygon() {
            return cornerPoints.getTransformed(transform);
        }
        function averagePoints(p1, p2) {
            return {
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2
            };
        }
        function roundPoint(p) {
            return {
                x: Math.round(p.x),
                y: Math.round(p.y)
            };
        }
        /**
         * Decide which drag action should be taken if our mouse was pressed in the given position.
         *
         * @param {CPPolygon} corners - The corners of the current transform area
         * @param mouse - The mouse point
         * @returns {number} A DRAG_* constant
         */ function classifyDragAction(corners, mouse) {
            const HANDLE_CAPTURE_RADIUS = 7, HANDLE_CAPTURE_RADIUS_SQR = HANDLE_CAPTURE_RADIUS * HANDLE_CAPTURE_RADIUS, EDGE_CAPTURE_RADIUS = HANDLE_CAPTURE_RADIUS, EDGE_CAPTURE_RADIUS_SQR = EDGE_CAPTURE_RADIUS * EDGE_CAPTURE_RADIUS;
            // Are we dragging a corner?
            for(let i = 0; i < corners.points.length; i++){
                if ((mouse.x - corners.points[i].x) * (mouse.x - corners.points[i].x) + (mouse.y - corners.points[i].y) * (mouse.y - corners.points[i].y) <= HANDLE_CAPTURE_RADIUS_SQR) return i * 2;
            }
            // Are we dragging an edge?
            for(let i = 0; i < corners.points.length; i++){
                var edgeP1 = corners.points[i], edgeP2 = corners.points[(i + 1) % corners.points.length], vEdge = new (0, _cpvectorJsDefault.default)(edgeP2.x - edgeP1.x, edgeP2.y - edgeP1.y), vMouse = new (0, _cpvectorJsDefault.default)(mouse.x - edgeP1.x, mouse.y - edgeP1.y), vEdgeLen = vEdge.getLength(), vEdgeScaled = vEdge.getScaled(1 / vEdgeLen), vMouseScaled = vMouse.getScaled(1 / vEdgeLen), mousePropOnLine = vEdgeScaled.getDotProduct(vMouseScaled);
                // If we're within the ends of the line (perpendicularly speaking)
                if (mousePropOnLine >= 0.0 && mousePropOnLine <= 1.0) {
                    // This gives us the point on the line closest to the mouse
                    vEdge.scale(mousePropOnLine);
                    if ((vEdge.x - vMouse.x) * (vEdge.x - vMouse.x) + (vEdge.y - vMouse.y) * (vEdge.y - vMouse.y) <= EDGE_CAPTURE_RADIUS_SQR) return i * 2 + 1;
                }
            }
            if (corners.containsPoint(mouse)) return DRAG_MOVE;
            return DRAG_ROTATE;
        }
        function setCursorForHandles() {
            var corners = cornersToDisplayPolygon(), mouse = {
                x: mouseX,
                y: mouseY
            }, dragAction = classifyDragAction(corners, mouse);
            switch(dragAction){
                case DRAG_NW_CORNER:
                case DRAG_NE_CORNER:
                case DRAG_SE_CORNER:
                case DRAG_SW_CORNER:
                    // Choose a cursor for a 45-degree resize from this corner
                    let cornerIndex = ~~(dragAction / 2), cornerBefore = corners.points[(cornerIndex + 3) % 4], corner = corners.points[cornerIndex], cornerAfter = corners.points[(cornerIndex + 1) % 4], // Get a vector which points 45 degrees toward the center of the box, this'll do for cursor direction
                    v45 = (0, _cpvectorJsDefault.default).subtractPoints(cornerBefore, corner).normalize().add((0, _cpvectorJsDefault.default).subtractPoints(cornerAfter, corner).normalize());
                    setResizeCursorForVector(v45);
                    break;
                case DRAG_N_EDGE:
                case DRAG_E_EDGE:
                case DRAG_S_EDGE:
                case DRAG_W_EDGE:
                    // Resizing from here will move edge perpendicularly
                    let corner1 = corners.points[~~(dragAction / 2)], corner2 = corners.points[(~~(dragAction / 2) + 1) % 4], vPerp = (0, _cpvectorJsDefault.default).subtractPoints(corner2, corner1).getPerpendicular();
                    setResizeCursorForVector(vPerp);
                    break;
                case DRAG_MOVE:
                    //一時的なパン･回転時にペンの移動でカーソルがちらつくのを防ぐ
                    if (!(0, _keymasterJsDefault.default).isPressed("r") && !(0, _keymasterJsDefault.default).isPressed("space")) setCursor(CURSOR_MOVE);
                    break;
                case DRAG_ROTATE:
                    if (!(0, _keymasterJsDefault.default).isPressed("r") && !(0, _keymasterJsDefault.default).isPressed("space")) setCursor(CURSOR_DEFAULT); // TODO add a custom rotation cursor
                    break;
                default:
                    // No drag action, so just use the default cursor
                    setCursor(CURSOR_DEFAULT);
            }
        }
        let maintainAspectCheckd = false;
        this.mouseDown = function(e, button, pressure) {
            const maintainAspectCheckbox = document.getElementById("chickenpaint-t-maintainAspectCheckbox");
            if (maintainAspectCheckbox && maintainAspectCheckbox instanceof HTMLInputElement) maintainAspectCheckd = maintainAspectCheckbox.checked;
            if (!this.capture && button == BUTTON_PRIMARY && !e.altKey && !(0, _keymasterJsDefault.default).isPressed("space")) {
                var corners = cornersToDisplayPolygon();
                draggingMode = classifyDragAction(corners, {
                    x: mouseX,
                    y: mouseY
                });
                lastDragPointDisplay = {
                    x: mouseX,
                    y: mouseY
                };
                lastDragPointDoc = coordToDocument(lastDragPointDisplay);
                this.capture = true;
                setCursorForHandles();
                return true;
            }
        };
        this.mouseDrag = (0, _throttleDebounceJs.throttle)(40, function(e) {
            const MIN_SCALE = 0.001;
            if (this.capture) {
                var dragPointDisplay = {
                    x: mouseX,
                    y: mouseY
                };
                switch(draggingMode){
                    case DRAG_MOVE:
                        let dragPointDoc = roundPoint(coordToDocument(dragPointDisplay)), translation = (0, _cpvectorJsDefault.default).subtractPoints(dragPointDoc, lastDragPointDoc), // Only translate in whole-pixel increments (in document space not canvas space)
                        translationRounded = translation.getTruncated(), translationRemainder = translation.subtract(translationRounded), translateInstance = new (0, _cptransformJsDefault.default)();
                        /*
                         * Apply the translate *after* the current affine is applied.
                         */ translateInstance.translate(translationRounded.x, translationRounded.y);
                        affine.preMultiply(translateInstance);
                        // Accumulate the fractional move that we didn't apply for next time
                        lastDragPointDoc = (0, _cpvectorJsDefault.default).subtractPoints(dragPointDoc, translationRemainder);
                        break;
                    case DRAG_ROTATE:
                        const DRAG_ROTATE_SNAP_ANGLE = Math.PI / 4;
                        let centerDoc = cornerPoints.getCenter(), centerDisplay = coordToDisplay(centerDoc), oldMouseAngle = Math.atan2(lastDragPointDisplay.y - centerDisplay.y, lastDragPointDisplay.x - centerDisplay.x), newMouseAngle = Math.atan2(dragPointDisplay.y - centerDisplay.y, dragPointDisplay.x - centerDisplay.x), deltaMouseAngle = newMouseAngle - oldMouseAngle, rotateAngle, rotateInstance = new (0, _cptransformJsDefault.default)();
                        rotationAccumulator += deltaMouseAngle;
                        if (e.shiftKey) /*
                             * The rotation in the decomposition was made about the origin. We want to rotate about the
                             * center of the selection, so first rotate the selection to square it up with the axes,
                             * then we'll pivot the selection about its center to the new angle.
                             */ rotateAngle = -affine.decompose().rotate + Math.round(rotationAccumulator / DRAG_ROTATE_SNAP_ANGLE) * DRAG_ROTATE_SNAP_ANGLE;
                        else rotateAngle = deltaMouseAngle;
                        /* Apply the rotation *after* the current affine instead of before it, so that we don't
                         * end up scaling on top of the rotated selection later (which would cause an unwanted shear)
                         */ // 反転時は回転方向を逆に
                        if (isViewFlipped) rotateAngle = -rotateAngle;
                        rotateInstance.rotateAroundPoint(rotateAngle, centerDoc.x, centerDoc.y);
                        affine.preMultiply(rotateInstance);
                        lastDragPointDisplay = dragPointDisplay;
                        break;
                    case DRAG_NW_CORNER:
                    case DRAG_NE_CORNER:
                    case DRAG_SE_CORNER:
                    case DRAG_SW_CORNER:
                        {
                            let draggingCorner = ~~(draggingMode / 2), oldCorner = origCornerPoints.points[draggingCorner], // The corner we dragged will move into its new position
                            newCorner = affine.getInverted().getTransformedPoint(roundPoint(coordToDocument(dragPointDisplay))), // The opposite corner to the one we dragged must not move
                            fixCorner = origCornerPoints.points[(draggingCorner + 2) % 4], /* Now we can see how much we'd need to scale the original rectangle about the fixed corner
                                 * for the other corner to reach the new position.
                                 */ scaleX = (newCorner.x - fixCorner.x) / (oldCorner.x - fixCorner.x), scaleY = (newCorner.y - fixCorner.y) / (oldCorner.y - fixCorner.y);
                            /*
                             * If the user resized it until it was zero-sized, just ignore that position and assume they'll move
                             * past it in a msec.
                             */ if (Math.abs(scaleX) < MIN_SCALE || Math.abs(scaleY) < MIN_SCALE || isNaN(scaleX) || isNaN(scaleY)) return true;
                            // Does user want proportional resize?
                            if (maintainAspectCheckd || e.shiftKey) {
                                var largestScale = Math.max(scaleX, scaleY);
                                scaleX = largestScale;
                                scaleY = largestScale;
                            }
                            // The transform we do here will be performed first before any of the other transforms (scale, rotate, etc)
                            affine.scaleAroundPoint(scaleX, scaleY, fixCorner.x, fixCorner.y);
                        }
                        break;
                    case DRAG_N_EDGE:
                    case DRAG_S_EDGE:
                    case DRAG_E_EDGE:
                    case DRAG_W_EDGE:
                        {
                            let cornerIndex = ~~(draggingMode / 2), oldHandle = averagePoints(origCornerPoints.points[cornerIndex], origCornerPoints.points[(cornerIndex + 1) % 4]), // The handle we dragged will move into its new position
                            newHandle = affine.getInverted().getTransformedPoint(roundPoint(coordToDocument(dragPointDisplay))), // The opposite handle to the one we dragged must not move
                            fixHandle = averagePoints(origCornerPoints.points[(cornerIndex + 2) % 4], origCornerPoints.points[(cornerIndex + 3) % 4]), scaleX, scaleY, oldVector = (0, _cpvectorJsDefault.default).subtractPoints(oldHandle, fixHandle), newVector = (0, _cpvectorJsDefault.default).subtractPoints(newHandle, fixHandle), oldLength = oldVector.getLength(), // We only take the length in the perpendicular direction to the transform edge:
                            newLength = oldVector.getDotProduct(newVector) / oldLength, newScale = newLength / oldLength;
                            /*
                             * If the user resized it until it was zero-sized, just ignore that position and assume they'll move
                             * past it in a msec.
                             */ if (Math.abs(newScale) < MIN_SCALE || isNaN(newScale)) return true;
                            if (draggingMode == DRAG_N_EDGE || draggingMode == DRAG_S_EDGE) {
                                scaleX = 1.0;
                                scaleY = newScale;
                            } else {
                                scaleX = newScale;
                                scaleY = 1.0;
                            }
                            affine.scaleAroundPoint(scaleX, scaleY, fixHandle.x, fixHandle.y);
                        }
                        break;
                }
                cornerPoints = origCornerPoints.getTransformed(affine);
                artwork.transformAffineAmend(affine);
                // TODO make me more specific
                that.repaintAll();
                return true;
            }
        });
        this.mouseUp = function(e, button, pressure) {
            if (this.capture && button == BUTTON_PRIMARY) {
                this.capture = false;
                draggingMode = DRAG_NONE;
                return true;
            }
        };
        /*
         * Set an appropriate resize cursor for the specified vector from the center to the handle.
         */ function setResizeCursorForVector(v) {
            let angle = Math.atan2(-v.y, v.x), /*
                 * Slice up into 45 degrees slices so that there are +-22.5 degrees centered around each corner,
                 * and a 45 degree segment for each edge
                 */ slice = Math.floor(angle / (Math.PI / 4) + 0.5), cursor;
            // Wrap angles below the x-axis wrap to positive ones...
            if (slice < 0) slice += 4;
            switch(slice){
                case 0:
                default:
                    cursor = CURSOR_EW_RESIZE;
                    break;
                case 1:
                    cursor = CURSOR_NESW_RESIZE;
                    break;
                case 2:
                    cursor = CURSOR_NS_RESIZE;
                    break;
                case 3:
                    cursor = CURSOR_NWSE_RESIZE;
                    break;
            }
            setCursor(cursor);
        }
        this.mouseMove = function() {
            // We want to stick with our choice of cursor throughout the drag operation
            if (!this.capture) setCursorForHandles();
        };
        this.paint = function() {
            var corners = cornersToDisplayPolygon().points, handles = new Array(corners.length * 2);
            // Collect the positions of the edge and corner handles...
            for(let i = 0; i < corners.length; i++)handles[i] = corners[i];
            for(let i = 0; i < corners.length; i++){
                var edgeP1 = corners[i], edgeP2 = corners[(i + 1) % corners.length], midWay = {
                    x: (edgeP1.x + edgeP2.x) / 2,
                    y: (edgeP1.y + edgeP2.y) / 2
                };
                handles[i + corners.length] = midWay;
            }
            (0, _cpguiutilsJs.setContrastingDrawStyle)(canvasContext, "fill");
            for(let i = 0; i < handles.length; i++)canvasContext.fillRect(handles[i].x - HANDLE_RADIUS, handles[i].y - HANDLE_RADIUS, HANDLE_RADIUS * 2 + 1, HANDLE_RADIUS * 2 + 1);
            strokePolygon(canvasContext, corners);
        };
        this.keyDown = function(e) {
            if (e.key === "Enter") {
                controller.actionPerformed({
                    action: "CPTransformAccept"
                });
                return true;
            } else if (e.key === "Escape") {
                controller.actionPerformed({
                    action: "CPTransformReject"
                });
                return true;
            }
        };
        this.enter = function() {
            CPMode.prototype.enter.call(this);
            // Start off with the identity transform
            var initial = artwork.transformAffineBegin(), initialSelection;
            affine = initial.transform;
            srcRect = initial.rect;
            // Decide on the rectangle we'll show as the boundary of the transform area
            initialSelection = initial.selection;
            /* If the user didn't have anything selected, we'll use the actual shrink-wrapped transform area instead. */ if (initialSelection.isEmpty()) initialSelection = initial.rect.clone();
            origCornerPoints = new (0, _cppolygonJsDefault.default)(initialSelection.toPoints());
            cornerPoints = origCornerPoints.getTransformed(affine);
            draggingMode = -1;
            rotationAccumulator = 0;
            that.repaintAll();
        };
        this.leave = function() {
            CPMode.prototype.leave.call(this);
            that.repaintAll();
        };
        // キーボード用の移動関数
        this.moveByKey = function(dx, dy) {
            if (!affine) return;
            let translateInstance = new (0, _cptransformJsDefault.default)();
            translateInstance.translate(dx, dy);
            affine.preMultiply(translateInstance);
            // 変形のハンドルを更新
            cornerPoints = origCornerPoints.getTransformed(affine); // transformの更新を反映させる関数呼び出しなど
            artwork.transformAffineAmend(affine);
            this.repaintAll?.(); // repaintAll() があれば呼ぶ
        };
    }
    CPTransformMode.prototype = Object.create(CPMode.prototype);
    CPTransformMode.prototype.constructor = CPTransformMode;
    //キーボードで1pxずつ移動できるようにする
    function getArrowKeyDelta(key) {
        if (!key) return null;
        switch(key.toLowerCase()){
            case "arrowup":
                return {
                    dx: 0,
                    dy: -1
                };
            case "arrowdown":
                return {
                    dx: 0,
                    dy: 1
                };
            case "arrowleft":
                return {
                    dx: -1,
                    dy: 0
                };
            case "arrowright":
                return {
                    dx: 1,
                    dy: 0
                };
            default:
                return null;
        }
    }
    // キーボードでの移動を有効にする
    document.addEventListener("keydown", function(e) {
        const topMode = modeStack.peek();
        const delta = getArrowKeyDelta(e.key);
        if (!delta) return;
        let { dx, dy } = delta;
        // 左右反転時はX方向の符号を逆に
        if (isViewFlipped) dx = -dx;
        //変形操作中のキーボードでの移動を有効にする
        if (topMode === transformMode) {
            transformMode.moveByKey(dx, dy);
            e.preventDefault();
        //移動ツール選択時にキーボードで1pxずつ移動できるようにする
        } else if (topMode === moveToolMode) {
            const copyMode = e.altKey;
            artwork.move(dx, dy, copyMode);
            e.preventDefault();
        }
    });
    function CPRotateCanvasMode() {
        var firstClick, initAngle = 0.0, initTransform, dragged = false, rotateButton = -1;
        this.mouseDown = function(e, button, pressure) {
            if (this.capture) return true;
            else if (!this.transient && button == BUTTON_PRIMARY && !e.altKey && !(0, _keymasterJsDefault.default).isPressed("space") || button == BUTTON_PRIMARY && !e.altKey && !(0, _keymasterJsDefault.default).isPressed("space") && (0, _keymasterJsDefault.default).isPressed("r")) {
                firstClick = {
                    x: mouseX,
                    y: mouseY
                };
                initAngle = that.getRotation();
                // もし一時的に反転している状態ならば、
                // cloneしたtransformに反転変換を適用して
                // 反転状態を反映させる
                initTransform = transform.clone();
                if (isViewFlipped) viewFlip(initTransform);
                dragged = false;
                this.capture = true;
                rotateButton = button;
                return true;
            } else if (this.transient) modeStack.pop();
        };
        this.mouseDrag = function(e) {
            if (this.capture) {
                const p = {
                    x: mouseX,
                    y: mouseY
                };
                const displayCenter = {
                    x: canvas.clientWidth / 2,
                    y: canvas.clientHeight / 2
                };
                const canvasCenter = {
                    x: canvas.width / 2,
                    y: canvas.height / 2
                };
                let deltaAngle = Math.atan2(p.y - displayCenter.y, p.x - displayCenter.x) - Math.atan2(firstClick.y - displayCenter.y, firstClick.x - displayCenter.x);
                let rotTrans = new (0, _cptransformJsDefault.default)();
                rotTrans.rotateAroundPoint(deltaAngle, canvasCenter.x, canvasCenter.y);
                rotTrans.multiply(initTransform);
                that.setRotation(initAngle + deltaAngle);
                that.setOffset(~~rotTrans.getTranslateX(), ~~rotTrans.getTranslateY());
                dragged = true;
                return true;
            }
        };
        /**
         * When the mouse is released after rotation, we might want to snap our angle to the nearest 90 degree mark.
         */ function finishRotation() {
            const ROTATE_SNAP_DEGREES = 5;
            let nearest90 = Math.round(canvasRotation / (Math.PI / 2)) * Math.PI / 2;
            if (Math.abs(canvasRotation - nearest90) < ROTATE_SNAP_DEGREES / 180 * Math.PI) {
                let deltaAngle = nearest90 - initAngle, center = {
                    x: canvas.width / 2,
                    y: canvas.height / 2
                }, rotTrans = new (0, _cptransformJsDefault.default)();
                rotTrans.rotateAroundPoint(deltaAngle, center.x, center.y);
                rotTrans.multiply(initTransform);
                that.setRotation(initAngle + deltaAngle);
                that.setOffset(~~rotTrans.getTranslateX(), ~~rotTrans.getTranslateY());
                that.repaintAll();
            }
            that.emitEvent("canvasRotated90", [
                that.getRotation90()
            ]);
        }
        this.mouseUp = function(e, button, pressure) {
            if (this.capture && button == rotateButton) {
                if (dragged) finishRotation();
                else that.resetRotation();
                this.capture = false;
                if (this.transient && !(0, _keymasterJsDefault.default).isPressed("r")) modeStack.pop();
                return true;
            }
        };
        this.keyUp = function(e) {
            if (this.transient && rotateButton != BUTTON_WHEEL && e.key === " ") {
                setCursor(CURSOR_DEFAULT);
                modeStack.pop(); // yield control to the default mode
                return true;
            }
        };
        this.keyDown = function(e) {
            if (e.key.toLowerCase() === "r") // That's our hotkey, so stay in this mode (don't forward to CPDefaultMode)
            return true;
        };
    }
    CPRotateCanvasMode.prototype = Object.create(CPMode.prototype);
    CPRotateCanvasMode.prototype.constructor = CPRotateCanvasMode;
    function CPGradientFillMode() {
        // Super constructor
        CPLineMode.call(this);
    }
    CPGradientFillMode.prototype = Object.create(CPLineMode.prototype);
    CPGradientFillMode.prototype.constructor = CPGradientFillMode;
    CPGradientFillMode.prototype.drawLine = function(from, to) {
        artwork.gradientFill(Math.round(from.x), Math.round(from.y), Math.round(to.x), Math.round(to.y), controller.getCurGradient());
    };
    CPGradientFillMode.prototype.queueBrushPreview = function() {
    //Suppress the drawing of the brush preview (inherited from CPDrawingMode)
    };
    function setCursor(cursor) {
        if (canvas.getAttribute("data-cursor") != cursor) canvas.setAttribute("data-cursor", cursor);
    }
    function checkCurrentLayerIsVisible() {
        var activeLayer = artwork.getActiveLayer();
        if (!(activeLayer.visible && activeLayer.ancestorsAreVisible())) {
            controller.showLayerNotification(activeLayer, (0, _langJs._)("Whoops! This layer is currently hidden"), "layer");
            return false;
        } else if (activeLayer.alpha == 0) {
            controller.showLayerNotification(activeLayer, (0, _langJs._)("Whoops! This layer's opacity is currently 0%"), "opacity");
            return false;
        }
        return true;
    }
    /**
     * Check that we should be drawing to the current layer, and let the user know if they are being blocked by the
     * layer settings.
     *
     * @returns {boolean} True if we should draw to the current layer
     */ function shouldDrawToThisLayer() {
        var activeLayer = artwork.getActiveLayer();
        if (activeLayer instanceof (0, _cplayerGroupJsDefault.default) && !artwork.isEditingMask()) {
            controller.showLayerNotification(activeLayer, (0, _langJs._)("Whoops! You can't draw on a group"), "layer");
            return false;
        }
        return checkCurrentLayerIsVisible();
    }
    /**
     * Update the scrollbar's range/position to match the current view settings for the document.
     *
     * @param scrollbar {CPScrollbar}
     * @param visMin The smallest coordinate in this axis in which the drawing appears
     * @param visWidth The extent of the drawing in this axis
     * @param viewSize The extent of the screen canvas in this axis
     * @param offset The present pixel offset of the drawing in this axis
     */ function updateScrollBar(scrollbar, visMin, visWidth, viewSize, offset) {
        var xMin = visMin - viewSize - offset + visWidth / 4, xMax = visMin + visWidth - offset - visWidth / 4;
        scrollbar.setValues(-offset, viewSize, xMin, xMax);
        scrollbar.setBlockIncrement(Math.max(1, ~~(viewSize * 0.66)));
        scrollbar.setUnitIncrement(Math.max(1, ~~(viewSize * 0.05)));
    }
    function updateScrollBars() {
        if (horzScroll == null || vertScroll == null || horzScroll.getValueIsAdjusting() || vertScroll.getValueIsAdjusting()) return;
        var visibleRect = getRefreshArea(new (0, _cprectJsDefault.default)(0, 0, artworkCanvas.width, artworkCanvas.height));
        updateScrollBar(horzScroll, visibleRect.left, visibleRect.getWidth(), canvas.clientWidth, that.getOffset().x);
        updateScrollBar(vertScroll, visibleRect.top, visibleRect.getHeight(), canvas.clientHeight, that.getOffset().y);
    }
    function updateTransform({ resetViewFlip = false } = {}) {
        transform.setToIdentity();
        transform.translate(offsetX, offsetY);
        transform.scale(zoom, zoom);
        transform.rotate(canvasRotation);
        if (isViewFlipped && !resetViewFlip) viewFlip(transform);
        updateScrollBars();
        that.repaintAll();
    }
    /**
     * Convert a canvas-relative coordinate into document coordinates and return the new coordinate.
     */ function coordToDocument(coord) {
        // TODO cache inverted transform
        return transform.getInverted().getTransformedPoint(coord);
    }
    /**
     * Convert a canvas-relative coordinate into document coordinates.
     */ function coordToDocumentInt(coord) {
        var result = coordToDocument(coord);
        result.x = Math.floor(result.x);
        result.y = Math.floor(result.y);
        return result;
    }
    /**
     * Convert a {x: pageX, y: pageY} co-ordinate pair from a mouse event to canvas-relative coordinates.
     */ function mouseCoordToCanvas(coord) {
        var rect = canvas.getBoundingClientRect();
        return {
            x: coord.x - rect.left - window.pageXOffset,
            y: coord.y - rect.top - window.pageYOffset
        };
    }
    function coordToDisplay(p) {
        return transform.getTransformedPoint(p);
    }
    function coordToDisplayInt(p) {
        var result = coordToDisplay(p);
        result.x = Math.round(result.x);
        result.y = Math.round(result.y);
        return result;
    }
    /**
     * Convert a rectangle that encloses the given document pixels into a rectangle in display coordinates.
     *
     * @param rect {CPRect}
     * @returns {*[]}
     */ function rectToDisplay(rect) {
        var center = coordToDisplay({
            x: (rect.left + rect.right) / 2,
            y: (rect.top + rect.bottom) / 2
        }), coords = rect.toPoints();
        for(var i = 0; i < coords.length; i++){
            coords[i] = coordToDisplayInt(coords[i]);
            // Need to inset the co-ordinates by 0.5 display pixels for the line to pass through the middle of the display pixel
            coords[i].x += Math.sign(center.x - coords[i].x) * 0.5;
            coords[i].y += Math.sign(center.y - coords[i].y) * 0.5;
        }
        return coords;
    }
    function strokePolygon(context, coords) {
        context.beginPath();
        context.moveTo(coords[0].x, coords[0].y);
        for(var i = 1; i < coords.length; i++)context.lineTo(coords[i].x, coords[i].y);
        context.lineTo(coords[0].x, coords[0].y);
        context.stroke();
    }
    /**
     * Stroke a selection rectangle that encloses the pixels in the given rectangle (in document co-ordinates).
     */ function plotSelectionRect(context, rect) {
        strokePolygon(context, rectToDisplay(rect));
    }
    /**
     * Take a CPRect of document coordinates and return a CPRect of canvas coordinates to repaint for that region.
     */ function getRefreshArea(r) {
        var p1 = coordToDisplayInt({
            x: r.left - 1,
            y: r.top - 1
        }), p2 = coordToDisplayInt({
            x: r.left - 1,
            y: r.bottom
        }), p3 = coordToDisplayInt({
            x: r.right,
            y: r.top - 1
        }), p4 = coordToDisplayInt({
            x: r.right,
            y: r.bottom
        }), r2 = new (0, _cprectJsDefault.default)(Math.min(Math.min(p1.x, p2.x), Math.min(p3.x, p4.x)), Math.min(Math.min(p1.y, p2.y), Math.min(p3.y, p4.y)), Math.max(Math.max(p1.x, p2.x), Math.max(p3.x, p4.x)) + 1, Math.max(Math.max(p1.y, p2.y), Math.max(p3.y, p4.y)) + 1);
        r2.grow(2, 2); // to be sure to include everything
        return r2;
    }
    /**
     * Adjust the current offset to bring the center of the artwork to the center of the canvas
     */ function centerCanvas() {
        var width = canvas.width, height = canvas.height, artworkCenter = coordToDisplay({
            x: artwork.width / 2,
            y: artwork.height / 2
        });
        that.setOffset(Math.round(offsetX + width / 2.0 - artworkCenter.x), Math.round(offsetY + height / 2.0 - artworkCenter.y));
    }
    this.setZoom = function(_zoom) {
        zoom = _zoom;
        updateTransform();
    };
    this.getZoom = function() {
        return zoom;
    };
    this.setGridSize = function(_gridSize) {
        gridSize = Math.max(Math.round(_gridSize), 1);
        this.repaintAll();
    };
    this.getGridSize = function() {
        return gridSize;
    };
    this.setOffset = function(x, y) {
        if (isNaN(x) || isNaN(y)) console.log("Bad offset");
        else {
            offsetX = x;
            offsetY = y;
            updateTransform();
        }
    };
    this.getOffset = function() {
        return {
            x: offsetX,
            y: offsetY
        };
    };
    this.setInterpolation = function(enabled) {
        interpolation = enabled;
        (0, _cppolyfillJs.setCanvasInterpolation)(canvasContext, enabled);
        this.repaintAll();
    };
    this.setRotation = function(angle) {
        canvasRotation = angle % (2 * Math.PI);
        updateTransform();
    };
    this.setRotationOnCenter = function(angle) {
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        // 前の回転との差分を使って offset を補正する
        const delta = angle - canvasRotation;
        const cos = Math.cos(delta);
        const sin = Math.sin(delta);
        // 中心を基準にするようにオフセット調整
        const dx = offsetX - centerX;
        const dy = offsetY - centerY;
        offsetX = centerX + dx * cos - dy * sin;
        offsetY = centerY + dx * sin + dy * cos;
        canvasRotation = angle % (2 * Math.PI);
        updateTransform();
    };
    /**
     * 現在のキャンバスの回転角度をラジアンで取得します。
     *
     * @returns {number} キャンバスの回転角度（ラジアン）
     */ this.getRotation = function() {
        return canvasRotation;
    };
    /**
     * Get canvas rotation in degrees, normalized to [-180, +180].
     * @returns {number} 現在の角度（度）
     */ this.getRotationDegrees = function() {
        let deg = this.getRotation() * 180 / Math.PI;
        deg = (deg + 180 + 360) % 360 - 180; // 負の値を補正
        return deg;
    };
    /**
     * Set canvas rotation in degrees, accepts [-180, +180] or any degree.
     * @param {number} degrees
     */ this.setRotationDegrees = function(degrees) {
        const radians = degrees * Math.PI / 180;
        this.setRotationOnCenter(radians);
    };
    /**
     * Get the rotation as the nearest number of whole 90 degree clockwise rotations ([0..3])
     */ this.getRotation90 = function() {
        var rotation = Math.round(this.getRotation() / Math.PI * 2);
        // Just in case:
        rotation %= 4;
        // We want [0..3] as output
        if (rotation < 0) rotation += 4;
        return rotation;
    };
    /**
     *
     * @param zoom float
     * @param centerX float X co-ordinate in the canvas space
     * @param centerY float Y co-ordinate in the canvas space
     */ function zoomOnPoint(zoom, centerX, centerY) {
        zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));
        if (that.getZoom() != zoom) {
            var offset = that.getOffset();
            that.setOffset(offset.x + ~~((centerX - offset.x) * (1 - zoom / that.getZoom())), offset.y + ~~((centerY - offset.y) * (1 - zoom / that.getZoom())));
            that.setZoom(zoom);
            /*CPController.CPViewInfo viewInfo = new CPController.CPViewInfo();
            viewInfo.zoom = zoom;
            viewInfo.offsetX = offsetX;
            viewInfo.offsetY = offsetY;
            controller.callViewListeners(viewInfo); TODO */ that.repaintAll();
        }
    }
    // More advanced zoom methods
    function zoomOnCenter(zoom, snap = true) {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        if (snap) {
            // 拡大を1.41、縮小を0.7092にした関係で、zoomが浮動小数点になるため、1倍2倍に近い時は値をまるめる
            const roundedZoom = parseFloat(zoom);
            if (Math.abs(roundedZoom - 1) < 0.01) zoom = 1;
            else if (Math.abs(roundedZoom - 2) < 0.2) zoom = 2;
            else if (Math.abs(roundedZoom - 0.5) < 0.08) zoom = 0.5;
        // console.log("Math.abs(roundedZoom - 1)",Math.abs(roundedZoom - 1));
        // console.log("Math.abs(roundedZoom - 2)",Math.abs(roundedZoom - 2));
        // console.log("Math.abs(roundedZoom - 0.5)",Math.abs(roundedZoom - 0.5));
        // console.log("zoom",zoom);
        }
        zoomOnPoint(zoom, width / 2, height / 2);
    }
    this.zoomIn = function() {
        zoomOnCenter(this.getZoom() * 1.41);
    };
    this.zoomOut = function() {
        zoomOnCenter(this.getZoom() * 0.7092);
    };
    this.zoom100 = function() {
        zoomOnCenter(1);
        centerCanvas();
    };
    this.zoomOnCenter = (zoom, snap = false)=>{
        zoomOnCenter(zoom, snap);
    };
    this.resetRotation = function() {
        var center = {
            x: canvas.width / 2,
            y: canvas.height / 2
        }, rotTrans = new (0, _cptransformJsDefault.default)();
        rotTrans.rotateAroundPoint(-this.getRotation(), center.x, center.y);
        rotTrans.multiply(transform);
        //表示が左右反転している時は
        if (isViewFlipped) //さらに反転して戻す
        viewFlip(rotTrans);
        this.setOffset(~~rotTrans.getTranslateX(), ~~rotTrans.getTranslateY());
        this.setRotation(0);
        that.emitEvent("canvasRotated90", [
            0
        ]);
    };
    //ズームと回転をリセット
    this.resetZoomAndRotation = function() {
        this.zoom100();
        this.resetRotation();
        isViewFlipped = false;
        updateTransform({
            resetViewFlip: true
        });
    };
    //パンまたは回転モードかどうかを判定
    this.isPanOrRotateMode = function() {
        return isPinchZoomAllowed;
    };
    /**
     * Get the current pen pressure, given a pointer event.
     *
     * @param {PointerEvent} e
     *
     * @return {Number}
     */ function getPointerPressure(e) {
        // Safari fails to set pressure = 0.5 for mouse button down like it is supposed to
        if (e.pointerType === "mouse" && e.buttons !== 0 && e.pressure === 0) return 1;
        if (e.pointerType === "touch") {
            /* Some devices like iOS set pressure = 0 for all touch events, so detect that absence of pressure
             * and override to use a pressure of 1.0.
             *
             * Android provides useful pressure based on the finger's contact area with the screen (Pixel 4A).
             */ if (e.pressure !== 0) sawTouchWithPressure = true;
            if (sawTouchWithPressure) return e.pressure * 2;
            return 1.0;
        }
        /* In the Pointer Events API, mice have a default pressure of 0.5, but we want 1.0. Since we can't
         * reliably distinguish between mice and pens, we don't have any better options:
         */ return e.pressure * 2;
    }
    let mouseWheelDebounce = false;
    function handleMouseWheel(e) {
        if (e.deltaY != 0) {
            if (!mouseWheelDebounce || Math.abs(e.deltaY) > 20) {
                let factor;
                if (e.deltaY > 0) factor = 1 / 1.15;
                else factor = 1.15;
                let canvasPoint = mouseCoordToCanvas({
                    x: e.pageX,
                    y: e.pageY
                }), docPoint = coordToDocument(canvasPoint);
                if (artwork.isPointWithin(docPoint.x, docPoint.y)) zoomOnPoint(that.getZoom() * factor, canvasPoint.x, canvasPoint.y);
                else zoomOnPoint(that.getZoom() * factor, offsetX + ~~(artwork.width * zoom / 2), offsetY + ~~(artwork.height * zoom / 2));
                mouseWheelDebounce = mouseWheelDebounce || setTimeout(function() {
                    mouseWheelDebounce = false;
                }, 50);
            }
            e.preventDefault();
        }
    }
    //表示の左右反転を制御
    let isViewFlipped = false;
    this.toggleViewFlip = ()=>{
        if (!isViewFlipped) {
            viewFlip(transform);
            isViewFlipped = true;
            that.repaintAll();
        } else {
            isViewFlipped = false;
            updateTransform({
                resetViewFlip: true
            });
        }
        //呼び出し元で反転状態の判定処理
        return isViewFlipped;
    };
    //表示の左右反転
    function viewFlip(transform) {
        const cx = artwork.width / 2;
        transform.translate(cx, 0);
        transform.scale(-1, 1);
        transform.translate(-cx, 0);
    }
    // ペンでズーム
    let penZoomActive = false;
    let penStartX = 0;
    canvas.addEventListener("pointerdown", (e)=>{
        if (!e.altKey && (!e.ctrlKey && (0, _keymasterJsDefault.default).isPressed("z") || e.ctrlKey && (0, _keymasterJsDefault.default).isPressed("space")) && e.pointerType !== "touch") {
            penZoomActive = true;
            penStartX = e.clientX;
        }
    });
    canvas.addEventListener("pointermove", (e)=>{
        if (!e.altKey && (!e.ctrlKey && (0, _keymasterJsDefault.default).isPressed("z") || e.ctrlKey && (0, _keymasterJsDefault.default).isPressed("space")) && penZoomActive && e.pointerType !== "touch" && e.buttons === 1) {
            const deltaX = e.clientX - penStartX;
            if (Math.abs(deltaX) > 10) {
                const factor = deltaX > 0 ? 1.15 : 1 / 1.15;
                // ペンの現在位置をキャンバス座標に変換
                const canvasPoint = mouseCoordToCanvas({
                    x: e.pageX,
                    y: e.pageY
                });
                zoomOnPoint(that.getZoom() * factor, canvasPoint.x, canvasPoint.y);
                penStartX = e.clientX; // 連続ズーム対応
            }
            e.preventDefault();
        }
    });
    canvas.addEventListener("pointerup", (e)=>{
        if (e.pointerType !== "touch") penZoomActive = false;
    });
    //ピンチズーム
    let pinchStartDistance = 0;
    let pinchStartZoom = 1;
    let activeTouches = 0;
    function getDistance(touches) {
        const dx = touches[0].pageX - touches[1].pageX;
        const dy = touches[0].pageY - touches[1].pageY;
        return Math.sqrt(dx * dx + dy * dy);
    }
    function handleTouchStart(e) {
        activeTouches = e.touches.length;
        if (isPinchZoomAllowed && activeTouches === 2) {
            pinchStartDistance = getDistance(e.touches);
            pinchStartZoom = that.getZoom();
            e.preventDefault();
        }
    }
    function handleTouchEnd(e) {
        activeTouches = e.touches.length;
    }
    function handleTouchMove(e) {
        activeTouches = e.touches.length;
        if (isPinchZoomAllowed && activeTouches === 2) {
            const newDistance = getDistance(e.touches);
            const zoomFactor = newDistance / pinchStartDistance;
            // 2本の指の中点を取得（canvas space に変換）
            const midX = (e.touches[0].pageX + e.touches[1].pageX) / 2;
            const midY = (e.touches[0].pageY + e.touches[1].pageY) / 2;
            const canvasPoint = mouseCoordToCanvas({
                x: midX,
                y: midY
            });
            // すでにある zoomOnPoint を使う
            zoomOnPoint(pinchStartZoom * zoomFactor, canvasPoint.x, canvasPoint.y);
            e.preventDefault();
        }
    }
    let canvasClientRect;
    function handlePointerMove(e) {
        // Use the cached position of the canvas on the page if possible
        if (!canvasClientRect) canvasClientRect = canvas.getBoundingClientRect();
        if (sawPen && !isTouchInputAllowed && e.pointerType === "touch") //タッチインプットが許可されていないモードの時はペン対応デバイスのタッチイベントを無視する
        // Palm rejection for devices that support pens
        return;
        if (activeTouches > 1 && e.pointerType === "touch") //二本指以上の時は処理しない
        return;
        if ((0, _keymasterJsDefault.default).isPressed("z") || e.ctrlKey && (0, _keymasterJsDefault.default).isPressed("space")) // ズーム中は描画しない
        return;
        /* Store these globally for the event handlers to refer to (we'd write to the event itself but some browsers
         * don't enjoy that)
         */ mouseX = e.clientX - canvasClientRect.left;
        mouseY = e.clientY - canvasClientRect.top;
        const FLAG_PRIMARY = 1, FLAG_SECONDARY = 2, FLAG_WHEEL = 4, isDragging = e.buttons !== 0, pressure = isDragging ? getPointerPressure(e) : 0;
        // Did any of our buttons change state?
        if ((e.buttons & FLAG_PRIMARY) !== 0 != mouseDown[BUTTON_PRIMARY]) {
            mouseDown[BUTTON_PRIMARY] = !mouseDown[BUTTON_PRIMARY];
            if (mouseDown[BUTTON_PRIMARY]) modeStack.mouseDown(e, BUTTON_PRIMARY, pressure);
            else modeStack.mouseUp(e, BUTTON_PRIMARY, pressure);
        }
        if ((e.buttons & FLAG_SECONDARY) !== 0 != mouseDown[BUTTON_SECONDARY]) {
            mouseDown[BUTTON_SECONDARY] = !mouseDown[BUTTON_SECONDARY];
            if (mouseDown[BUTTON_SECONDARY]) modeStack.mouseDown(e, BUTTON_SECONDARY, pressure);
            else modeStack.mouseUp(e, BUTTON_SECONDARY, pressure);
        }
        if ((e.buttons & FLAG_WHEEL) !== 0 != mouseDown[BUTTON_WHEEL]) {
            mouseDown[BUTTON_WHEEL] = !mouseDown[BUTTON_WHEEL];
            if (mouseDown[BUTTON_WHEEL]) modeStack.mouseDown(e, BUTTON_WHEEL, pressure);
            else modeStack.mouseUp(e, BUTTON_WHEEL, pressure);
        }
        if (isDragging) modeStack.mouseDrag(e, pressure);
        else modeStack.mouseMove(e, pressure);
        if (!sawPen && e.pointerType === "pen") sawPen = true;
    }
    // Called when all mouse/pointer buttons are released
    function handlePointerUp(e) {
        mouseDown[BUTTON_PRIMARY] = false;
        mouseDown[BUTTON_SECONDARY] = false;
        mouseDown[BUTTON_WHEEL] = false;
        modeStack.mouseUp(e, e.button, 0.0);
        canvas.releasePointerCapture(e.pointerId);
    }
    // Called when the first button on the pointer is depressed / pen touches the surface
    function handlePointerDown(e) {
        if (sawPen && !isTouchInputAllowed && e.pointerType === "touch") //タッチインプットが許可されていないモードの時はペン対応デバイスのタッチイベントを無視する
        // Palm rejection for devices that support pens
        return;
        if ((0, _keymasterJsDefault.default).isPressed("z")) // ズーム中は描画しない
        return;
        canvas.setPointerCapture(e.pointerId);
        canvasClientRect = canvas.getBoundingClientRect();
        // Store these globally for the event handlers to refer to
        mouseX = e.clientX - canvasClientRect.left;
        mouseY = e.clientY - canvasClientRect.top;
        mouseDown[BUTTON_PRIMARY] = false;
        mouseDown[BUTTON_SECONDARY] = false;
        mouseDown[BUTTON_WHEEL] = false;
        mouseDown[e.button] = true;
        modeStack.mouseDown(e, e.button, getPointerPressure(e));
    }
    function handleKeyDown(e) {
        modeStack.keyDown(e);
    }
    function handleKeyUp(e) {
        //altキーを押下した直後にショートカットキーが動作しなくなる問題を修正
        if (e.key.toLowerCase() === "alt") //altキーが離された時のDefaultの動作をキャンセル
        e.preventDefault();
        modeStack.keyUp(e);
    }
    // Get the DOM element for the canvas area
    this.getElement = function() {
        return canvasContainer;
    };
    /**
     * Schedule a repaint for the current repaint region.
     */ function repaint() {
        if (!scheduledRepaint) {
            scheduledRepaint = true;
            window.requestAnimationFrame(function() {
                that.paint();
            });
        }
    }
    /**
     * Schedule a repaint for the entire screen.
     */ this.repaintAll = function() {
        repaintRegion.left = 0;
        repaintRegion.top = 0;
        repaintRegion.right = canvas.width;
        repaintRegion.bottom = canvas.height;
        repaint();
    };
    /**
     * Schedule a repaint for an area of the screen for later.
     *
     * @param rect CPRect Region that should be repainted using display coordinates
     */ function repaintRect(rect) {
        repaintRegion.union(rect);
        repaint();
    }
    this.paint = function() {
        var drawingWasClipped = false;
        scheduledRepaint = false;
        /* Clip drawing to the area of the screen we want to repaint */ if (!repaintRegion.isEmpty()) {
            canvasContext.save();
            if (canvasContext.clipTo) {
                canvasContext.beginPath();
                repaintRegion.left = repaintRegion.left | 0;
                repaintRegion.top = repaintRegion.top | 0;
                canvasContext.rect(repaintRegion.left, repaintRegion.top, Math.ceil(repaintRegion.getWidth()), Math.ceil(repaintRegion.getHeight()));
                canvasContext.clip();
            }
            drawingWasClipped = true;
        }
        /* Copy pixels that changed in the document into our local fused image cache */ if (!artworkUpdateRegion.isEmpty()) {
            let imageData;
            if (maskView && maskView.isOpen()) imageData = maskView.getImageData();
            else imageData = artwork.fusionLayers().getImageData();
            artworkCanvasContext.putImageData(imageData, 0, 0, artworkUpdateRegion.left, artworkUpdateRegion.top, artworkUpdateRegion.getWidth(), artworkUpdateRegion.getHeight());
            artworkUpdateRegion.makeEmpty();
        }
        canvasContext.fillStyle = "#606060";
        canvasContext.fillRect(0, 0, canvas.width, canvas.height);
        // Transform the coordinate system to bring the document into the right position on the screen (translate/zoom/etc)
        canvasContext.save();
        canvasContext.setTransform(transform.m[0], transform.m[1], transform.m[2], transform.m[3], transform.m[4], transform.m[5]);
        canvasContext.fillStyle = checkerboardPattern;
        canvasContext.fillRect(0, 0, artwork.width, artwork.height);
        canvasContext.drawImage(artworkCanvas, 0, 0, artworkCanvas.width, artworkCanvas.height);
        canvasContext.restore();
        // The rest of the drawing happens using the original screen coordinate system
        (0, _cpguiutilsJs.setContrastingDrawStyle)(canvasContext, "stroke");
        canvasContext.lineWidth = 1.0;
        // Draw the artwork selection so long as we're not in the middle of selecting a new rectangle
        if (!artwork.getSelection().isEmpty() && !(modeStack.peek() instanceof CPRectSelectionMode && modeStack.peek().capture)) {
            canvasContext.setLineDash([
                3,
                2
            ]);
            plotSelectionRect(canvasContext, artwork.getSelection());
            canvasContext.setLineDash([]);
        }
        // Draw grid
        if (showGrid) {
            var bounds = artwork.getBounds(), gridVisualPitch = zoom * gridSize;
            /* If the grid is going to be miniscule on the screen (basically just covering/inverting the entire artwork,
             * do not paint it.
             */ if (gridVisualPitch > 2) {
                canvasContext.beginPath();
                // Vertical lines
                for(let i = gridSize - 1; i < bounds.right; i += gridSize){
                    let p1 = coordToDisplay({
                        x: i,
                        y: bounds.top
                    }), p2 = coordToDisplay({
                        x: i,
                        y: bounds.bottom
                    });
                    canvasContext.moveTo(p1.x + 0.5, p1.y + 0.5);
                    canvasContext.lineTo(p2.x + 0.5, p2.y + 0.5);
                }
                // Horizontal lines
                for(let i = gridSize - 1; i < bounds.bottom; i += gridSize){
                    let p1 = coordToDisplay({
                        x: 0,
                        y: i
                    }), p2 = coordToDisplay({
                        x: bounds.right,
                        y: i
                    });
                    canvasContext.moveTo(p1.x + 0.5, p1.y + 0.5);
                    canvasContext.lineTo(p2.x + 0.5, p2.y + 0.5);
                }
                canvasContext.stroke();
            }
        }
        // Additional drawing by the current mode
        modeStack.paint(canvasContext);
        canvasContext.globalCompositeOperation = "source-over";
        if (drawingWasClipped) {
            repaintRegion.makeEmpty();
            canvasContext.restore();
        }
    };
    this.showGrid = function(show) {
        showGrid = show;
        this.repaintAll();
    };
    /**
     * Resize the canvas area to the given height (in pixels)
     *
     * @param {number} height New canvas area height in CSS pixels
     * @param {boolean} skipCenter True if the canvas should not be re-centered
     */ this.resize = function(height, skipCenter) {
        // Leave room for the bottom scrollbar
        height -= canvasContainerBottom.offsetHeight;
        //canvas.hightでは少数点以下が切り捨てられるため
        //canvas.style.heightに小数点が入るとcanvasの大きさが変わる
        //事前Math.floorで整数化
        height = Math.floor(height);
        canvas.style.height = height + "px";
        canvas.width = canvas.clientWidth;
        canvas.height = height;
        canvasClientRect = null;
        if (!skipCenter) centerCanvas();
        // Interpolation property gets reset when canvas resizes
        this.setInterpolation(interpolation);
        this.repaintAll();
    };
    controller.on("toolChange", function(tool, toolInfo) {
        var newMode = drawingModes[toolInfo.strokeMode];
        // If we currently have any drawing modes active, switch them to the drawing mode of the new tool
        for(var i = 0; i < modeStack.modes.length; i++)if (modeStack.modes[i] instanceof CPDrawingMode) {
            modeStack.modes[i].leave();
            modeStack.modes[i] = newMode;
            modeStack.modes[i].enter();
            break;
        }
        curDrawMode = newMode;
    });
    controller.on("modeChange", function(mode) {
        var newMode;
        switch(mode){
            case (0, _chickenPaintJsDefault.default).M_DRAW:
                newMode = curDrawMode;
                break;
            case (0, _chickenPaintJsDefault.default).M_FLOODFILL:
                newMode = floodFillMode;
                break;
            case (0, _chickenPaintJsDefault.default).M_GRADIENTFILL:
                newMode = gradientFillMode;
                break;
            case (0, _chickenPaintJsDefault.default).M_RECT_SELECTION:
                newMode = rectSelectionMode;
                break;
            case (0, _chickenPaintJsDefault.default).M_MOVE_TOOL:
                newMode = moveToolMode;
                break;
            case (0, _chickenPaintJsDefault.default).M_ROTATE_CANVAS:
                newMode = rotateCanvasMode;
                break;
            case (0, _chickenPaintJsDefault.default).M_PAN_CANVAS:
                newMode = panMode;
                break;
            case (0, _chickenPaintJsDefault.default).M_COLOR_PICKER:
                newMode = colorPickerMode;
                break;
            case (0, _chickenPaintJsDefault.default).M_TRANSFORM:
                newMode = transformMode;
                break;
        }
        isPinchZoomAllowed = mode === (0, _chickenPaintJsDefault.default).M_PAN_CANVAS || mode === (0, _chickenPaintJsDefault.default).M_ROTATE_CANVAS;
        isTouchInputAllowed = mode === (0, _chickenPaintJsDefault.default).M_MOVE_TOOL || mode === (0, _chickenPaintJsDefault.default).M_ROTATE_CANVAS || mode === (0, _chickenPaintJsDefault.default).M_PAN_CANVAS;
        modeStack.setUserMode(newMode);
    });
    function onMaskViewChangeLayer() {
        artworkUpdateRegion = artwork.getBounds();
        that.repaintAll();
    }
    controller.on("maskViewOpened", function(newMaskView) {
        if (maskView) maskView.off("changeLayer", onMaskViewChangeLayer);
        maskView = newMaskView;
        maskView.on("changeLayer", onMaskViewChangeLayer);
        onMaskViewChangeLayer();
    });
    //
    // Modes system: modes control the way the GUI is reacting to the user input
    // All the tools are implemented through modes
    //
    defaultMode = new CPDefaultMode();
    colorPickerMode = new CPColorPickerMode();
    panMode = new CPPanCanvasMode();
    rotateCanvasMode = new CPRotateCanvasMode();
    floodFillMode = new CPFloodFillMode();
    gradientFillMode = new CPGradientFillMode();
    rectSelectionMode = new CPRectSelectionMode();
    moveToolMode = new CPMoveToolMode();
    transformMode = new CPTransformMode();
    // this must correspond to the stroke modes defined in CPToolInfo
    drawingModes = [
        new CPFreehandMode(),
        new CPLineMode(),
        new CPBezierMode()
    ];
    curDrawMode = drawingModes[(0, _cpbrushInfoJsDefault.default).STROKE_MODE_FREEHAND];
    // The default mode will handle the events that no other modes are interested in
    modeStack.setDefaultMode(defaultMode);
    modeStack.setUserMode(curDrawMode);
    artworkCanvas.width = artwork.width;
    artworkCanvas.height = artwork.height;
    canvas.width = 800;
    canvas.height = 900;
    canvas.className = "chickenpaint-canvas";
    canvas.setAttribute("touch-action", "none");
    if (!canvasContext.setLineDash) canvasContext.setLineDash = function() {}; // For IE 10 and older
    canvas.addEventListener("contextmenu", function(e) {
        e.preventDefault();
    });
    canvas.addEventListener("mouseenter", function() {
        mouseIn = true;
    });
    canvas.addEventListener("mouseleave", function() {
        mouseIn = false;
        if (!mouseDown[BUTTON_PRIMARY] && !mouseDown[BUTTON_SECONDARY] && !mouseDown[BUTTON_WHEEL]) that.repaintAll();
    });
    canvas.addEventListener("pointerdown", handlePointerDown);
    canvas.addEventListener("pointermove", handlePointerMove);
    canvas.addEventListener("touchstart", handleTouchStart, {
        passive: false
    });
    canvas.addEventListener("touchend", handleTouchEnd, {
        passive: false
    });
    canvas.addEventListener("touchmove", handleTouchMove, {
        passive: false
    });
    canvas.addEventListener("pointerup", handlePointerUp);
    canvas.addEventListener("wheel", handleMouseWheel, {
        passive: false
    });
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);
    /* Workaround for Chrome Mac bug that causes canvas to be disposed and never recreated when tab is switched into the
     * background https://bugs.chromium.org/p/chromium/issues/detail?id=588434
     */ document.addEventListener("visibilitychange", function() {
        const oldHeight = canvas.height + canvasContainerBottom.offsetHeight;
        canvas.width = 1;
        canvas.height = 1;
        that.resize(oldHeight, true);
    }, false);
    window.addEventListener("scroll", function() {
        canvasClientRect = null;
    });
    canvas.addEventListener("mousedown", function(e) {
        if (e.button == BUTTON_WHEEL) // Prevent middle-mouse scrolling in Firefox
        e.preventDefault();
    });
    artwork.on("changeSelection", function() {
        // We could keep track of our last-painted selection rect and only invalidate that here
        that.repaintAll();
    });
    artwork.on("updateRegion", function(region) {
        artworkUpdateRegion.union(region);
        repaintRect(getRefreshArea(artworkUpdateRegion));
    });
    horzScroll.on("valueChanged", function(value) {
        var p = that.getOffset();
        that.setOffset(-value, p.y);
    });
    vertScroll.on("valueChanged", function(value) {
        var p = that.getOffset();
        that.setOffset(p.x, -value);
    });
    //初期状態で、ズームのアンチエイリアスをOnに
    this.setInterpolation(true);
    var canvasSpacingWrapper = document.createElement("div");
    canvasSpacingWrapper.className = "chickenpaint-canvas-container-wrapper";
    canvasSpacingWrapper.appendChild(canvas);
    canvasContainerTop.className = "chickenpaint-canvas-container-top";
    canvasContainerTop.appendChild(canvasSpacingWrapper);
    canvasContainerTop.appendChild(vertScroll.getElement());
    canvasContainerBottom.className = "chickenpaint-canvas-container-bottom";
    canvasContainerBottom.appendChild(horzScroll.getElement());
    canvasContainer.appendChild(canvasContainerTop);
    canvasContainer.appendChild(canvasContainerBottom);
    controller.setCanvas(this);
}
CPCanvas.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
CPCanvas.prototype.constructor = CPCanvas;

},{"../languages/lang.js":"9myCU","wolfy87-eventemitter":"gPUo0","../../lib/keymaster.js":"hFCDu","../util/CPRect.js":"aDqvw","../util/CPTransform.js":"hM3oc","../util/CPBezier.js":"881mj","../util/throttle-debounce.js":"2HXyQ","../util/CPPolygon.js":"dNatU","../util/CPPolyfill.js":"89GR9","../util/CPVector.js":"9LpxA","../ChickenPaint.js":"3lJkm","../engine/CPBrushInfo.js":"b7K5Z","../engine/CPLayerGroup.js":"k5mD3","../engine/CPMaskView.js":"iy9lO","./CPGUIUtils.js":"9eZG7","./CPScrollbar.js":"6V1eC","../util/CPColor.js":"ioCeM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hFCDu":[function(require,module,exports,__globalThis) {
//     keymaster.js
//     (c) 2011-2013 Thomas Fuchs
//     keymaster.js may be freely distributed under the MIT license.
(function(global) {
    var k, _handlers = {}, _mods = {
        16: false,
        18: false,
        17: false,
        91: false
    }, _scope = 'all', // modifier keys
    _MODIFIERS = {
        "\u21E7": 16,
        shift: 16,
        "\u2325": 18,
        alt: 18,
        option: 18,
        "\u2303": 17,
        ctrl: 17,
        control: 17,
        "\u2318": 91,
        command: 91
    }, // special keys
    _MAP = {
        backspace: 8,
        tab: 9,
        clear: 12,
        enter: 13,
        'return': 13,
        esc: 27,
        escape: 27,
        space: 32,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        del: 46,
        'delete': 46,
        home: 36,
        end: 35,
        pageup: 33,
        pagedown: 34,
        ',': 188,
        '.': 190,
        '/': 191,
        '`': 192,
        '-': 189,
        '=': 187,
        ';': 186,
        '\'': 222,
        '[': 219,
        ']': 221,
        '\\': 220
    }, code = function(x) {
        var code = _MAP[x] || x.toUpperCase().charCodeAt(0);
        return typeof code === "function" ? code() : code;
    }, _downKeys = [];
    for(k = 1; k < 20; k++)_MAP['f' + k] = 111 + k;
    // IE doesn't support Array#indexOf, so have a simple replacement
    function index(array, item) {
        var i = array.length;
        while(i--)if (array[i] === item) return i;
        return -1;
    }
    // for comparing mods before unassignment
    function compareArray(a1, a2) {
        if (a1.length != a2.length) return false;
        for(var i = 0; i < a1.length; i++){
            if (a1[i] !== a2[i]) return false;
        }
        return true;
    }
    function getBrowserName() {
        if (navigator.userAgent.toLowerCase().indexOf('firefox') > 0) return "firefox";
    }
    var modifierMap = {
        16: 'shiftKey',
        18: 'altKey',
        17: 'ctrlKey',
        91: 'metaKey'
    };
    function updateModifierKey(event) {
        for(k in _mods)_mods[k] = event[modifierMap[k]];
    }
    // handle keydown event
    function dispatch(event) {
        var key, handler, k, i, modifiersMatch, scope;
        //   key = event.keyCode;
        key = getKeyCodeFromKey(event.key);
        if (index(_downKeys, key) == -1) _downKeys.push(key);
        // if a modifier key, set the key.<modifierkeyname> property to true and return
        if (key in _mods) {
            _mods[key] = true;
            // 'assignKey' from inside this closure is exported to window.key
            for(k in _MODIFIERS)if (_MODIFIERS[k] == key) assignKey[k] = true;
            return;
        }
        updateModifierKey(event);
        // see if we need to ignore the keypress (filter() can can be overridden)
        // by default ignore key presses if a select, textarea, or input is focused
        if (!assignKey.filter.call(this, event)) return;
        // abort if no potentially matching shortcuts found
        if (!(key in _handlers)) return;
        scope = getScope();
        // for each potential shortcut
        for(i = 0; i < _handlers[key].length; i++){
            handler = _handlers[key][i];
            // see if it's in the current scope
            if (handler.scope == scope || handler.scope == 'all') {
                // check if modifiers match if any
                modifiersMatch = handler.mods.length > 0;
                for(k in _mods)if (!_mods[k] && index(handler.mods, +k) > -1 || _mods[k] && index(handler.mods, +k) == -1) modifiersMatch = false;
                // call the handler and stop the event if neccessary
                if (handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch) {
                    if (handler.method(event, handler) === false) {
                        if (event.preventDefault) event.preventDefault();
                        else event.returnValue = false;
                        if (event.stopPropagation) event.stopPropagation();
                        if (event.cancelBubble) event.cancelBubble = true;
                    }
                }
            }
        }
    }
    // unset modifier keys on keyup
    function clearModifier(event) {
        //   var key = event.keyCode, k,
        var key = getKeyCodeFromKey(event.key), k, i = index(_downKeys, key);
        // remove key from _downKeys
        if (i >= 0) _downKeys.splice(i, 1);
        if (key in _mods) {
            _mods[key] = false;
            for(k in _MODIFIERS)if (_MODIFIERS[k] == key) assignKey[k] = false;
        }
    }
    function resetModifiers() {
        for(k in _mods)_mods[k] = false;
        for(k in _MODIFIERS)assignKey[k] = false;
    }
    // parse and assign shortcut
    function assignKey(key, scope, method) {
        var keys, mods;
        keys = getKeys(key);
        if (method === undefined) {
            method = scope;
            scope = 'all';
        }
        // for each shortcut
        for(var i = 0; i < keys.length; i++){
            // set modifier keys if any
            mods = [];
            key = keys[i].split('+');
            if (key.length > 1) {
                mods = getMods(key);
                key = [
                    key[key.length - 1]
                ];
            }
            // convert to keycode and...
            key = key[0];
            key = code(key);
            // ...store handler
            if (!(key in _handlers)) _handlers[key] = [];
            _handlers[key].push({
                shortcut: keys[i],
                scope: scope,
                method: method,
                key: keys[i],
                mods: mods
            });
        }
    }
    // unbind all handlers for given key in current scope
    function unbindKey(key, scope) {
        var multipleKeys, keys, mods = [], i, j, obj;
        multipleKeys = getKeys(key);
        for(j = 0; j < multipleKeys.length; j++){
            keys = multipleKeys[j].split('+');
            if (keys.length > 1) mods = getMods(keys);
            key = keys[keys.length - 1];
            key = code(key);
            if (scope === undefined) scope = getScope();
            if (!_handlers[key]) return;
            for(i = 0; i < _handlers[key].length; i++){
                obj = _handlers[key][i];
                // only clear handlers if correct scope and mods match
                if (obj.scope === scope && compareArray(obj.mods, mods)) _handlers[key][i] = {};
            }
        }
    }
    // Returns true if the key with code 'keyCode' is currently down
    // Converts strings into key codes.
    function isPressed(keyCode) {
        if (typeof keyCode == 'string') keyCode = code(keyCode);
        return index(_downKeys, keyCode) != -1;
    }
    function getPressedKeyCodes() {
        return _downKeys.slice(0);
    }
    function filter(event) {
        var tagName = (event.target || event.srcElement).tagName;
        // ignore keypressed in any elements that support keyboard data input
        return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');
    }
    // initialize key.<modifier> to false
    for(k in _MODIFIERS)assignKey[k] = false;
    // set current scope (default 'all')
    function setScope(scope) {
        _scope = scope || 'all';
    }
    function getScope() {
        return _scope || 'all';
    }
    // delete all handlers for a given scope
    function deleteScope(scope) {
        var key, handlers, i;
        for(key in _handlers){
            handlers = _handlers[key];
            for(i = 0; i < handlers.length;)if (handlers[i].scope === scope) handlers.splice(i, 1);
            else i++;
        }
    }
    // abstract key logic for assign and unassign
    function getKeys(key) {
        var keys;
        key = key.replace(/\s/g, '');
        keys = key.split(',');
        if (keys[keys.length - 1] == '') keys[keys.length - 2] += ',';
        return keys;
    }
    // abstract mods logic for assign and unassign
    function getMods(key) {
        var mods = key.slice(0, key.length - 1);
        for(var mi = 0; mi < mods.length; mi++)mods[mi] = _MODIFIERS[mods[mi]];
        return mods;
    }
    // cross-browser events
    function addEvent(object, event, method) {
        if (object.addEventListener) object.addEventListener(event, method, false);
    //   else if(object.attachEvent)
    // 	object.attachEvent('on'+event, function(){ method(window.event) });
    }
    // set the handlers globally on document
    addEvent(document, 'keydown', function(event) {
        dispatch(event);
    }); // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48
    addEvent(document, 'keyup', clearModifier);
    // reset modifiers to false whenever the window is (re)focused.
    addEvent(window, 'focus', resetModifiers);
    // store previously defined key
    var previousKey = global.key;
    // restore previously defined key and return reference to our key object
    function noConflict() {
        var k = global.key;
        global.key = previousKey;
        return k;
    }
    // set window.key and window.key.set/get/deleteScope, and the default filter
    global.key = assignKey;
    global.key.setScope = setScope;
    global.key.getScope = getScope;
    global.key.deleteScope = deleteScope;
    global.key.filter = filter;
    global.key.isPressed = isPressed;
    global.key.getPressedKeyCodes = getPressedKeyCodes;
    global.key.noConflict = noConflict;
    global.key.unbind = unbindKey;
    module.exports = assignKey;
})(this || {});
function getKeyCodeFromKey(key) {
    // 特殊キーのマッピングにアルファベットを追加
    // 特殊キーのマッピング
    var specialKeys = {
        'DELETE': 46,
        'BACKSPACE': 8,
        'TAB': 9,
        'ENTER': 13,
        'ESCAPE': 27,
        ' ': 32,
        'ARROWLEFT': 37,
        'ARROWUP': 38,
        'ARROWRIGHT': 39,
        'ARROWDOWN': 40,
        'SHIFT': 16,
        '[': 219,
        ']': 221,
        '1': 49,
        '2': 50,
        '3': 51,
        '4': 52,
        '5': 53,
        '6': 54,
        '7': 55,
        '8': 56,
        '9': 57,
        '0': 48,
        '-': 189,
        '=': 187,
        '+': 187,
        ';': 187,
        'META': 91,
        'LEFTMETA': 91,
        'RIGHTMETA': 91,
        'ALT': 18,
        'ALTGRAPH': 18,
        'OPTION': 18,
        'CONTROL': 17
    };
    for(var i = 65; i <= 90; i++){
        var Alphabet_key = String.fromCharCode(i);
        specialKeys[Alphabet_key] = i;
    }
    key = key.toUpperCase();
    // 特殊キーの場合はマッピングされた値を返す
    if (key in specialKeys) return specialKeys[key];
}

},{}],"881mj":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPBezier);
function CPBezier() {
    // How to use this class:
    //
    // 1 - set the 4 points coordinates (x0-3, y0-3)
    // two options:
    // 2a - call init() with desired dt then read the current coordinate (Bx, By) and use nextPoint() to compute the
    // next point
    // 2b - use one of the "compute" methods to compute the values for the whole curve in one step
    // The 4 points coordinates
    this.x0 = this.y0 = this.x1 = this.y1 = this.x2 = this.y2 = this.x3 = this.y3 = 0.0;
    // used to compute the Bezier curve with the forward differences method
    let Bx, dBx, ddBx, dddBx, By, dBy, ddBy, dddBy;
    const init = (dt)=>{
        // Implements a fast degree-3 Bezier curve using the forward differences method
        //
        // Reference for this algorithm:
        // "Curves and Surfaces for Computer Graphics" by David Salomon, page 189
        let q1 = 3.0 * dt, q2 = q1 * dt, q3 = dt * dt * dt, q4 = 2.0 * q2, q5 = 6.0 * q3, q6x = this.x0 - 2.0 * this.x1 + this.x2, q6y = this.y0 - 2.0 * this.y1 + this.y2, q7x = 3.0 * (this.x1 - this.x2) - this.x0 + this.x3, q7y = 3.0 * (this.y1 - this.y2) - this.y0 + this.y3;
        Bx = this.x0;
        By = this.y0;
        dBx = (this.x1 - this.x0) * q1 + q6x * q2 + q7x * q3;
        dBy = (this.y1 - this.y0) * q1 + q6y * q2 + q7y * q3;
        ddBx = q6x * q4 + q7x * q5;
        ddBy = q6y * q4 + q7y * q5;
        dddBx = q7x * q5;
        dddBy = q7y * q5;
    };
    /**
     * Fill the given x,y arrays with a series of points on the curve.
     * 
     * @param {Number[]} x
     * @param {Number[]} y
     *
     * @param {number} elements Count of elements to fill x and y arrays
     */ this.compute = (x, y, elements)=>{
        init(1.0 / elements);
        x[0] = Bx;
        y[0] = By;
        for(let i = 1; i < elements; i++){
            Bx += dBx;
            By += dBy;
            dBx += ddBx;
            dBy += ddBy;
            ddBx += dddBx;
            ddBy += dddBy;
            x[i] = Bx;
            y[i] = By;
        }
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2HXyQ":[function(require,module,exports,__globalThis) {
/*!
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */ // Script: jQuery throttle / debounce: Sometimes, less is more!
//
// *Version: 1.1, Last updated: 3/7/2010*
// 
// Project Home - http://benalman.com/projects/jquery-throttle-debounce-plugin/
// GitHub       - http://github.com/cowboy/jquery-throttle-debounce/
// Source       - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.js
// (Minified)   - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.min.js (0.7kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Throttle - http://benalman.com/code/projects/jquery-throttle-debounce/examples/throttle/
// Debounce - http://benalman.com/code/projects/jquery-throttle-debounce/examples/debounce/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - none, 1.3.2, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-throttle-debounce/unit/
// 
// About: Release History
// 
// 1.1 - (3/7/2010) Fixed a bug in <jQuery.throttle> where trailing callbacks
//       executed later than they should. Reworked a fair amount of internal
//       logic as well.
// 1.0 - (3/6/2010) Initial release as a stand-alone project. Migrated over
//       from jquery-misc repo v0.4 to jquery-throttle repo v1.0, added the
//       no_trailing throttle parameter and debounce functionality.
// Method: throttle
//
// Throttle execution of a function. Especially useful for rate limiting
// execution of handlers on events like resize and scroll. If you want to
// rate-limit execution of a function to a single time, see the
// <jQuery.debounce> method.
//
// In this visualization, | is a throttled-function call and X is the actual
// callback execution:
//
// > Throttled with `no_trailing` specified as false or unspecified:
// > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
// > X    X    X    X    X    X        X    X    X    X    X    X
// >
// > Throttled with `no_trailing` specified as true:
// > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
// > X    X    X    X    X             X    X    X    X    X
//
// Usage:
//
// > var throttled = jQuery.throttle( delay, [ no_trailing, ] callback );
// >
// > jQuery('selector').bind( 'someevent', throttled );
// > jQuery('selector').unbind( 'someevent', throttled );
//
// This also works in jQuery 1.4+:
//
// > jQuery('selector').bind( 'someevent', jQuery.throttle( delay, [ no_trailing, ] callback ) );
// > jQuery('selector').unbind( 'someevent', callback );
//
// Arguments:
//
//  delay - (Number) A zero-or-greater delay in milliseconds. For event
//    callbacks, values around 100 or 250 (or even higher) are most useful.
//  no_trailing - (Boolean) Optional, defaults to false. If no_trailing is
//    true, callback will only execute every `delay` milliseconds while the
//    throttled-function is being called. If no_trailing is false or
//    unspecified, callback will be executed one final time after the last
//    throttled-function call. (After the throttled-function has not been
//    called for `delay` milliseconds, the internal counter is reset)
//  callback - (Function) A function to be executed after delay milliseconds.
//    The `this` context and all arguments are passed through, as-is, to
//    `callback` when the throttled-function is executed.
//
// Returns:
//
//  (Function) A new, throttled, function.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "throttle", ()=>throttle);
// Method: jQuery.debounce
//
// Debounce execution of a function. Debouncing, unlike throttling,
// guarantees that a function is only executed a single time, either at the
// very beginning of a series of calls, or at the very end. If you want to
// simply rate-limit execution of a function, see the <jQuery.throttle>
// method.
//
// In this visualization, | is a debounced-function call and X is the actual
// callback execution:
//
// > Debounced with `at_begin` specified as false or unspecified:
// > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
// >                          X                                 X
// >
// > Debounced with `at_begin` specified as true:
// > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
// > X                                 X
//
// Usage:
//
// > var debounced = jQuery.debounce( delay, [ at_begin, ] callback );
// >
// > jQuery('selector').bind( 'someevent', debounced );
// > jQuery('selector').unbind( 'someevent', debounced );
//
// This also works in jQuery 1.4+:
//
// > jQuery('selector').bind( 'someevent', jQuery.debounce( delay, [ at_begin, ] callback ) );
// > jQuery('selector').unbind( 'someevent', callback );
//
// Arguments:
//
//  delay - (Number) A zero-or-greater delay in milliseconds. For event
//    callbacks, values around 100 or 250 (or even higher) are most useful.
//  at_begin - (Boolean) Optional, defaults to false. If at_begin is false or
//    unspecified, callback will only be executed `delay` milliseconds after
//    the last debounced-function call. If at_begin is true, callback will be
//    executed only at the first debounced-function call. (After the
//    throttled-function has not been called for `delay` milliseconds, the
//    internal counter is reset)
//  callback - (Function) A function to be executed after delay milliseconds.
//    The `this` context and all arguments are passed through, as-is, to
//    `callback` when the debounced-function is executed.
//
// Returns:
//
//  (Function) A new, debounced, function.
parcelHelpers.export(exports, "debounce", ()=>debounce);
function throttle(delay, no_trailing, callback, debounce_mode) {
    // After wrapper has stopped being called, this timeout ensures that
    // `callback` is executed at the proper times in `throttle` and `end`
    // debounce modes.
    var timeout_id, // Keep track of the last time `callback` was executed.
    last_exec = 0;
    // `no_trailing` defaults to falsy.
    if (typeof no_trailing !== 'boolean') {
        debounce_mode = callback;
        callback = no_trailing;
        no_trailing = undefined;
    }
    // The `wrapper` function encapsulates all of the throttling / debouncing
    // functionality and when executed will limit the rate at which `callback`
    // is executed.
    function wrapper() {
        var that = this, elapsed = +new Date() - last_exec, args = arguments;
        // Execute `callback` and update the `last_exec` timestamp.
        function exec() {
            last_exec = +new Date();
            callback.apply(that, args);
        }
        // If `debounce_mode` is true (at_begin) this is used to clear the flag
        // to allow future `callback` executions.
        function clear() {
            timeout_id = undefined;
        }
        if (debounce_mode && !timeout_id) // Since `wrapper` is being called for the first time and
        // `debounce_mode` is true (at_begin), execute `callback`.
        exec();
        // Clear any existing timeout.
        timeout_id && clearTimeout(timeout_id);
        if (debounce_mode === undefined && elapsed > delay) // In throttle mode, if `delay` time has been exceeded, execute
        // `callback`.
        exec();
        else if (no_trailing !== true) // In trailing throttle mode, since `delay` time has not been
        // exceeded, schedule `callback` to execute `delay` ms after most
        // recent execution.
        //
        // If `debounce_mode` is true (at_begin), schedule `clear` to execute
        // after `delay` ms.
        //
        // If `debounce_mode` is false (at end), schedule `callback` to
        // execute after `delay` ms.
        timeout_id = setTimeout(debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay);
    }
    // Return the wrapper function.
    return wrapper;
}
function debounce(delay, at_begin, callback) {
    return callback === undefined ? throttle(delay, at_begin, false) : throttle(delay, callback, at_begin !== false);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dNatU":[function(require,module,exports,__globalThis) {
/*
	ChickenPaint

	ChickenPaint is a translation of ChibiPaint from Java to JavaScript
	by Nicholas Sherlock / Chicken Smoothie.

	ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

	ChickenPaint is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	ChickenPaint is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPPolygon);
var _cptransformJs = require("./CPTransform.js");
var _cptransformJsDefault = parcelHelpers.interopDefault(_cptransformJs);
function CPPolygon(points) {
    this.points = points || [];
}
CPPolygon.prototype.clone = function() {
    var result = new CPPolygon(new Array(this.points.length));
    for(var i = 0; i < this.points.length; i++)// Deep clone
    result.points[i] = {
        x: this.points[i].x,
        y: this.points[i].y
    };
    return result;
};
/**
 * Get a new polygon which is the result of transforming the points of this polygon with the given affine transform.
 *
 * @param {CPTransform} affineTransform
 * @returns {CPPolygon}
 */ CPPolygon.prototype.getTransformed = function(affineTransform) {
    var result = new CPPolygon(new Array(this.points.length));
    for(var i = 0; i < this.points.length; i++)result.points[i] = affineTransform.getTransformedPoint(this.points[i]);
    return result;
};
/**
 * Get the average of all the points in the polygon (the "center").
 *
 * @returns {{x: number, y: number}}
 */ CPPolygon.prototype.getCenter = function() {
    var centerX = this.points[0].x, centerY = this.points[0].y;
    for(var i = 1; i < this.points.length; i++){
        centerX += this.points[i].x;
        centerY += this.points[i].y;
    }
    return {
        x: centerX / this.points.length,
        y: centerY / this.points.length
    };
};
/**
 * From https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
 *
 * @param point
 * @returns {boolean}
 */ CPPolygon.prototype.containsPoint = function(point) {
    var i, j, contained = false;
    for(i = 0, j = this.points.length - 1; i < this.points.length; j = i++)if (this.points[i].y > point.y != this.points[j].y > point.y && point.x < (this.points[j].x - this.points[i].x) * (point.y - this.points[i].y) / (this.points[j].y - this.points[i].y) + this.points[i].x) contained = !contained;
    return contained;
};

},{"./CPTransform.js":"hM3oc","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9LpxA":[function(require,module,exports,__globalThis) {
/*
	ChickenPaint

	ChickenPaint is a translation of ChibiPaint from Java to JavaScript
	by Nicholas Sherlock / Chicken Smoothie.

	ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

	ChickenPaint is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	ChickenPaint is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ /**
 *
 * @param x
 * @param y
 *
 * @constructor
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPVector);
function CPVector(x, y) {
    this.x = x;
    this.y = y;
}
CPVector.prototype.getLength = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};
/**
 *
 * @returns {CPVector} This vector for chaining
 */ CPVector.prototype.normalize = function() {
    var length = this.getLength();
    this.x /= length;
    this.y /= length;
    return this;
};
/**
 *
 * @param {CPVector} that
 */ CPVector.prototype.getDotProduct = function(that) {
    return this.x * that.x + this.y * that.y;
};
/**
 *
 * @param {numeric} scaleFactor
 * @returns {CPVector} This vector for chaining
 */ CPVector.prototype.scale = function(scaleFactor) {
    this.x *= scaleFactor;
    this.y *= scaleFactor;
    return this;
};
CPVector.prototype.getScaled = function(scaleFactor) {
    var result = new CPVector(this.x, this.y);
    result.scale(scaleFactor);
    return result;
};
CPVector.prototype.getRounded = function() {
    return new CPVector(Math.round(this.x), Math.round(this.y));
};
CPVector.prototype.getTruncated = function() {
    return new CPVector(~~this.x, ~~this.y);
};
CPVector.prototype.getPerpendicular = function() {
    return new CPVector(-this.y, this.x);
};
/**
 * Add that vector to this one
 *
 * @param {CPVector} that
 * @returns {CPVector} This vector for chaining
 */ CPVector.prototype.add = function(that) {
    this.x += that.x;
    this.y += that.y;
    return this;
};
/**
 * Subtract that vector from this one
 *
 * @param {CPVector} that
 * @returns {CPVector} This vector for chaining
 */ CPVector.prototype.subtract = function(that) {
    this.x -= that.x;
    this.y -= that.y;
    return this;
};
/**
 * Get the sum of this vector and that one.
 *
 * @param {CPVector} that
 * @returns {CPVector}
 */ CPVector.prototype.getSum = function(that) {
    return new CPVector(this.x + that.x, this.y + that.y);
};
/**
 * Create a new vector by p1 - p2
 *
 * @param p1
 * @param p2
 *
 * @returns {CPVector}
 */ CPVector.subtractPoints = function(p1, p2) {
    return new CPVector(p1.x - p2.x, p1.y - p2.y);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9eZG7":[function(require,module,exports,__globalThis) {
/**
 * Create a checkerboard HTML5 CanvasPattern (which can be used for fillStyle) using the given canvas context.
 * 
 * @param canvasContext
 * @returns {CanvasPattern}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createCheckerboardPattern", ()=>createCheckerboardPattern);
/**
 * Set the globalCompositeOperation and fill/stroke color up to maximize contrast for the drawn items
 * against arbitrary backgrounds.
 *
 * @param {CanvasRenderingContext2D} canvasContext
 * @param {string} kind - "stroke" or "fill" depending on which colour you'd like to set
 */ parcelHelpers.export(exports, "setContrastingDrawStyle", ()=>setContrastingDrawStyle);
function createCheckerboardPattern(canvasContext) {
    var checkerboardCanvas = document.createElement("canvas"), checkerboardContext = checkerboardCanvas.getContext("2d"), imageData = checkerboardContext.createImageData(64, 64), data = imageData.data, pixelOffset = 0;
    for(var j = 0; j < 64; j++){
        for(var i = 0; i < 64; i++)if ((i & 0x8) != 0 !== ((j & 0x8) != 0)) {
            // White
            data[pixelOffset++] = 0xff;
            data[pixelOffset++] = 0xff;
            data[pixelOffset++] = 0xff;
            data[pixelOffset++] = 0xff;
        } else {
            // Grey
            data[pixelOffset++] = 0xcc;
            data[pixelOffset++] = 0xcc;
            data[pixelOffset++] = 0xcc;
            data[pixelOffset++] = 0xff;
        }
    }
    checkerboardCanvas.width = 64;
    checkerboardCanvas.height = 64;
    checkerboardContext.putImageData(imageData, 0, 0);
    return canvasContext.createPattern(checkerboardCanvas, 'repeat');
}
function setContrastingDrawStyle(canvasContext, kind) {
    kind = kind + "Style";
    canvasContext.globalCompositeOperation = 'exclusion';
    if (canvasContext.globalCompositeOperation == "exclusion") // White + exclusion inverts the colors underneath, giving us good contrast
    canvasContext[kind] = 'white';
    else {
        // IE Edge doesn't support Exclusion, so how about Difference with mid-grey instead
        // This is visible on black and white, but disappears on a grey background
        canvasContext.globalCompositeOperation = 'difference';
        canvasContext[kind] = '#888';
        // For super dumb browsers (only support source-over), at least don't make the cursor invisible on a white BG!
        if (canvasContext.globalCompositeOperation != "difference") canvasContext[kind] = 'black';
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6V1eC":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPScrollbar);
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
function CPScrollbar(vertical) {
    let bar = document.createElement("div"), handle = document.createElement("div"), handleInner = document.createElement("div"), min = 0, max = 1, offset = 0, visibleRange = 1, blockIncrement = 10, unitIncrement = 1, valueIsAdjusting = false, handleSize = 1, dragging = false, dragLastOffset, that = this;
    function updateBar() {
        let longDimension = vertical ? bar.clientHeight : bar.clientWidth;
        /* As the size of the document approaches the size of the container, handle size grows to fill the 
             * whole track:
             */ handleSize = visibleRange / (max - min) * longDimension;
        let handleOffset = (offset - min) / (max - min) * (longDimension - handleSize);
        handleInner.style[vertical ? "height" : "width"] = handleSize + "px";
        handle.style[vertical ? "height" : "width"] = handleSize + "px";
        handle.style[vertical ? "top" : "left"] = handleOffset + "px";
    }
    this.setValues = function(_offset, _visibleRange, _min, _max) {
        offset = _offset;
        visibleRange = _visibleRange;
        min = _min;
        max = _max;
        updateBar();
    };
    this.setBlockIncrement = function(increment) {
        blockIncrement = increment;
    };
    this.setUnitIncrement = function(increment) {
        unitIncrement = increment;
    };
    this.getElement = function() {
        return bar;
    };
    this.getValueIsAdjusting = function() {
        return valueIsAdjusting;
    };
    function onBarClick(e) {
        if (this == bar) {
            let clickPos = vertical ? e.pageY - bar.offsetTop - window.scrollY : e.pageX - bar.offsetLeft - window.scrollX;
            let barPos = parseInt(handle.style[vertical ? "top" : "left"], 10);
            if (clickPos < barPos) offset -= blockIncrement;
            else offset += blockIncrement;
            that.emitEvent("valueChanged", [
                offset
            ]);
            updateBar();
        }
    }
    function onHandlePress(e) {
        e.stopPropagation();
        dragLastOffset = vertical ? e.pageY - bar.offsetTop - window.scrollY : e.pageX - bar.offsetLeft - window.scrollX;
        handle.setPointerCapture(e.pointerId);
        handle.classList.add("dragging");
        dragging = true;
    }
    function onHandleClick(e) {
        e.stopPropagation();
    }
    function onHandleDrag(e) {
        if (dragging) {
            valueIsAdjusting = true;
            const longDimension = vertical ? bar.clientHeight : bar.clientWidth;
            const mouseOffset = vertical ? e.pageY - bar.offsetTop - window.scrollY : e.pageX - bar.offsetLeft - window.scrollX;
            offset = offset + (mouseOffset - dragLastOffset) * (max - min) / (longDimension - handleSize);
            offset = Math.min(Math.max(offset, min), max);
            dragLastOffset = mouseOffset;
            that.emitEvent("valueChanged", [
                offset
            ]);
            updateBar();
            valueIsAdjusting = false;
        }
    }
    function onHandleRelease(e) {
        e.stopPropagation();
        if (dragging) {
            try {
                handle.releasePointerCapture(e.pointerId);
            } catch (e) {}
            handle.classList.remove("dragging");
            dragging = false;
        }
    }
    bar.className = "chickenpaint-scrollbar " + (vertical ? "chickenpaint-scrollbar-vertical" : "chickenpaint-scrollbar-horizontal");
    handle.className = "chickenpaint-scrollbar-handle";
    handle.setAttribute("touch-action", "none");
    handleInner.className = "chickenpaint-scrollbar-handle-inner";
    handle.appendChild(handleInner);
    bar.appendChild(handle);
    handle.addEventListener("pointerdown", onHandlePress);
    handle.addEventListener("pointermove", onHandleDrag);
    handle.addEventListener("pointerup", onHandleRelease);
    handle.addEventListener("click", onHandleClick);
    bar.addEventListener("click", onBarClick);
}
CPScrollbar.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
CPScrollbar.prototype.constructor = CPScrollbar;

},{"wolfy87-eventemitter":"gPUo0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3jeYk":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPPaletteManager);
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
var _cptoolPaletteJs = require("./CPToolPalette.js");
var _cptoolPaletteJsDefault = parcelHelpers.interopDefault(_cptoolPaletteJs);
var _cpmiscPaletteJs = require("./CPMiscPalette.js");
var _cpmiscPaletteJsDefault = parcelHelpers.interopDefault(_cpmiscPaletteJs);
var _cpstrokePaletteJs = require("./CPStrokePalette.js");
var _cpstrokePaletteJsDefault = parcelHelpers.interopDefault(_cpstrokePaletteJs);
var _cpcolorPaletteJs = require("./CPColorPalette.js");
var _cpcolorPaletteJsDefault = parcelHelpers.interopDefault(_cpcolorPaletteJs);
var _cpbrushPaletteJs = require("./CPBrushPalette.js");
var _cpbrushPaletteJsDefault = parcelHelpers.interopDefault(_cpbrushPaletteJs);
var _cplayersPaletteJs = require("./CPLayersPalette.js");
var _cplayersPaletteJsDefault = parcelHelpers.interopDefault(_cplayersPaletteJs);
var _cptexturePaletteJs = require("./CPTexturePalette.js");
var _cptexturePaletteJsDefault = parcelHelpers.interopDefault(_cptexturePaletteJs);
var _cpswatchesPaletteJs = require("./CPSwatchesPalette.js");
var _cpswatchesPaletteJsDefault = parcelHelpers.interopDefault(_cpswatchesPaletteJs);
function CPPaletteManager(cpController) {
    const palettes = {
        tool: new (0, _cptoolPaletteJsDefault.default)(cpController),
        misc: new (0, _cpmiscPaletteJsDefault.default)(cpController),
        stroke: new (0, _cpstrokePaletteJsDefault.default)(cpController),
        color: new (0, _cpcolorPaletteJsDefault.default)(cpController),
        brush: new (0, _cpbrushPaletteJsDefault.default)(cpController),
        layers: new (0, _cplayersPaletteJsDefault.default)(cpController),
        textures: new (0, _cptexturePaletteJsDefault.default)(cpController),
        swatches: new (0, _cpswatchesPaletteJsDefault.default)(cpController)
    }, defaultCollapse = {
        tool: false,
        color: false,
        misc: false
    }, collapseDownwards = {
        color: true,
        textures: true,
        layers: true
    }, parentElem = document.createElement("div"), that = this;
    let paletteFrames = [], hiddenFrames = [];
    this.palettes = palettes;
    function getPaletteDisplayArea() {
        // Use the canvas as a positioning guide to avoid overlapping scrollbars
        let canvas = parentElem.closest(".chickenpaint").querySelector(".chickenpaint-canvas");
        return {
            width: canvas.offsetWidth,
            height: canvas.offsetHeight
        };
    }
    function showPalette(palette, show) {
        let palElement = palette.getElement();
        if (show) {
            if (!parentElem.contains(palElement)) parentElem.appendChild(palElement);
        } else if (parentElem.contains(palElement)) parentElem.removeChild(palElement);
        that.emitEvent("paletteVisChange", [
            palette.name,
            show
        ]);
    // FIXME: focus hack
    // controller.canvas.grabFocus(); TODO
    }
    this.showPaletteByName = function(paletteName, show) {
        let palette = palettes[paletteName];
        if (palette) showPalette(palette, show);
    };
    this.togglePalettes = function() {
        if (hiddenFrames.length === 0) {
            let palettes = parentElem.querySelectorAll(".chickenpaint-palette");
            palettes.forEach(function(palette) {
                that.showPaletteByName(palette.getAttribute("data-paletteName"), false);
                hiddenFrames.push(palette);
            });
        } else {
            for(let i = 0; i < hiddenFrames.length; i++){
                let frame = hiddenFrames[i];
                that.showPaletteByName(frame.getAttribute("data-paletteName"), true);
            }
            hiddenFrames = [];
        }
    };
    /**
     * Pop palettes that are currently outside the visible area back into view.
     */ this.constrainPalettes = function() {
        let windowDim = getPaletteDisplayArea();
        for(let i in palettes){
            let palette = palettes[i];
            /* Move palettes that are more than half out of the frame back into it */ if (palette.getX() + palette.getWidth() / 2 > windowDim.width) palette.setLocation(windowDim.width - palette.getWidth(), palette.getY());
            if (palette.getY() + palette.getHeight() / 2 > windowDim.height) palette.setLocation(palette.getX(), windowDim.height - palette.getHeight());
        }
        //Move small palettes to the front so that they aren't completely hidden
        //palettes.swatches.moveToFront();
        //Special handling for the swatches palette being under the brush palette:
        let widthToSpare = windowDim.width - palettes.tool.getWidth() - palettes.misc.getWidth() - palettes.stroke.getWidth() - palettes.color.getWidth() - palettes.brush.getWidth() - 15 > 0;
        if (palettes.swatches.getX() + palettes.swatches.getWidth() == palettes.brush.getX() + palettes.brush.getWidth() && Math.abs(palettes.swatches.getY() - palettes.brush.getY()) < 20) palettes.swatches.setLocation(palettes.brush.getX() - palettes.swatches.getWidth() - (widthToSpare ? 5 : 1), 0);
        //Special handling for layers palette being too damn tall:
        if (palettes.layers.getY() + palettes.layers.getHeight() > windowDim.height) palettes.layers.setHeight(Math.max(windowDim.height - palettes.layers.getY(), 200));
    };
    /**
     * Rearrange the palettes from scratch into a useful arrangement.
     */ this.arrangePalettes = function() {
        let windowDim = getPaletteDisplayArea(), haveWidthToSpare;
        if (cpController.getSmallScreenMode()) {
            palettes.tool.setLocation(0, 0);
            palettes.misc.setLocation(palettes.tool.getX() + palettes.tool.getWidth() + 1, 0);
            const BrushLocationY = windowDim.width - (palettes.tool.getWidth() + palettes.misc.getWidth() + palettes.brush.getWidth()) <= 16 ? palettes.misc.getY() + palettes.misc.getHeight() + 1 : 0;
            palettes.brush.setLocation(windowDim.width - palettes.brush.getWidth() - 15, BrushLocationY);
            // palettes.brush.setLocation(windowDim.width - palettes.brush.getWidth() - 15, palettes.misc.getY() + palettes.misc.getHeight() + 1);
            let layersY = 330;
            palettes.textures.setWidth(windowDim.width - palettes.textures.getX());
            palettes.layers.setLocation(palettes.brush.getX() + palettes.brush.getWidth() - palettes.layers.getWidth(), palettes.textures.getY() - palettes.layers.getHeight());
            const layerPaletteHeight = Math.max(palettes.textures.getY() - layersY - 1, 370);
            palettes.layers.setHeight(layerPaletteHeight);
            // palettes.layers.setHeight(palettes.textures.getY() - layersY - 1);
            palettes.layers.setWidth(218);
            palettes.stroke.setLocation(palettes.misc.getX(), palettes.misc.getY() + palettes.misc.getHeight() + 1);
            palettes.swatches.setLocation(palettes.stroke.getX(), palettes.stroke.getY() + palettes.stroke.getHeight() + 1);
        } else {
            haveWidthToSpare = windowDim.width - palettes.tool.getWidth() - palettes.misc.getWidth() - palettes.stroke.getWidth() - palettes.color.getWidth() - palettes.brush.getWidth() - 15 > 0;
            palettes.brush.setLocation(windowDim.width - palettes.brush.getWidth() - 15, 0);
            let bottomOfBrush = palettes.brush.getY() + palettes.brush.getHeight(), layersY = windowDim.height - bottomOfBrush > 300 ? bottomOfBrush + 2 : bottomOfBrush;
            palettes.layers.setSize(palettes.brush.getWidth() + (haveWidthToSpare ? 30 : 0), windowDim.height - layersY);
            palettes.layers.setLocation(palettes.brush.getX() + palettes.brush.getWidth() - palettes.layers.getWidth(), layersY);
            palettes.tool.setLocation(0, 0);
            palettes.misc.setLocation(palettes.tool.getX() + palettes.tool.getWidth() + (haveWidthToSpare ? 5 : 1), 0);
            if (haveWidthToSpare) palettes.stroke.setLocation(palettes.misc.getX() + palettes.misc.getWidth() + (haveWidthToSpare ? 5 : 1), 0);
            else palettes.stroke.setLocation(palettes.misc.getX(), palettes.misc.getY() + palettes.misc.getHeight() + 1);
            palettes.swatches.setLocation(Math.max(palettes.brush.getX() - palettes.swatches.getWidth() - (haveWidthToSpare ? 5 : 1), palettes.tool.getX() + palettes.tool.getWidth()), 0);
            palettes.textures.setWidth(Math.min(palettes.layers.getX() - palettes.textures.getX(), 490));
        }
        palettes.textures.setLocation(palettes.color.getX() + palettes.color.getWidth() + 4, windowDim.height - palettes.textures.getHeight());
        palettes.color.setLocation(0, Math.max(palettes.tool.getY() + palettes.tool.getHeight(), windowDim.height - palettes.color.getHeight()));
    };
    cpController.on("smallScreen", function(smallScreenMode) {
        if (smallScreenMode) for(let paletteName in palettes){
            let palette = palettes[paletteName];
            palette.toggleCollapse(smallScreenMode && (!(paletteName in defaultCollapse) || defaultCollapse[paletteName]));
        }
    });
    this.getElement = function() {
        return parentElem;
    };
    parentElem.className = "chickenpaint-palettes";
    for(let paletteName in palettes){
        let palette = palettes[paletteName], palElement = palette.getElement();
        palette.on("paletteVisChange", function() {
            showPalette(this, false);
        });
        if (paletteName in collapseDownwards) palette.setCollapseDownwards(true);
        palElement.setAttribute("data-paletteName", paletteName);
        paletteFrames.push(palElement);
    }
    for(let paletteName in palettes){
        let palElement = palettes[paletteName].getElement();
        parentElem.appendChild(palElement);
    }
}
CPPaletteManager.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
CPPaletteManager.prototype.constructor = CPPaletteManager;

},{"wolfy87-eventemitter":"gPUo0","./CPToolPalette.js":"6znbc","./CPMiscPalette.js":"lFdG8","./CPStrokePalette.js":"iPT41","./CPColorPalette.js":"9ivoS","./CPBrushPalette.js":"km3rc","./CPLayersPalette.js":"dMvva","./CPTexturePalette.js":"dIkNA","./CPSwatchesPalette.js":"hnCVa","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6znbc":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPToolPalette);
var _keymasterJs = require("../../lib/keymaster.js");
var _keymasterJsDefault = parcelHelpers.interopDefault(_keymasterJs);
var _cppaletteJs = require("./CPPalette.js");
var _cppaletteJsDefault = parcelHelpers.interopDefault(_cppaletteJs);
var _chickenPaintJs = require("../ChickenPaint.js");
var _chickenPaintJsDefault = parcelHelpers.interopDefault(_chickenPaintJs);
var _langJs = require("../languages/lang.js");
function CPToolPalette(cpController) {
    (0, _cppaletteJsDefault.default).call(this, cpController, "tool", "Tools");
    let that = this, buttons = [
        {
            className: "chickenpaint-tool-rect-selection",
            command: "CPRectSelection",
            toolTip: "Marquee",
            shortcut: "m",
            mode: (0, _chickenPaintJsDefault.default).M_RECT_SELECTION
        },
        {
            className: "chickenpaint-tool-move",
            command: "CPMoveTool",
            toolTip: "Move tool",
            shortcut: "v",
            mode: (0, _chickenPaintJsDefault.default).M_MOVE_TOOL
        },
        {
            className: "chickenpaint-tool-flood-fill",
            command: "CPFloodFill",
            toolTip: "Flood fill",
            shortcut: "f",
            mode: (0, _chickenPaintJsDefault.default).M_FLOODFILL
        },
        {
            className: "chickenpaint-tool-gradient-fill",
            command: "CPGradientFill",
            toolTip: "Gradient fill",
            shortcut: "g",
            mode: (0, _chickenPaintJsDefault.default).M_GRADIENTFILL
        },
        {
            className: "chickenpaint-tool-color-picker",
            command: "CPColorPicker",
            toolTip: "Color picker",
            shortcut: "i",
            mode: (0, _chickenPaintJsDefault.default).M_COLOR_PICKER
        },
        {
            className: "chickenpaint-tool-blur",
            command: "CPBlur",
            toolTip: "Blur",
            shortcut: "u",
            mode: (0, _chickenPaintJsDefault.default).M_DRAW,
            tool: (0, _chickenPaintJsDefault.default).T_BLUR
        },
        {
            className: "chickenpaint-tool-pencil",
            command: "CPPencil",
            toolTip: "Pencil",
            shortcut: "n",
            mode: (0, _chickenPaintJsDefault.default).M_DRAW,
            tool: (0, _chickenPaintJsDefault.default).T_PENCIL
        },
        {
            className: "chickenpaint-tool-pen",
            command: "CPPen",
            toolTip: "Pen",
            selected: true,
            shortcut: "b",
            mode: (0, _chickenPaintJsDefault.default).M_DRAW,
            tool: (0, _chickenPaintJsDefault.default).T_PEN
        },
        {
            className: "chickenpaint-tool-airbrush",
            command: "CPAirbrush",
            toolTip: "Airbrush",
            shortcut: "a",
            mode: (0, _chickenPaintJsDefault.default).M_DRAW,
            tool: (0, _chickenPaintJsDefault.default).T_AIRBRUSH
        },
        {
            className: "chickenpaint-tool-water",
            command: "CPWater",
            toolTip: "Waterpaint",
            shortcut: "w",
            mode: (0, _chickenPaintJsDefault.default).M_DRAW,
            tool: (0, _chickenPaintJsDefault.default).T_WATER
        },
        {
            className: "chickenpaint-tool-eraser",
            command: "CPEraser",
            toolTip: "Eraser",
            shortcut: "e",
            mode: (0, _chickenPaintJsDefault.default).M_DRAW,
            tool: (0, _chickenPaintJsDefault.default).T_ERASER
        },
        {
            className: "chickenpaint-tool-soft-eraser",
            command: "CPSoftEraser",
            toolTip: "Soft eraser",
            shortcut: "s",
            mode: (0, _chickenPaintJsDefault.default).M_DRAW,
            tool: (0, _chickenPaintJsDefault.default).T_SOFTERASER
        },
        {
            className: "chickenpaint-tool-smudge",
            command: "CPSmudge",
            toolTip: "Smudge",
            shortcut: "d",
            mode: (0, _chickenPaintJsDefault.default).M_DRAW,
            tool: (0, _chickenPaintJsDefault.default).T_SMUDGE
        },
        {
            className: "chickenpaint-tool-blender",
            command: "CPBlender",
            toolTip: "Blender",
            shortcut: "c",
            mode: (0, _chickenPaintJsDefault.default).M_DRAW,
            tool: (0, _chickenPaintJsDefault.default).T_BLENDER
        },
        {
            className: "chickenpaint-tool-dodge",
            command: "CPDodge",
            toolTip: "Dodge (tool)",
            shortcut: "o",
            mode: (0, _chickenPaintJsDefault.default).M_DRAW,
            tool: (0, _chickenPaintJsDefault.default).T_DODGE
        },
        {
            className: "chickenpaint-tool-burn",
            command: "CPBurn",
            toolTip: "Burn (tool)",
            shortcut: "p",
            mode: (0, _chickenPaintJsDefault.default).M_DRAW,
            tool: (0, _chickenPaintJsDefault.default).T_BURN
        },
        {
            className: "chickenpaint-tool-rotate-canvas",
            command: "CPRotateCanvas",
            commandDoubleClick: "CPResetCanvasRotation",
            toolTip: "Rotate canvas",
            mode: (0, _chickenPaintJsDefault.default).M_ROTATE_CANVAS
        },
        {
            className: "chickenpaint-tool-pan-canvas",
            command: "CPPanCanvas",
            toolTip: "Grab canvas",
            mode: (0, _chickenPaintJsDefault.default).M_PAN_CANVAS
        }
    ], listElem = document.createElement("ul");
    function buttonClicked(e) {
        if (this.nodeName == "LI") {
            let button = buttons[parseInt(this.getAttribute("data-buttonIndex"), 10)];
            cpController.actionPerformed({
                action: button.command
            });
        // that.userIsDoneWithUs();
        //ボタンクリック時にパレットを折りたたむ機能を削除
        }
    }
    function buildButtons() {
        let body = that.getBodyElement();
        listElem.className = "chickenpaint-tools list-unstyled";
        for(let i in buttons)(function(i) {
            let button = buttons[i], buttonElem = document.createElement("li"), buttonIcon = document.createElement("div");
            buttonElem.className = "chickenpaint-toolbar-button " + button.className;
            buttonElem.setAttribute("data-buttonIndex", i);
            buttonElem.setAttribute('data-mode', button.mode);
            if (button.tool !== undefined) buttonElem.setAttribute('data-tool', button.tool);
            buttonElem.title = (0, _langJs._)(button.toolTip);
            if (button.shortcut) {
                buttonElem.title += " (" + button.shortcut.toUpperCase() + ")";
                (0, _keymasterJsDefault.default)(button.shortcut, function() {
                    buttonClicked.call(buttonElem);
                    return false;
                });
            }
            if (button.selected) buttonElem.className = buttonElem.className + " selected";
            buttonIcon.className = "chickenpaint-toolbar-button-icon";
            buttonElem.appendChild(buttonIcon);
            listElem.appendChild(buttonElem);
        })(i);
        listElem.addEventListener("click", function(e) {
            const liElem = e.target.closest("li"); // クリックされた要素が li の場合、それを取得
            if (liElem) buttonClicked.call(liElem, e); // クリックされた li 要素を引数に渡す
        });
        listElem.addEventListener("dblclick", function(e) {
            const liElem = e.target.closest("li");
            if (liElem) {
                let buttonIndex = parseInt(liElem.getAttribute("data-buttonIndex"), 10);
                let button = buttons[buttonIndex];
                // クリックされた時に処理を実行
                if (button.commandDoubleClick) cpController.actionPerformed({
                    action: button.commandDoubleClick
                });
            }
        });
        body.appendChild(listElem);
    }
    cpController.on("modeChange", function(newMode) {
        let body = that.getBodyElement();
        // 'selected' クラスを全ての <li> から削除
        const liElems = body.querySelectorAll("li");
        liElems.forEach(function(liElem) {
            liElem.classList.remove("selected");
        });
        // モードに応じて 'selected' クラスを追加
        if (newMode == (0, _chickenPaintJsDefault.default).M_DRAW) {
            const toolElem = body.querySelector(`li[data-tool="${cpController.getCurTool()}"]`);
            if (toolElem) toolElem.classList.add("selected");
        } else {
            const modeElem = body.querySelector(`li[data-mode="${newMode}"]`);
            if (modeElem) modeElem.classList.add("selected");
        }
    });
    cpController.on("toolChange", function(newTool) {
        let body = that.getBodyElement();
        if (cpController.getCurMode() == (0, _chickenPaintJsDefault.default).M_DRAW) {
            // 'selected' クラスを全ての <li> から削除
            const liElems = body.querySelectorAll("li");
            liElems.forEach(function(liElem) {
                liElem.classList.remove("selected");
            });
            // 新しいツールに対応する <li> に 'selected' クラスを追加
            const toolElem = body.querySelector(`li[data-tool="${newTool}"]`);
            if (toolElem) toolElem.classList.add("selected");
        }
    });
    buildButtons();
}
CPToolPalette.prototype = Object.create((0, _cppaletteJsDefault.default).prototype);
CPToolPalette.prototype.constructor = CPToolPalette;

},{"../../lib/keymaster.js":"hFCDu","./CPPalette.js":"2mLTE","../ChickenPaint.js":"3lJkm","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2mLTE":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPPalette);
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
var _langJs = require("../languages/lang.js");
const DRAG_START_THRESHOLD = 5;
function distanceGreaterThan(a, b, threshold) {
    let dist = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
    return dist > threshold * threshold;
}
function CPPalette(cpController, className, title, options) {
    // Use a shorter version of the title if needed and one is available
    if (cpController.getSmallScreenMode() && (0, _langJs._)(title + " (shorter)") !== title + " (shorter)") this.title = (0, _langJs._)(title + " (shorter)");
    else this.title = (0, _langJs._)(title);
    options = options || {};
    this.name = className;
    this.resizeVert = options.resizeVert || false;
    this.resizeHorz = options.resizeHorz || false;
    let containerElement = document.createElement("div"), headElement = document.createElement("div"), collapseIcon = document.createElement("i"), closeButton = document.createElement("button"), bodyElement = document.createElement("div"), vertHandle = null, horzHandle = null, dragStartPos, dragAction, dragOffset, that = this;
    this.getElement = function() {
        return containerElement;
    };
    this.getBodyElement = function() {
        return bodyElement;
    };
    this.getWidth = function() {
        return containerElement.offsetWidth;
    };
    this.getHeight = function() {
        return containerElement.offsetHeight;
    };
    this.getX = function() {
        return parseInt(containerElement.style.left, 10) || 0;
    };
    this.getY = function() {
        return parseInt(containerElement.style.top, 10) || 0;
    };
    this.setLocation = function(x, y) {
        containerElement.style.left = x + "px";
        containerElement.style.top = y + "px";
    };
    this.setWidth = function(width) {
        containerElement.style.width = width + "px";
    };
    this.setHeight = function(height) {
        containerElement.style.height = height + "px";
    };
    this.setSize = function(width, height) {
        this.setWidth(width);
        this.setHeight(height);
    };
    this.setCollapseDownwards = function(collapseDownwards) {
        options.collapseDownwards = collapseDownwards;
    };
    /**
 * @param {boolean} [collapse] True to collapse, false to uncollapse, omit to toggle state
 */ this.toggleCollapse = function(collapse) {
        if (collapse === undefined) collapse = !containerElement.classList.contains("collapsed");
        else {
            if (containerElement.classList.contains("collapsed") === collapse) return;
        }
        let chickenpaintCanvas = containerElement.closest(".chickenpaint")?.querySelector(".chickenpaint-canvas"), windowHeight = chickenpaintCanvas ? chickenpaintCanvas.clientHeight : window.innerHeight, oldHeight = this.getHeight(), oldBottom = this.getY() + oldHeight;
        // collapseがtrueなら「collapsed」クラスが追加され、falseなら削除される
        containerElement.classList.toggle("collapsed", collapse);
        // angle-downアイコンの表示/非表示を切り替える
        collapseIcon.classList.toggle("icon-angle-down", !collapse);
        // angle-upアイコンの表示/非表示を切り替える
        collapseIcon.classList.toggle("icon-angle-up", collapse);
        if (collapse) // Move the header down to the old base position
        {
            if (options.collapseDownwards) this.setLocation(this.getX(), Math.min(oldBottom, windowHeight) - this.getHeight());
        } else {
            let thisHeight = this.getHeight();
            if (options.collapseDownwards) this.setLocation(this.getX(), Math.max(oldBottom - thisHeight, 0));
            else // Keep palettes inside the window when uncollapsing
            if (this.getY() + thisHeight > windowHeight) this.setLocation(this.getX(), Math.max(windowHeight - thisHeight, 0));
        }
    };
    this.userIsDoneWithUs = function() {
        if (cpController.getSmallScreenMode()) this.toggleCollapse(true);
    };
    function paletteHeaderPointerMove(e) {
        if ((dragAction === "dragStart" || dragAction === "dragging") && e.buttons !== 0) {
            let newX = e.pageX - dragOffset.x, newY = e.pageY - dragOffset.y;
            if (dragAction == "dragStart") {
                if (distanceGreaterThan({
                    x: newX,
                    y: newY
                }, dragStartPos, DRAG_START_THRESHOLD)) // Recognise this as a drag rather than a clink
                dragAction = "dragging";
            }
            if (dragAction == "dragging") that.setLocation(newX, newY);
        }
    }
    function paletteHeaderPointerDown(e) {
        if (e.button == 0) {
            /* Left */ e.stopPropagation();
            e.preventDefault(); // Avoid generating further legacy mouse events
            if (e.target.nodeName == "BUTTON") // Close button was clicked
            that.emitEvent("paletteVisChange", [
                that,
                false
            ]);
            else {
                dragStartPos = {
                    x: parseInt(containerElement.style.left, 10) || 0,
                    y: parseInt(containerElement.style.top, 10) || 0
                };
                dragOffset = {
                    x: e.pageX - containerElement.offsetLeft,
                    y: e.pageY - containerElement.offsetTop
                };
                if (cpController.getSmallScreenMode()) // Wait for the cursor to move a certain amount before we classify this as a drag
                dragAction = "dragStart";
                else dragAction = "dragging";
                e.target.setPointerCapture(e.pointerId);
            }
        }
    }
    function paletteHeaderPointerUp(e) {
        if (dragAction === "dragging" || dragAction === "dragStart") {
            if (dragAction === "dragStart") {
                // We clicked the header. Cancel the drag and toggle the palette instead
                e.stopPropagation();
                e.preventDefault();
                /* Don't move the dialog immediately, because otherwise a click event will be
                 * dispatched on the element which ends up under the cursor afterwards.
                 */ setTimeout(()=>{
                    that.setLocation(dragStartPos.x, dragStartPos.y);
                    that.toggleCollapse();
                }, 100);
            }
            dragAction = false;
            try {
                e.target.releasePointerCapture(e.pointerId);
            } catch (e) {
                // This can fail for a variety of reasons we don't care about and won't affect us
                console.error(e);
            }
        }
    }
    function vertHandlePointerMove(e) {
        if (dragAction == "vertResize") that.setHeight(e.pageY - containerElement.offsetTop);
    }
    function vertHandlePointerUp(e) {
        vertHandle.releasePointerCapture(e.pointerId);
        dragAction = false;
    }
    function vertHandlePointerDown(e) {
        dragAction = "vertResize";
        vertHandle.setPointerCapture(e.pointerId);
    }
    function addVertResizeHandle() {
        vertHandle = document.createElement("div");
        vertHandle.className = "chickenpaint-resize-handle-vert";
        vertHandle.addEventListener("pointerdown", vertHandlePointerDown);
        vertHandle.addEventListener("pointermove", vertHandlePointerMove);
        vertHandle.addEventListener("pointerup", vertHandlePointerUp);
        containerElement.appendChild(vertHandle);
    }
    function horzHandlePointerMove(e) {
        if (dragAction == "horzResize") that.setWidth(e.pageX - containerElement.offsetLeft);
    }
    function horzHandlePointerUp(e) {
        horzHandle.releasePointerCapture(e.pointerId);
        dragAction = false;
    }
    function horzHandlePointerDown(e) {
        dragAction = "horzResize";
        horzHandle.setPointerCapture(e.pointerId);
    }
    function addHorzResizeHandle() {
        horzHandle = document.createElement("div");
        horzHandle.className = "chickenpaint-resize-handle-horz";
        horzHandle.addEventListener("pointerdown", horzHandlePointerDown);
        horzHandle.addEventListener("pointermove", horzHandlePointerMove);
        horzHandle.addEventListener("pointerup", horzHandlePointerUp);
        containerElement.appendChild(horzHandle);
    }
    collapseIcon.className = "collapse-icon fas icon-angle-down";
    closeButton.type = "button";
    closeButton.className = "btn btn-close";
    closeButton.textContent = "";
    closeButton.tabIndex = -1;
    containerElement.className = "chickenpaint-palette chickenpaint-palette-" + className;
    headElement.className = "chickenpaint-palette-head";
    headElement.setAttribute("touch-action", "none");
    let titleContainer = document.createElement("div"), titleElem = document.createElement("h5");
    titleContainer.className = "modal-header";
    titleElem.className = "modal-title";
    titleElem.appendChild(document.createTextNode(this.title));
    titleElem.appendChild(collapseIcon);
    titleContainer.appendChild(titleElem);
    titleContainer.appendChild(closeButton);
    headElement.appendChild(titleContainer);
    bodyElement.className = "chickenpaint-palette-body";
    containerElement.appendChild(headElement);
    containerElement.appendChild(bodyElement);
    if (this.resizeVert) addVertResizeHandle();
    if (this.resizeHorz) addHorzResizeHandle();
    headElement.addEventListener("pointerdown", paletteHeaderPointerDown);
    headElement.addEventListener("pointermove", paletteHeaderPointerMove);
    headElement.addEventListener("pointerup", paletteHeaderPointerUp);
}
CPPalette.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
CPPalette.prototype.constructor = (0, _wolfy87EventemitterDefault.default);

},{"wolfy87-eventemitter":"gPUo0","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lFdG8":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPMiscPalette);
var _cppaletteJs = require("./CPPalette.js");
var _cppaletteJsDefault = parcelHelpers.interopDefault(_cppaletteJs);
var _langJs = require("../languages/lang.js");
function CPMiscPalette(cpController) {
    (0, _cppaletteJsDefault.default).call(this, cpController, "misc", "Misc");
    /** @type {HTMLElement|null} */ //表示の左右反転時に赤枠を付けるElement
    this.flipButton = null;
    let that = this, buttons = [
        {
            className: "chickenpaint-tool-zoom-in",
            command: "CPZoomIn",
            toolTip: "Zoom in"
        },
        {
            className: "chickenpaint-tool-zoom-out",
            command: "CPZoomOut",
            toolTip: "Zoom out"
        },
        {
            className: "chickenpaint-tool-zoom-100",
            command: "CPZoom100",
            toolTip: "Zoom 100%"
        },
        {
            className: "chickenpaint-tool-flip-horizontal",
            command: "CPViewHFlip",
            toolTip: "Flip View Horizontal"
        },
        {
            className: "chickenpaint-tool-undo",
            command: "CPUndo",
            toolTip: "Undo"
        },
        {
            className: "chickenpaint-tool-redo",
            command: "CPRedo",
            toolTip: "Redo"
        },
        {
            className: "chickenpaint-tool-send",
            command: "CPSend",
            toolTip: "Save Oekaki"
        }
    ];
    function buildButtons() {
        let body = that.getBodyElement(), listElem = document.createElement("ul");
        listElem.className = "chickenpaint-misc-tools list-unstyled";
        for(let i in buttons){
            let button = buttons[i], buttonElem = document.createElement("li"), buttonIcon = document.createElement("div");
            if (button.command == "CPSend" && !cpController.isActionSupported("CPContinue")) {
                button.toolTip = "Post Oekaki";
                button.className = "chickenpaint-tool-send-and-end";
            }
            buttonElem.className = "chickenpaint-toolbar-button " + button.className;
            buttonElem.setAttribute("data-buttonIndex", i);
            buttonElem.setAttribute("title", (0, _langJs._)(button.toolTip));
            buttonIcon.className = "chickenpaint-toolbar-button-icon";
            buttonElem.appendChild(buttonIcon);
            listElem.appendChild(buttonElem);
            // 「左右反転ボタン」の要素を保存する
            if (button.className === "chickenpaint-tool-flip-horizontal") that.flipButton = buttonElem;
        }
        listElem.addEventListener("click", function(e) {
            // クリックされた要素が <li> 内の何らかの要素の場合、親の <li> を取得
            const liElem = e.target.closest("li");
            // 親が <li> であれば処理を行う
            if (liElem) {
                let buttonIndex = parseInt(liElem.getAttribute("data-buttonIndex"), 10);
                let button = buttons[buttonIndex];
                // アクションを実行
                cpController.actionPerformed({
                    action: button.command
                });
            }
        });
        body.appendChild(listElem);
    }
    buildButtons();
}
CPMiscPalette.prototype = Object.create((0, _cppaletteJsDefault.default).prototype);
CPMiscPalette.prototype.constructor = CPMiscPalette;

},{"./CPPalette.js":"2mLTE","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iPT41":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPStrokePalette);
var _cppaletteJs = require("./CPPalette.js");
var _cppaletteJsDefault = parcelHelpers.interopDefault(_cppaletteJs);
var _cpbrushInfoJs = require("../engine/CPBrushInfo.js");
var _cpbrushInfoJsDefault = parcelHelpers.interopDefault(_cpbrushInfoJs);
var _langJs = require("../languages/lang.js");
function CPStrokePalette(cpController) {
    (0, _cppaletteJsDefault.default).call(this, cpController, "stroke", "Stroke");
    let that = this, buttons = [
        {
            className: "chickenpaint-tool-freehand",
            command: "CPFreeHand",
            toolTip: (0, _langJs._)("Free-hand"),
            selected: true
        },
        {
            className: "chickenpaint-tool-line",
            command: "CPLine",
            toolTip: (0, _langJs._)("Straight line")
        },
        {
            className: "chickenpaint-tool-bezier",
            command: "CPBezier",
            toolTip: (0, _langJs._)("Bezier curve")
        }
    ], body = that.getBodyElement();
    function buildButtons() {
        let listElem = document.createElement("ul");
        listElem.className = "chickenpaint-stroke-tools list-unstyled";
        for(let i in buttons){
            let button = buttons[i], buttonElem = document.createElement("li"), buttonIcon = document.createElement("div");
            buttonElem.className = "chickenpaint-toolbar-button " + button.className;
            buttonElem.setAttribute("data-buttonIndex", i);
            buttonElem.setAttribute("title", button.toolTip);
            if (button.selected) buttonElem.className = buttonElem.className + " selected";
            buttonIcon.className = "chickenpaint-toolbar-button-icon";
            buttonElem.appendChild(buttonIcon);
            listElem.appendChild(buttonElem);
        }
        listElem.addEventListener("click", function(e) {
            // クリックされた要素が <li> 内の何らかの要素の場合、親の <li> を取得
            const liElem = e.target.closest("li");
            // 親が <li> であれば処理を行う
            if (liElem) {
                let buttonIndex = parseInt(liElem.getAttribute("data-buttonIndex"), 10);
                let button = buttons[buttonIndex];
                // アクションを実行
                cpController.actionPerformed({
                    action: button.command
                });
            }
        });
        body.appendChild(listElem);
    }
    buildButtons();
    cpController.on("toolChange", function(tool, toolInfo) {
        const freehandElem = document.querySelector(".chickenpaint-tool-freehand");
        const lineElem = document.querySelector(".chickenpaint-tool-line");
        const bezierElem = document.querySelector(".chickenpaint-tool-bezier");
        if (freehandElem) freehandElem.classList.toggle("selected", toolInfo.strokeMode == (0, _cpbrushInfoJsDefault.default).STROKE_MODE_FREEHAND);
        if (lineElem) lineElem.classList.toggle("selected", toolInfo.strokeMode == (0, _cpbrushInfoJsDefault.default).STROKE_MODE_LINE);
        if (bezierElem) bezierElem.classList.toggle("selected", toolInfo.strokeMode == (0, _cpbrushInfoJsDefault.default).STROKE_MODE_BEZIER);
    });
}
CPStrokePalette.prototype = Object.create((0, _cppaletteJsDefault.default).prototype);
CPStrokePalette.prototype.constructor = CPStrokePalette;

},{"./CPPalette.js":"2mLTE","../engine/CPBrushInfo.js":"b7K5Z","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9ivoS":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPColorPalette);
var _cppaletteJs = require("./CPPalette.js");
var _cppaletteJsDefault = parcelHelpers.interopDefault(_cppaletteJs);
var _cpcolorSelectJs = require("./CPColorSelect.js");
var _cpcolorSelectJsDefault = parcelHelpers.interopDefault(_cpcolorSelectJs);
var _cpcolorSliderJs = require("./CPColorSlider.js");
var _cpcolorSliderJsDefault = parcelHelpers.interopDefault(_cpcolorSliderJs);
var _cpcolorJs = require("../util/CPColor.js");
var _cpcolorJsDefault = parcelHelpers.interopDefault(_cpcolorJs);
var _langJs = require("../languages/lang.js");
function CPColorPalette(cpController) {
    (0, _cppaletteJsDefault.default).call(this, cpController, "color", "Color (picker)");
    let colorSelect = new (0, _cpcolorSelectJsDefault.default)(cpController), colorSlider = new (0, _cpcolorSliderJsDefault.default)(cpController, colorSelect), colorShow = new CPColorShow(cpController), body = this.getBodyElement(), topSection = document.createElement("div");
    topSection.className = 'chickenpaint-colorpicker-top';
    topSection.appendChild(colorSelect.getElement());
    topSection.appendChild(colorSlider.getElement());
    body.appendChild(topSection);
    body.appendChild(colorShow.getElement());
}
function CPColorShow(controller) {
    let color = 0, element = document.createElement("div");
    function padLeft(string, padding, len) {
        while(string.length < len)string = padding + string;
        return string;
    }
    function paint() {
        element.style.backgroundColor = "#" + padLeft(Number(color).toString(16), "0", 6);
    }
    function mouseClick(e) {
        e.preventDefault();
        let colHex = "#" + padLeft(Number(color).toString(16), "0", 6);
        colHex = window.prompt((0, _langJs._)("Please enter a color in hex format"), colHex);
        if (colHex != null) try {
            if (colHex.match(/^#/) || colHex.match(/^$/)) colHex = colHex.substring(1);
            let newColor = parseInt(colHex, 16);
            controller.setCurColor(new (0, _cpcolorJsDefault.default)(newColor));
        } catch (e) {}
    }
    this.getElement = function() {
        return element;
    };
    controller.on("colorChange", function(_color) {
        color = _color.getRgb();
        paint();
    });
    element.className = 'chickenpaint-colorpicker-show';
    element.addEventListener("click", mouseClick);
    paint();
}
CPColorPalette.prototype = Object.create((0, _cppaletteJsDefault.default).prototype);
CPColorPalette.prototype.constructor = CPColorPalette;

},{"./CPPalette.js":"2mLTE","./CPColorSelect.js":"dlCqQ","./CPColorSlider.js":"eC5nU","../util/CPColor.js":"ioCeM","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dlCqQ":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint

    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.

    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cpcolorJs = require("../util/CPColor.js");
var _cpcolorJsDefault = parcelHelpers.interopDefault(_cpcolorJs);
var _cpcolorBmpJs = require("../engine/CPColorBmp.js");
var _cpcolorBmpJsDefault = parcelHelpers.interopDefault(_cpcolorBmpJs);
var _cpguiutilsJs = require("./CPGUIUtils.js");
const CONTROL_WIDTH = 128, CONTROL_HEIGHT = 128, PIXEL_SCALE = window.devicePixelRatio || 1, CANVAS_WIDTH = Math.round(CONTROL_WIDTH * PIXEL_SCALE), CANVAS_HEIGHT = Math.round(CONTROL_HEIGHT * PIXEL_SCALE);
class CPColorSelect {
    _controller;
    _canvas;
    _canvasContext;
    _imageData;
    _bitmapInvalid = true;
    _capturedMouse = false;
    _greyscale = false;
    color = new (0, _cpcolorJsDefault.default)(0);
    constructor(controller, initialColor){
        this._controller = controller;
        let canvas = document.createElement("canvas");
        this._canvas = canvas;
        canvas.className = 'chickenpaint-colorpicker-select';
        canvas.setAttribute("touch-action", "none");
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        canvas.style.width = CONTROL_WIDTH + "px";
        canvas.style.height = CONTROL_HEIGHT + "px";
        this._canvasContext = canvas.getContext("2d");
        this._imageData = this._canvasContext.createImageData(CANVAS_WIDTH, CANVAS_HEIGHT);
        // Workaround for Chrome bug https://bugs.chromium.org/p/chromium/issues/detail?id=1350157:
        this._canvasContext.getImageData(0, 0, 1, 1);
        this._handleEndDrag = this._endDrag.bind(this);
        this._handleMousePickColor = this._mousePickColor.bind(this);
        canvas.addEventListener("pointerdown", (e)=>this._startDrag(e));
        if (initialColor) this.color.copyFrom(initialColor);
        controller.on("colorChange", (c)=>{
            this.color.copyFrom(c);
            this._bitmapInvalid = true;
            this.paint();
        });
        controller.on("colorModeChange", (newMode)=>{
            this._greyscale = newMode == "greyscale";
            this._bitmapInvalid = true;
            this.paint();
        });
        this.paint();
    }
    _makeBitmap() {
        if (!this._bitmapInvalid) return;
        let pixIndex = 0, data = this._imageData.data;
        if (this._greyscale) for(let y = 0; y < CANVAS_HEIGHT; y++){
            let col = 255 - Math.round(y / (CANVAS_HEIGHT - 1) * 255);
            for(let x = 0; x < CANVAS_WIDTH; x++){
                data[pixIndex + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET] = col;
                data[pixIndex + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET] = col;
                data[pixIndex + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET] = col;
                data[pixIndex + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET] = 0xFF;
                pixIndex += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL;
            }
        }
        else {
            let col = this.color.clone();
            for(let y = 0; y < CANVAS_HEIGHT; y++){
                col.setValue(255 - ~~(y / (CANVAS_HEIGHT - 1) * 255));
                for(let x = 0; x < CANVAS_WIDTH; x++){
                    col.setSaturation(Math.round(x / (CANVAS_WIDTH - 1) * 255));
                    data[pixIndex + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET] = col.rgb >> 16 & 0xFF;
                    data[pixIndex + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET] = col.rgb >> 8 & 0xFF;
                    data[pixIndex + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET] = col.rgb & 0xFF;
                    data[pixIndex + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET] = 0xFF;
                    pixIndex += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL;
                }
            }
        }
        this._bitmapInvalid = false;
    }
    paint() {
        this._makeBitmap();
        this._canvasContext.putImageData(this._imageData, 0, 0);
        let cursorX = this.color.getSaturation() / 255 * (CANVAS_WIDTH - 1), cursorY = (255 - this.color.getValue()) / 255 * (CANVAS_HEIGHT - 1);
        (0, _cpguiutilsJs.setContrastingDrawStyle)(this._canvasContext, "stroke");
        this._canvasContext.lineWidth = 1.5 * PIXEL_SCALE;
        this._canvasContext.beginPath();
        if (this._greyscale) {
            this._canvasContext.moveTo(0, cursorY);
            this._canvasContext.lineTo(CANVAS_WIDTH, cursorY);
        } else this._canvasContext.arc(cursorX, cursorY, 5 * PIXEL_SCALE, 0, Math.PI * 2);
        this._canvasContext.stroke();
        this._canvasContext.globalCompositeOperation = 'source-over';
    }
    _mousePickColor(e) {
        let rect = this._canvas.getBoundingClientRect();
        let x = e.pageX - window.scrollX - rect.left;
        let y = e.pageY - window.scrollY - rect.top;
        let value = Math.max(Math.min(255 - ~~(y * 255 / (CONTROL_HEIGHT - 1)), 255), 0);
        if (this._greyscale) this.color.setGreyscale(value);
        else {
            let sat = Math.max(Math.min(~~(x * 255 / (CONTROL_WIDTH - 1)), 255), 0);
            this.color.setHsv(this.color.getHue(), sat, value);
        }
        this.paint();
        this._controller.setCurColor(this.color);
    }
    _endDrag(e) {
        this._canvas.releasePointerCapture(e.pointerId);
        this._capturedMouse = false;
        this._canvas.removeEventListener("pointerup", this._handleEndDrag);
        this._canvas.removeEventListener("pointermove", this._handleMousePickColor);
    }
    _startDrag(e) {
        if (!this._capturedMouse) {
            this._capturedMouse = true;
            this._canvas.setPointerCapture(e.pointerId);
            this._canvas.addEventListener("pointerup", this._handleEndDrag);
            this._canvas.addEventListener("pointermove", this._handleMousePickColor);
        }
        this._handleMousePickColor(e);
    }
    setHue(hue) {
        if (this.color.getHue() != hue) {
            this.color.setHue(hue);
            this._controller.setCurColor(this.color);
        }
    }
    getElement() {
        return this._canvas;
    }
}
exports.default = CPColorSelect;

},{"../util/CPColor.js":"ioCeM","../engine/CPColorBmp.js":"5rykl","./CPGUIUtils.js":"9eZG7","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eC5nU":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint

    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.

    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cpcolorJs = require("../util/CPColor.js");
var _cpcolorJsDefault = parcelHelpers.interopDefault(_cpcolorJs);
var _cpcolorBmpJs = require("../engine/CPColorBmp.js");
var _cpcolorBmpJsDefault = parcelHelpers.interopDefault(_cpcolorBmpJs);
var _cpguiutilsJs = require("./CPGUIUtils.js");
const WIDTH = 24, HEIGHT = 128;
/**
 * @param {ImageData} imageData
 */ function makeSliderBitmap(imageData) {
    let color = new (0, _cpcolorJsDefault.default)(0x00FFFF), pixIndex = 0, data = imageData.data;
    for(let y = 0; y < imageData.height; y++){
        color.setHue(y * 359 / imageData.height);
        for(let x = 0; x < imageData.width; x++){
            data[pixIndex + (0, _cpcolorBmpJsDefault.default).RED_BYTE_OFFSET] = color.rgb >> 16 & 0xFF;
            data[pixIndex + (0, _cpcolorBmpJsDefault.default).GREEN_BYTE_OFFSET] = color.rgb >> 8 & 0xFF;
            data[pixIndex + (0, _cpcolorBmpJsDefault.default).BLUE_BYTE_OFFSET] = color.rgb & 0xFF;
            data[pixIndex + (0, _cpcolorBmpJsDefault.default).ALPHA_BYTE_OFFSET] = 0xFF;
            pixIndex += (0, _cpcolorBmpJsDefault.default).BYTES_PER_PIXEL;
        }
    }
}
class CPColorSlider {
    hue;
    selecter;
    _canvas;
    _canvasContext;
    _imageData;
    _capturedMouse = false;
    constructor(controller, selecter, initialHue){
        this.selecter = selecter;
        this.hue = initialHue || 0;
        let canvas = document.createElement("canvas");
        this._canvas = canvas;
        controller.on("colorChange", (color)=>{
            this.setHue(color.getHue());
        });
        controller.on("colorModeChange", (mode)=>{
            canvas.style.display = mode == "greyscale" ? "none" : "block";
        });
        canvas.setAttribute("touch-action", "none");
        canvas.addEventListener("pointerdown", (e)=>this._startDrag(e));
        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        canvas.className = 'chickenpaint-colorpicker-slider';
        this._canvasContext = canvas.getContext("2d");
        this._imageData = this._canvasContext.createImageData(WIDTH, HEIGHT);
        // Workaround for Chrome bug https://bugs.chromium.org/p/chromium/issues/detail?id=1350157:
        this._canvasContext.getImageData(0, 0, 1, 1);
        this._handleEndDrag = this._endDrag.bind(this);
        this._handleMousePickColor = this._mousePickColor.bind(this);
        makeSliderBitmap(this._imageData);
        this.paint();
    }
    paint() {
        this._canvasContext.putImageData(this._imageData, 0, 0);
        let y = this.hue * HEIGHT / 360;
        (0, _cpguiutilsJs.setContrastingDrawStyle)(this._canvasContext, "stroke");
        this._canvasContext.lineWidth = 1.5;
        this._canvasContext.beginPath();
        this._canvasContext.moveTo(0, y);
        this._canvasContext.lineTo(WIDTH, y);
        this._canvasContext.stroke();
        this._canvasContext.globalCompositeOperation = 'source-over';
    }
    _mousePickColor(e) {
        let rect = this._canvas.getBoundingClientRect(), y = e.pageY - rect.top, _hue = ~~(y * 360 / HEIGHT);
        this.hue = Math.max(0, Math.min(359, _hue));
        this.paint();
        if (this.selecter) this.selecter.setHue(this.hue);
    }
    _endDrag(e) {
        this._canvas.releasePointerCapture(e.pointerId);
        this._capturedMouse = false;
        this._canvas.removeEventListener("pointerup", this._handleEndDrag);
        this._canvas.removeEventListener("pointermove", this._handleMousePickColor);
    }
    _startDrag(e) {
        if (!this._capturedMouse) {
            this._capturedMouse = true;
            this._canvas.setPointerCapture(e.pointerId);
            this._canvas.addEventListener("pointerup", this._handleEndDrag);
            this._canvas.addEventListener("pointermove", this._handleMousePickColor);
        }
        this._handleMousePickColor(e);
    }
    getElement() {
        return this._canvas;
    }
    setHue(h) {
        this.hue = h;
        this.paint();
    }
}
exports.default = CPColorSlider;

},{"../util/CPColor.js":"ioCeM","../engine/CPColorBmp.js":"5rykl","./CPGUIUtils.js":"9eZG7","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"km3rc":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPBrushPalette);
var _chickenPaintJs = require("../ChickenPaint.js");
var _chickenPaintJsDefault = parcelHelpers.interopDefault(_chickenPaintJs);
var _cppaletteJs = require("./CPPalette.js");
var _cppaletteJsDefault = parcelHelpers.interopDefault(_cppaletteJs);
var _cpcheckboxJs = require("./CPCheckbox.js");
var _cpcheckboxJsDefault = parcelHelpers.interopDefault(_cpcheckboxJs);
var _cpcolorSwatchJs = require("./CPColorSwatch.js");
var _cpcolorSwatchJsDefault = parcelHelpers.interopDefault(_cpcolorSwatchJs);
var _cpsliderJs = require("./CPSlider.js");
var _cpsliderJsDefault = parcelHelpers.interopDefault(_cpsliderJs);
var _cpguiutilsJs = require("./CPGUIUtils.js");
var _cpcolorBmpJs = require("../engine/CPColorBmp.js");
var _cpcolorBmpJsDefault = parcelHelpers.interopDefault(_cpcolorBmpJs);
var _cpcolorJs = require("../util/CPColor.js");
var _cpcolorJsDefault = parcelHelpers.interopDefault(_cpcolorJs);
var _cppolyfillJs = require("../util/CPPolyfill.js");
var _keymasterJs = require("../../lib/keymaster.js");
var _keymasterJsDefault = parcelHelpers.interopDefault(_keymasterJs);
var _langJs = require("../languages/lang.js");
function sliderCheckboxGroup(checkbox, slider) {
    let group = document.createElement("div");
    group.className = "chickenpaint-checkbox-slider-group";
    group.appendChild(checkbox.getElement());
    group.appendChild(slider.getElement());
    return group;
}
function fillCombobox(combo, optionNames) {
    for(let key in optionNames)if (optionNames.hasOwnProperty(key)) {
        let option = document.createElement("option");
        option.appendChild(document.createTextNode((0, _langJs._)(optionNames[key])));
        option.value = key;
        combo.appendChild(option);
    }
}
function CPGradientPreview(controller) {
    let w = 150, h = 32, canvas = document.createElement("canvas"), canvasContext = canvas.getContext("2d"), checkerboard = (0, _cpguiutilsJs.createCheckerboardPattern)(canvasContext), image = new (0, _cpcolorBmpJsDefault.default)(w, h), imageCanvas = document.createElement("canvas"), imageCanvasContext = imageCanvas.getContext("2d"), gradient = controller.getCurGradient();
    function paint() {
        image.gradient(image.getBounds(), 0, 0, image.width, 0, gradient, true);
        imageCanvasContext.putImageData(image.imageData, 0, 0, 0, 0, w, h);
        canvasContext.fillRect(0, 0, canvas.width, canvas.height);
        canvasContext.drawImage(imageCanvas, 0, 0);
    }
    this.getElement = function() {
        return canvas;
    };
    controller.on("gradientChange", function(_gradient) {
        gradient = _gradient;
        paint();
    });
    canvas.width = imageCanvas.width = w;
    canvas.height = imageCanvas.height = h;
    canvas.className = "chickenpaint-gradient-preview";
    canvasContext.fillStyle = checkerboard;
    paint();
}
function CPBrushPalette(controller) {
    (0, _cppaletteJsDefault.default).call(this, controller, "brush", "Tool options");
    let brushPanel = new CPBrushPanel(controller), gradientPanel = new CPGradientPanel(controller), transformPanel = new CPTransformPanel(controller), selectPanel = new CPSelectionPanel(controller), panPanel = new CPPanPanel(controller), body = this.getBodyElement();
    //touchmoveイベントのデフォルトの動作をキャンセル
    body.addEventListener("touchmove", (e)=>{
        e.preventDefault(); // デフォルトの動作をキャンセル
    }, {
        passive: false
    });
    body.appendChild(brushPanel.getElement());
    body.appendChild(gradientPanel.getElement());
    body.appendChild(transformPanel.getElement());
    body.appendChild(selectPanel.getElement());
    body.appendChild(panPanel.getElement());
    function hideAllPanels() {
        brushPanel.getElement().style.display = "none";
        gradientPanel.getElement().style.display = "none";
        transformPanel.getElement().style.display = "none";
        selectPanel.getElement().style.display = "none";
        panPanel.getElement().style.display = "none";
    }
    let currentMode = null;
    function updatePanelByMode(mode) {
        hideAllPanels();
        const checkbox = selectPanel.getElement().querySelector(".form-check"); //
        if (checkbox) checkbox.style.display = "none"; // 非表示にする
        switch(mode){
            case (0, _chickenPaintJsDefault.default).M_GRADIENTFILL:
                gradientPanel.getElement().style.display = "block";
                break;
            case (0, _chickenPaintJsDefault.default).M_TRANSFORM:
                transformPanel.getElement().style.display = "block";
                break;
            case (0, _chickenPaintJsDefault.default).M_RECT_SELECTION:
                selectPanel.getElement().style.display = "block";
                if (checkbox instanceof HTMLElement) checkbox.style.display = ""; // 表示する
                break;
            case (0, _chickenPaintJsDefault.default).M_MOVE_TOOL:
                selectPanel.getElement().style.display = "block";
                break;
            case (0, _chickenPaintJsDefault.default).M_ROTATE_CANVAS:
            case (0, _chickenPaintJsDefault.default).M_PAN_CANVAS:
                panPanel.getElement().style.display = "block";
                break;
            default:
                brushPanel.getElement().style.display = "block";
                break;
        }
    }
    controller.on("modeChange", function(mode) {
        currentMode = mode;
        updatePanelByMode(mode);
    });
    document.addEventListener("keydown", (e)=>{
        if (e.key.toLocaleLowerCase() === "r" || !e.ctrlKey && e.key.toLocaleLowerCase() === "z" || e.key === " ") {
            hideAllPanels();
            panPanel.getElement().style.display = "block";
        }
    });
    document.addEventListener("keyup", (e)=>{
        if (e.key.toLocaleLowerCase() === "r" || e.key.toLocaleLowerCase() === "z" || e.key === " ") {
            hideAllPanels();
            updatePanelByMode(currentMode);
        }
    });
}
CPBrushPalette.prototype = Object.create((0, _cppaletteJsDefault.default).prototype);
CPBrushPalette.prototype.constructor = CPBrushPalette;
function CPBrushPanel(controller) {
    const TIP_NAMES = [
        "Round Pixelated",
        "Round Hard Edge",
        "Round Soft",
        "Square Pixelated",
        "Square Hard Edge"
    ], BRUSH_SIZES = [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        15,
        20,
        25,
        30,
        35,
        40,
        45,
        50,
        60,
        70,
        80,
        90,
        100,
        125,
        150,
        175,
        200
    ];
    let panel = document.createElement("div"), tipCombo = document.createElement("select"), alphaCB = new (0, _cpcheckboxJsDefault.default)(false, (0, _langJs._)("Control brush opacity with pen pressure")), alphaSlider = new (0, _cpsliderJsDefault.default)(1, 255), sizeCB = new (0, _cpcheckboxJsDefault.default)(true, (0, _langJs._)("Control brush size with pen pressure")), sizeSlider = new (0, _cpsliderJsDefault.default)(1, 200, false, true), scatteringCB = new (0, _cpcheckboxJsDefault.default)(false, (0, _langJs._)("Control brush scattering with pen pressure")), scatteringSlider = new (0, _cpsliderJsDefault.default)(0, 1000, false, true), resatSlider = new (0, _cpsliderJsDefault.default)(0, 100, false, true), bleedSlider = new (0, _cpsliderJsDefault.default)(0, 100, false, true), spacingSlider = new (0, _cpsliderJsDefault.default)(0, 100, false, true), smoothingSlider = new (0, _cpsliderJsDefault.default)(0, 100, false, true), brushPreview = new CPBrushPalette.CPBrushPreview(controller);
    function fillWithInitialValues() {
        alphaCB.setValue(controller.getBrushInfo().pressureAlpha);
        alphaSlider.setValue(controller.getAlpha());
        sizeCB.setValue(controller.getBrushInfo().pressureSize);
        sizeSlider.setValue(controller.getBrushSize());
        scatteringCB.setValue(controller.getBrushInfo().pressureScattering);
        scatteringSlider.setValue(~~(controller.getBrushInfo().scattering * 100));
        tipCombo.value = controller.getBrushInfo().tip;
        resatSlider.setValue(~~(controller.getBrushInfo().resat * 100));
        bleedSlider.setValue(~~(controller.getBrushInfo().bleed * 100));
        spacingSlider.setValue(~~(controller.getBrushInfo().spacing * 100));
        smoothingSlider.setValue(~~(controller.getBrushInfo().smoothing * 100));
    }
    this.getElement = function() {
        return panel;
    };
    alphaSlider.title = function(value) {
        return (0, _langJs._)("Opacity") + ": " + value;
    };
    alphaSlider.on("valueChange", function(value) {
        controller.setAlpha(value);
    });
    sizeSlider.title = function(value) {
        return (0, _langJs._)("Brush size") + ": " + value;
    };
    sizeSlider.on("valueChange", function(value) {
        controller.setBrushSize(value);
    });
    resatSlider.title = function(value) {
        return (0, _langJs._)("Color") + ": " + value + "%";
    };
    resatSlider.on("valueChange", function(value) {
        controller.getBrushInfo().resat = value / 100.0;
        controller.callToolListeners();
    });
    bleedSlider.title = function(value) {
        return (0, _langJs._)("Blend") + ": " + value + "%";
    };
    bleedSlider.on("valueChange", function(value) {
        controller.getBrushInfo().bleed = value / 100.0;
        controller.callToolListeners();
    });
    spacingSlider.title = function(value) {
        return (0, _langJs._)("Spacing") + ": " + value + "%";
    };
    spacingSlider.on("valueChange", function(value) {
        controller.getBrushInfo().spacing = value / 100.0;
        controller.callToolListeners();
    });
    scatteringSlider.title = function(value) {
        return (0, _langJs._)("Scattering") + ": " + value + "%";
    };
    scatteringSlider.on("valueChange", function(value) {
        controller.getBrushInfo().scattering = value / 100.0;
        controller.callToolListeners();
    });
    smoothingSlider.title = function(value) {
        return (0, _langJs._)("Smoothing") + ": " + value + "%";
    };
    smoothingSlider.on("valueChange", function(value) {
        controller.getBrushInfo().smoothing = value / 100.0;
        controller.callToolListeners();
    });
    scatteringCB.on("valueChange", function(state) {
        controller.getBrushInfo().pressureScattering = state;
        controller.callToolListeners();
    });
    alphaCB.on("valueChange", function(state) {
        controller.getBrushInfo().pressureAlpha = state;
        controller.callToolListeners();
    });
    sizeCB.on("valueChange", function(state) {
        controller.getBrushInfo().pressureSize = state;
        controller.callToolListeners();
    });
    tipCombo.addEventListener("change", function(e) {
        controller.getBrushInfo().tip = parseInt(tipCombo.value, 10);
        tipCombo.blur();
    });
    // tipCombo.onfocus = ()=>{//フォーカスを検出したら
    // 	document.activeElement.blur();//フォーカスを外す
    // 	// console.log(document.activeElement);
    // };
    tipCombo.className = "form-control form-control-sm";
    tipCombo.tabIndex = -1;
    fillCombobox(tipCombo, TIP_NAMES);
    panel.appendChild(tipCombo);
    panel.appendChild(brushPreview.getElement());
    panel.appendChild(sliderCheckboxGroup(sizeCB, sizeSlider));
    panel.appendChild(sliderCheckboxGroup(alphaCB, alphaSlider));
    panel.appendChild(resatSlider.getElement());
    panel.appendChild(bleedSlider.getElement());
    panel.appendChild(spacingSlider.getElement());
    panel.appendChild(sliderCheckboxGroup(scatteringCB, scatteringSlider));
    panel.appendChild(smoothingSlider.getElement());
    fillWithInitialValues();
    controller.on("toolChange", function(tool, toolInfo) {
        alphaSlider.setValue(toolInfo.alpha);
        sizeSlider.setValue(toolInfo.size);
        sizeCB.setValue(toolInfo.pressureSize);
        alphaCB.setValue(toolInfo.pressureAlpha);
        tipCombo.value = toolInfo.tip;
        scatteringCB.setValue(toolInfo.pressureScattering);
        if (~~(toolInfo.resat * 100.0) != resatSlider.value) resatSlider.setValue(~~(toolInfo.resat * 100.0));
        if (~~(toolInfo.bleed * 100.0) != bleedSlider.value) bleedSlider.setValue(~~(toolInfo.bleed * 100.0));
        if (~~(toolInfo.spacing * 100.0) != spacingSlider.value) spacingSlider.setValue(~~(toolInfo.spacing * 100.0));
        if (~~(toolInfo.scattering * 100.0) != scatteringSlider.value) scatteringSlider.setValue(~~(toolInfo.scattering * 100.0));
        if (~~(toolInfo.smoothing * 100.0) != smoothingSlider.value) smoothingSlider.setValue(~~(toolInfo.smoothing * 100.0));
    });
    (0, _keymasterJsDefault.default)("1,2,3,4,5,6,7,8,9,0", function(event, handler) {
        let shortcut = parseInt(handler.shortcut, 10);
        if (shortcut == 0) shortcut = 10;
        controller.setAlpha(Math.round(shortcut / 10 * 255));
    });
    (0, _keymasterJsDefault.default)("{,[", function() {
        let size = controller.getBrushSize();
        for(let i = BRUSH_SIZES.length - 1; i >= 0; i--)if (size > BRUSH_SIZES[i]) {
            controller.setBrushSize(BRUSH_SIZES[i]);
            break;
        }
    });
    (0, _keymasterJsDefault.default)("},]", function() {
        let size = controller.getBrushSize();
        for(let i = 0; i < BRUSH_SIZES.length; i++)if (size < BRUSH_SIZES[i]) {
            controller.setBrushSize(BRUSH_SIZES[i]);
            break;
        }
    });
}
CPBrushPalette.CPBrushPreview = function(controller) {
    let size = 16, canvas = document.createElement("canvas"), canvasContext = canvas.getContext("2d"), mouseCaptured = false;
    function paint() {
        canvasContext.clearRect(0, 0, canvas.width, canvas.height);
        canvasContext.beginPath();
        canvasContext.arc(canvas.width / 2, canvas.height / 2, size / 2 * window.devicePixelRatio, 0, Math.PI * 2);
        canvasContext.stroke();
    }
    function handlePointerDrag(e) {
        const rect = canvas.getBoundingClientRect();
        const pt = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
        const x = pt.x - canvas.clientWidth / 2;
        const y = pt.y - canvas.clientHeight / 2;
        const newSize = Math.round(Math.sqrt(x * x + y * y) * 2);
        let size = Math.max(1, Math.min(200, newSize));
        paint();
        controller.setBrushSize(size);
    }
    function handlePointerUp(e) {
        if (mouseCaptured) {
            mouseCaptured = false;
            document.removeEventListener("pointerup", handlePointerUp, {
                capture: false
            });
            document.removeEventListener("pointermove", handlePointerDrag, {
                capture: false
            });
        }
    }
    canvas.addEventListener("pointerdown", function(e) {
        if (!mouseCaptured) {
            mouseCaptured = true;
            document.addEventListener("pointerup", handlePointerUp, {
                passive: true,
                capture: false
            });
            document.addEventListener("pointermove", handlePointerDrag, {
                passive: true,
                capture: false
            });
            handlePointerDrag(e);
        }
    });
    this.getElement = function() {
        return canvas;
    };
    controller.on("toolChange", function(tool, toolInfo) {
        if (toolInfo.size != size) {
            size = toolInfo.size;
            paint();
        }
    });
    canvas.width = 64;
    canvas.height = 64;
    if (window.devicePixelRatio > 1) {
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.width = canvas.width * window.devicePixelRatio;
        canvas.height = canvas.height * window.devicePixelRatio;
    }
    canvas.className = "chickenpaint-brush-preview";
    canvasContext.strokeStyle = "black";
    canvasContext.lineWidth = 1.0 * window.devicePixelRatio;
    paint();
};
function CPGradientPanel(controller) {
    const gradientPanel = document.createElement("div"), gradientPreview = new CPGradientPreview(controller), gradientStartSwatch = new (0, _cpcolorSwatchJsDefault.default)(new (0, _cpcolorJsDefault.default)(controller.getCurGradient()[0] & 0xffffff), controller.getCurGradient()[0] >>> 24, gradientPanel), gradientEndSwatch = new (0, _cpcolorSwatchJsDefault.default)(new (0, _cpcolorJsDefault.default)(controller.getCurGradient()[1] & 0xffffff), controller.getCurGradient()[1] >>> 24, gradientPanel);
    function updateGradient() {
        const gradient = [
            gradientStartSwatch.getAlpha() << 24 | gradientStartSwatch.getColorRgb(),
            gradientEndSwatch.getAlpha() << 24 | gradientEndSwatch.getColorRgb()
        ];
        controller.setCurGradient(gradient);
    }
    this.getElement = function() {
        return gradientPanel;
    };
    gradientPanel.className = "chickenpaint-gradient-panel";
    gradientPanel.style.display = "none";
    gradientStartSwatch.on("colorChange", updateGradient);
    gradientStartSwatch.on("alphaChange", updateGradient);
    gradientEndSwatch.on("colorChange", updateGradient);
    gradientEndSwatch.on("alphaChange", updateGradient);
    let title, colorsGroup, colorGroup;
    title = document.createElement("p");
    title.textContent = (0, _langJs._)("Gradient");
    gradientPanel.appendChild(title);
    gradientPanel.appendChild(gradientPreview.getElement());
    colorsGroup = document.createElement("div");
    colorsGroup.className = "chickenpaint-gradient-colors";
    colorGroup = document.createElement("div");
    colorGroup.className = "chickenpaint-gradient-start-color";
    colorGroup.appendChild(gradientStartSwatch.getElement());
    colorsGroup.appendChild(colorGroup);
    colorGroup = document.createElement("div");
    colorGroup.className = "chickenpaint-gradient-end-color";
    colorGroup.appendChild(gradientEndSwatch.getElement());
    colorsGroup.appendChild(colorGroup);
    gradientPanel.appendChild(colorsGroup);
}
function CPTransformPanel(controller) {
    const TRANSFORM_INTERPOLATION = {
        smooth: (0, _langJs._)("Smooth"),
        sharp: (0, _langJs._)("Sharp")
    };
    let panel = document.createElement("div"), acceptButton = document.createElement("button"), rejectButton = document.createElement("button"), interpCombo = document.createElement("select");
    this.getElement = function() {
        return panel;
    };
    panel.className = "chickenpaint-transform-panel";
    panel.style.display = "none";
    acceptButton.type = "button";
    rejectButton.type = "button";
    acceptButton.className = "btn btn-primary btn-block";
    rejectButton.className = "btn btn-light btn-block";
    acceptButton.textContent = (0, _langJs._)("Apply transform");
    rejectButton.textContent = (0, _langJs._)("Cancel");
    interpCombo.addEventListener("change", function(e) {
        controller.setTransformInterpolation(this.value);
    });
    interpCombo.className = "form-control chickenpaint-transform-interpolation";
    fillCombobox(interpCombo, TRANSFORM_INTERPOLATION);
    if ((0, _cppolyfillJs.isCanvasInterpolationSupported)()) {
        let interpGroup = document.createElement("div"), interpLabel = document.createElement("label");
        interpLabel.textContent = (0, _langJs._)("Transform style");
        interpGroup.className = "form-group";
        interpGroup.appendChild(interpLabel);
        interpGroup.appendChild(interpCombo);
        panel.appendChild(interpGroup);
    }
    let buttonGroup = document.createElement("div");
    buttonGroup.appendChild(acceptButton);
    buttonGroup.appendChild(rejectButton);
    buttonGroup.className = "form-group";
    panel.appendChild(buttonGroup);
    let { wrapper: maintainAspectGroup, checkbox: maintainAspectCheckbox } = createBootstrapCheckbox("chickenpaint-t-maintainAspectCheckbox", (0, _langJs._)("Constrain"), true);
    // パネルに追加
    panel.appendChild(maintainAspectGroup);
    acceptButton.addEventListener("click", function(e) {
        controller.actionPerformed({
            action: "CPTransformAccept"
        });
        e.preventDefault();
    });
    rejectButton.addEventListener("click", function(e) {
        controller.actionPerformed({
            action: "CPTransformReject"
        });
        e.preventDefault();
    });
    // ローカル変数から直接リスナーを追加
    maintainAspectCheckbox.addEventListener("change", ()=>{
        maintainAspectCheckbox.blur(); // フォーカス解除
    // console.log("チェック状態:", maintainAspectCheckbox.checked);
    });
}
// 選択パネル
function CPSelectionPanel(controller) {
    let panel = document.createElement("div"), formGroup = document.createElement("div"), label = document.createElement("label"), selectAllButton = document.createElement("button"), deselectButton = document.createElement("button"), transformButton = document.createElement("button"); // 追加
    this.getElement = function() {
        return panel;
    };
    panel.className = "chickenpaint-selection-panel";
    panel.style.display = "none"; // 初期非表示
    formGroup.className = "form-group";
    // ラベルのみ使用
    label.textContent = (0, _langJs._)("Selection"); // 「選択範囲」
    formGroup.appendChild(label);
    // 「すべて選択」ボタン
    selectAllButton.type = "button";
    selectAllButton.className = "btn btn-light btn-block";
    selectAllButton.textContent = (0, _langJs._)("Select all");
    selectAllButton.addEventListener("click", function(e) {
        controller.actionPerformed({
            action: "CPSelectAll"
        });
        e.preventDefault();
    });
    formGroup.appendChild(selectAllButton);
    // 「選択解除」ボタン
    deselectButton.type = "button";
    deselectButton.className = "btn btn-light btn-block";
    deselectButton.textContent = (0, _langJs._)("Deselect");
    deselectButton.addEventListener("click", function(e) {
        controller.actionPerformed({
            action: "CPDeselectAll"
        });
        e.preventDefault();
    });
    formGroup.appendChild(deselectButton);
    // 「変形」ボタン
    transformButton.type = "button";
    transformButton.className = "btn btn-primary btn-block";
    transformButton.textContent = (0, _langJs._)("Transform");
    transformButton.addEventListener("click", function(e) {
        controller.actionPerformed({
            action: "CPTransform"
        });
        e.preventDefault();
    });
    formGroup.appendChild(transformButton);
    panel.appendChild(formGroup);
    //チェックボックスの作成
    let { wrapper: maintainAspectGroup, checkbox: maintainAspectCheckbox } = createBootstrapCheckbox("chickenpaint-s-maintainAspectCheckbox", (0, _langJs._)("Constrain"), false);
    panel.appendChild(maintainAspectGroup);
    // パネルに追加
    // ローカル変数から直接リスナーを追加
    maintainAspectCheckbox.addEventListener("change", ()=>{
        maintainAspectCheckbox.blur(); // フォーカス解除
    // console.log("チェック状態:", maintainAspectCheckbox.checked);
    });
}
//Bootstrapのチェックボックスを作成
function createBootstrapCheckbox(id, title, checked = false) {
    // チェックボックス作成
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.id = id;
    checkbox.className = "form-check-input";
    checkbox.checked = checked;
    // フォーカス時の青枠を消す
    checkbox.style.outline = "none";
    checkbox.style.boxShadow = "none";
    //タブキーでのフォーカスを無効にする
    checkbox.tabIndex = -1;
    // ラベル作成
    const label = document.createElement("label");
    label.className = "form-check-label";
    label.setAttribute("for", id);
    label.textContent = title;
    // ラッパー div
    const wrapper = document.createElement("div");
    wrapper.className = "form-check";
    wrapper.appendChild(checkbox);
    wrapper.appendChild(label);
    // チェック状態取得用に input を返す場合は一緒に返す
    return {
        wrapper,
        checkbox
    };
}
function CPPanPanel(controller) {
    let panel = document.createElement("div");
    let formGroup = document.createElement("div");
    let label = document.createElement("label");
    let resetButton = document.createElement("button");
    let zoomSlider = new (0, _cpsliderJsDefault.default)(10, 800, false, true, 180, 3.13);
    let rotationSlider = new (0, _cpsliderJsDefault.default)(-180, 180, false, false, 180);
    panel.className = "chickenpaint-pan-panel";
    panel.style.display = "none"; // 初期非表示
    panel.appendChild(zoomSlider.getElement());
    formGroup.className = "form-group";
    // ラベルのみ使用
    label.textContent = (0, _langJs._)("Zoom and Rotate"); //「ズームと回転」
    formGroup.appendChild(label);
    formGroup.appendChild(label);
    panel.appendChild(formGroup);
    // 「すべて選択」ボタン
    resetButton.type = "button";
    resetButton.className = "btn btn-primary btn-block";
    resetButton.style.outline = "none";
    resetButton.style.boxShadow = "none";
    resetButton.textContent = (0, _langJs._)("Reset View");
    resetButton.addEventListener("click", function(e) {
        controller.actionPerformed({
            action: "CPResetZoomAndRotation"
        });
        e.preventDefault();
    });
    formGroup.appendChild(resetButton);
    panel.appendChild(formGroup);
    function fillWithInitialValues() {
        zoomSlider.setValue(controller.getZoom() * 100);
        rotationSlider.setValue(controller.getRotationDegrees());
    }
    zoomSlider.title = function(value) {
        return (0, _langJs._)("Zoom") + ": " + value + "%";
    };
    rotationSlider.title = function(value) {
        return (0, _langJs._)("Rotation") + ": " + value + "\xb0";
    };
    zoomSlider.on("valueChange", function(value) {
        controller.zoomOnCenter(value / 100);
    });
    rotationSlider.on("valueChange", function(value) {
        controller.setRotationDegrees(value);
    });
    panel.appendChild(zoomSlider.getElement());
    panel.appendChild(rotationSlider.getElement());
    this.getElement = function() {
        return panel;
    };
    fillWithInitialValues();
    document.addEventListener("wheel", (e)=>{
        e.preventDefault(); // これでスクロール抑制できる
        updateSliderDebounced();
    }, {
        passive: false
    });
    // デバウンス関数の定義
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(()=>func.apply(this, args), wait);
        };
    }
    //スライダーを更新
    const updateSlider = ()=>{
        zoomSlider.setValue(controller.getZoom() * 100);
        rotationSlider.setValue(controller.getRotationDegrees());
    };
    // デバウンス関数を使用して、連続したイベントをまとめて処理
    const updateSliderDebounced = debounce(updateSlider, 12);
    const isZoomRotateEnabled = (e)=>{
        return controller.isPanOrRotateMode() || (0, _keymasterJsDefault.default).isPressed("space") || (0, _keymasterJsDefault.default).isPressed("r") || (0, _keymasterJsDefault.default).isPressed("z");
    };
    let isPointerDown = false;
    document.addEventListener("pointerdown", (e)=>{
        if (!isZoomRotateEnabled(e)) return;
        isPointerDown = true;
        updateSliderDebounced();
    });
    document.addEventListener("pointermove", (e)=>{
        if (!isPointerDown) return;
        if (!isZoomRotateEnabled(e)) return;
        updateSliderDebounced();
    });
    document.addEventListener("pointerup", (e)=>{
        isPointerDown = false;
        if (!isZoomRotateEnabled(e)) return;
        updateSliderDebounced();
    });
    // キーボードでのサイズ変更
    (0, _keymasterJsDefault.default)("=,-,ctrl+0,alt+0,r,z,space,enter", function() {
        if (isPointerDown) return; // ポインターダウンの時は更新しない
        updateSliderDebounced();
    });
    //パンや回転ツールのアイコンがクリックされたときにスライダーを更新
    document.addEventListener("click", (e)=>{
        if (e.target instanceof HTMLElement && e.target.classList.contains("chickenpaint-toolbar-button-icon")) updateSliderDebounced();
    });
}

},{"../ChickenPaint.js":"3lJkm","./CPPalette.js":"2mLTE","./CPCheckbox.js":"dRWru","./CPColorSwatch.js":"dXfrB","./CPSlider.js":"3GYON","./CPGUIUtils.js":"9eZG7","../engine/CPColorBmp.js":"5rykl","../util/CPColor.js":"ioCeM","../util/CPPolyfill.js":"89GR9","../../lib/keymaster.js":"hFCDu","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dRWru":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPCheckbox);
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
function CPCheckbox(state, title) {
    var canvas = document.createElement('canvas'), canvasContext = canvas.getContext('2d'), that = this;
    this.state = state || false;
    function paint() {
        var width = canvas.width, height = canvas.height;
        canvasContext.clearRect(0, 0, width, height);
        canvasContext.beginPath();
        canvasContext.arc(width / 2 + 1, width / 2 + 1, Math.max(width / 2, 1) - 2, 0, Math.PI * 2);
        if (that.state) canvasContext.fill();
        else canvasContext.stroke();
    }
    this.setValue = function(b) {
        if (this.state != b) {
            this.state = b;
            this.emitEvent('valueChange', [
                b
            ]);
            paint();
        }
    };
    this.getElement = function() {
        return canvas;
    };
    canvas.addEventListener("mousedown", function(e) {
        that.setValue(!that.state);
    });
    canvas.title = title || "";
    canvas.className = 'chickenpaint-checkbox';
    canvas.width = 20;
    canvas.height = 20;
    canvas.fillStyle = 'black';
    canvas.strokeStyle = 'black';
    paint();
}
CPCheckbox.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
CPCheckbox.prototype.constructor = CPCheckbox;

},{"wolfy87-eventemitter":"gPUo0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dXfrB":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint

    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.

    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPColorSwatch);
var _bootstrapBundleMinJs = require("bootstrap/dist/js/bootstrap.bundle.min.js");
var _langJs = require("../languages/lang.js");
var _cpcolorJs = require("../util/CPColor.js");
var _cpcolorJsDefault = parcelHelpers.interopDefault(_cpcolorJs);
var _cpsliderJs = require("./CPSlider.js");
var _cpsliderJsDefault = parcelHelpers.interopDefault(_cpsliderJs);
var _cpcolorSelectJs = require("./CPColorSelect.js");
var _cpcolorSelectJsDefault = parcelHelpers.interopDefault(_cpcolorSelectJs);
var _cpcolorSliderJs = require("./CPColorSlider.js");
var _cpcolorSliderJsDefault = parcelHelpers.interopDefault(_cpcolorSliderJs);
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
function CPColorSwatch(initialColor, initialAlpha, containerElement) {
    let that = this, color = new (0, _cpcolorJsDefault.default)(0), alpha = 255, element = document.createElement("div");
    function padLeft(string, padding, len) {
        while(string.length < len)string = padding + string;
        return string;
    }
    function paint() {
        element.style.backgroundColor = "#" + padLeft(Number(color.getRgb()).toString(16), "0", 6);
    }
    this.getElement = function() {
        return element;
    };
    this.setColor = function(_color) {
        if (!color.isEqual(_color)) {
            color.copyFrom(_color);
            paint();
            this.emitEvent("colorChange", [
                color
            ]);
        }
    };
    this.setAlpha = function(_alpha) {
        if (_alpha != alpha) {
            alpha = _alpha;
            paint();
            this.emitEvent("alphaChange", [
                alpha
            ]);
        }
    };
    this.getColorRgb = function() {
        return color.getRgb();
    };
    this.getAlpha = function() {
        return alpha;
    };
    this.setCurColor = this.setColor;
    function buildColorEditPanel() {
        const panel = document.createElement("div"), group = document.createElement("div"), select = new (0, _cpcolorSelectJsDefault.default)(that, color), slider = new (0, _cpcolorSliderJsDefault.default)(that, select, color.getHue()), alphaSlider = new (0, _cpsliderJsDefault.default)(0, 255);
        panel.className = "chickenpaint-color-pick-panel";
        group.className = "chickenpaint-colorpicker-top";
        group.appendChild(select.getElement());
        group.appendChild(slider.getElement());
        panel.appendChild(group);
        alphaSlider.value = alpha;
        alphaSlider.title = function(alpha) {
            return (0, _langJs._)("Opacity: ") + alpha;
        };
        alphaSlider.on("valueChange", function(alpha) {
            that.setAlpha(alpha);
        });
        panel.appendChild(alphaSlider.getElement());
        setTimeout(function() {
            alphaSlider.resize();
        }, 0);
        return panel;
    }
    element.className = 'chickenpaint-color-pick-swatch';
    if (initialColor) color.copyFrom(initialColor);
    if (initialAlpha) alpha = initialAlpha;
    const bootstrapPopover = new _bootstrapBundleMinJs.Popover(element, {
        html: true,
        content: function() {
            window.addEventListener("mousedown", closeClickHandler);
            return buildColorEditPanel();
        },
        trigger: "manual",
        placement: "bottom",
        container: containerElement || false
    });
    // Clicking outside the popover will dismiss it
    const closeClickHandler = function(e) {
        const colorpicker = e.target;
        const isColorPicker = colorpicker.closest('.popover-body') || colorpicker.classList.contains('chickenpaint-color-pick-panel') || colorpicker.classList.contains('chickenpaint-colorpicker-select') || colorpicker.classList.contains('chickenpaint-colorpicker-slider');
        e.preventDefault();
        // console.log("closeClickHandler",e);
        if (isColorPicker) return;
        bootstrapPopover.hide();
    };
    element.addEventListener("click", function(e) {
        e.preventDefault();
        bootstrapPopover.toggle();
    });
    element.addEventListener("hidden.bs.popover", function() {
        window.removeEventListener("mousedown", closeClickHandler);
    });
    paint();
}
CPColorSwatch.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
CPColorSwatch.prototype.constructor = CPColorSwatch;

},{"bootstrap/dist/js/bootstrap.bundle.min.js":"joWv1","../languages/lang.js":"9myCU","../util/CPColor.js":"ioCeM","./CPSlider.js":"3GYON","./CPColorSelect.js":"dlCqQ","./CPColorSlider.js":"eC5nU","wolfy87-eventemitter":"gPUo0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3GYON":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPSlider);
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
var _langJs = require("../languages/lang.js");
function CPSlider(minValue, maxValue, centerMode, expMode, defaultWidth = 150, expModeFactor = 2.5 //低い値の時にスライダーの動作を細やかにする係数
) {
    const PRECISE_DRAG_SCALE = 4, DRAG_MODE_IDLE = 0, DRAG_MODE_NORMAL = 1, DRAG_MODE_PRECISE = 2;
    let canvas = document.createElement("canvas"), canvasContext = canvas.getContext("2d"), valueRange = maxValue - minValue, dragMode = DRAG_MODE_IDLE, dragPreciseX, doneInitialPaint = false, that = this;
    this.value = undefined;
    /**
     * Either a string to draw on the slider, or a function(value) which receives the current value of the slider and
     * should return the string to be painted to the slider.
     *
     * @name CPSlider#title
     * @default ""
     */ this.title = "";
    centerMode = centerMode || false;
    function paint() {
        let width = canvas.width || defaultWidth;
        let height = canvas.height;
        let title = typeof that.title === "string" ? (0, _langJs._)(that.title) : that.title(that.value);
        let textX = 3 * window.devicePixelRatio;
        let textY = canvas.height * 0.75;
        if (centerMode) {
            canvasContext.save();
            canvasContext.fillStyle = "white";
            canvasContext.fillRect(0, 0, width, height);
            canvasContext.fillStyle = "black";
            canvasContext.fillText(title, textX, textY);
            canvasContext.beginPath();
            // if (that.value >= valueRange / 2) {
            //     canvasContext.rect(width / 2, 0, (that.value - valueRange / 2) * width / valueRange, height);
            // } else {
            //     canvasContext.rect(that.value * width / valueRange, 0, (valueRange / 2 - that.value) * width / valueRange, height);
            // }
            if (that.value >= 0) // 正の値は中央→右へ
            canvasContext.rect(width / 2, 0, that.value / maxValue * (width / 2), height);
            else // 負の値は中央→左へ
            canvasContext.rect(width / 2 + that.value / Math.abs(minValue) * (width / 2), 0, -(that.value / Math.abs(minValue)) * (width / 2), height);
            canvasContext.fill();
            canvasContext.clip();
            canvasContext.fillStyle = "white";
            canvasContext.fillText(title, textX, textY);
            canvasContext.restore();
        } else {
            let barProp = (that.value - minValue) / valueRange, barWidth;
            if (expMode) barProp = Math.pow(barProp, 1 / expModeFactor);
            barWidth = barProp * width;
            canvasContext.save();
            canvasContext.save();
            canvasContext.fillStyle = "black";
            canvasContext.beginPath();
            canvasContext.rect(0, 0, barWidth, height);
            canvasContext.fill();
            canvasContext.clip();
            canvasContext.fillStyle = "white";
            canvasContext.fillText(title, textX, textY);
            // Remove the clip region
            canvasContext.restore();
            canvasContext.fillStyle = "white";
            canvasContext.beginPath();
            canvasContext.rect(barWidth, 0, width, height);
            canvasContext.fill();
            canvasContext.clip();
            canvasContext.fillStyle = "black";
            canvasContext.fillText(title, textX, textY);
            canvasContext.restore();
        }
    }
    function mouseSelect(e) {
        let width = canvas.clientWidth;
        let left = canvas.getBoundingClientRect().left + window.scrollX;
        let proportion = (e.pageX - left) / width;
        if (expMode) // Give the user finer control over the low values
        proportion = Math.pow(Math.max(proportion, 0.0), expModeFactor);
        that.setValue(proportion * valueRange + minValue);
    }
    function pointerDragged(e) {
        switch(dragMode){
            case DRAG_MODE_NORMAL:
                return mouseSelect(e);
            case DRAG_MODE_PRECISE:
                let title = that.title();
                //ブラシサイズと不透明度以外は細やかなスライダーの動作をしない
                if (!(title.includes((0, _langJs._)("Brush size")) || title.includes((0, _langJs._)("Opacity")))) return mouseSelect(e);
                let diff = (e.pageX - dragPreciseX) / PRECISE_DRAG_SCALE;
                if (diff !== 0) {
                    let unrounded = that.value + diff;
                    let rounded = Math.floor(unrounded);
                    that.setValue(rounded);
                    /* Tweak the "old mouseX" position such that the fractional part of the value we were unable to set
                     * will be accumulated
                     */ dragPreciseX = e.pageX - (unrounded - rounded) * PRECISE_DRAG_SCALE;
                }
                break;
        }
    }
    canvas.addEventListener("pointerup", (e)=>{
        if (dragMode === DRAG_MODE_IDLE) {
            canvas.releasePointerCapture(e.pointerId);
            return canvas.removeEventListener("pointermove", pointerDragged);
        }
        if (dragMode !== DRAG_MODE_IDLE) switch(dragMode){
            case DRAG_MODE_NORMAL:
                if (e.button === 0 && !e.shiftKey) dragMode = DRAG_MODE_IDLE;
                break;
            case DRAG_MODE_PRECISE:
                if (e.button == 2 || e.button === 0 && e.shiftKey) dragMode = DRAG_MODE_IDLE;
                break;
            default:
                return;
        }
        canvas.releasePointerCapture(e.pointerId);
        return canvas.removeEventListener("pointermove", pointerDragged);
    });
    this.setValue = function(_value) {
        _value = ~~Math.max(minValue, Math.min(maxValue, _value));
        if (this.value != _value) {
            this.value = _value;
            // The event listeners might like to update our title property at this point to reflect the new value
            this.emitEvent("valueChange", [
                this.value
            ]);
            if (doneInitialPaint) paint();
            else {
                // We don't bother to do our canvas dimensioning until we're supplied with an initial value
                doneInitialPaint = true;
                this.resize();
            }
        }
    };
    /**
     * Get the DOM element for the slider component.
     */ this.getElement = function() {
        return canvas;
    };
    this.resize = function() {
        canvas.width = canvas.clientWidth || defaultWidth;
        canvas.height = canvas.clientHeight || 20;
        if (window.devicePixelRatio > 1) {
            // Assume our width is set to 100% or similar, so we only need to the fix the height
            canvas.style.height = canvas.height + "px";
            canvas.width = canvas.width * window.devicePixelRatio;
            canvas.height = canvas.height * window.devicePixelRatio;
        }
        canvasContext.font = canvas.height * 0.47 + "pt sans-serif";
        paint();
    };
    canvas.addEventListener("pointerdown", function(e) {
        if (dragMode === DRAG_MODE_IDLE) {
            if (e.button === 2 || e.button === 0 && e.shiftKey) {
                dragMode = DRAG_MODE_PRECISE;
                dragPreciseX = e.pageX;
            } else {
                dragMode = DRAG_MODE_NORMAL;
                mouseSelect(e);
            }
            canvas.setPointerCapture(e.pointerId);
            canvas.addEventListener("pointermove", pointerDragged);
        }
    });
    canvas.addEventListener("contextmenu", function(e) {
        e.preventDefault();
    });
    canvas.setAttribute("touch-action", "none");
    canvas.className = "chickenpaint-slider";
    if (!("devicePixelRatio" in window)) // Old browsers
    window.devicePixelRatio = 1.0;
}
CPSlider.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
CPSlider.prototype.constructor = CPSlider;

},{"wolfy87-eventemitter":"gPUo0","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dMvva":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPLayersPalette);
var _bootstrapBundleMinJs = require("bootstrap/dist/js/bootstrap.bundle.min.js");
var _cppaletteJs = require("./CPPalette.js");
var _cppaletteJsDefault = parcelHelpers.interopDefault(_cppaletteJs);
var _cpblendJs = require("../engine/CPBlend.js");
var _cpblendJsDefault = parcelHelpers.interopDefault(_cpblendJs);
var _cpsliderJs = require("./CPSlider.js");
var _cpsliderJsDefault = parcelHelpers.interopDefault(_cpsliderJs);
var _cplayerGroupJs = require("../engine/CPLayerGroup.js");
var _cplayerGroupJsDefault = parcelHelpers.interopDefault(_cplayerGroupJs);
var _cplayerJs = require("../engine/CPLayer.js");
var _cplayerJsDefault = parcelHelpers.interopDefault(_cplayerJs);
var _cpimageLayerJs = require("../engine/CPImageLayer.js");
var _cpimageLayerJsDefault = parcelHelpers.interopDefault(_cpimageLayerJs);
var _langJs = require("../languages/lang.js");
function absorbTouch(e) {
    e.preventDefault();
    e.stopPropagation();
}
function createFontAwesomeIcon(iconName) {
    let icon = document.createElement("span");
    icon.className = "fa " + iconName;
    return icon;
}
function createChickenPaintIcon(iconName) {
    let icon = document.createElement("span");
    icon.className = "chickenpaint-icon chickenpaint-icon-" + iconName;
    return icon;
}
/**
 *
 * @param {HTMLInputElement} checkbox - Must have a unique ID set
 * @param {string} title
 *
 * @returns {HTMLElement}
 */ function wrapBootstrapCheckbox(checkbox, title) {
    let div = document.createElement("div"), label = document.createElement("label");
    label.tabIndex = -1;
    checkbox.tabIndex = -1;
    div.className = "form-check";
    checkbox.className = "form-check-input";
    label.className = "form-check-label";
    label.setAttribute("for", checkbox.id);
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(title));
    div.appendChild(checkbox);
    div.appendChild(label);
    return div;
}
function computeLayerPredicates(layer, isEditingMask) {
    return {
        "image-layer": layer instanceof (0, _cpimageLayerJsDefault.default),
        "layer-group": layer instanceof (0, _cplayerGroupJsDefault.default),
        "clipping-mask": layer instanceof (0, _cpimageLayerJsDefault.default) && layer.clip,
        "no-clipping-mask": layer instanceof (0, _cpimageLayerJsDefault.default) && !layer.clip,
        "no-clipping-mask-or-is-group": !(layer instanceof (0, _cpimageLayerJsDefault.default)) || !layer.clip,
        mask: layer && layer.mask !== null,
        "no-mask": layer && layer.mask === null,
        "mask-enabled": layer && layer.mask !== null && layer.maskVisible,
        "mask-disabled": layer && layer.mask !== null && !layer.maskVisible,
        isNotEditingMask: layer && !isEditingMask,
        isEditingMask: layer && layer.mask !== null && isEditingMask
    };
}
function CPLayersPalette(controller) {
    (0, _cppaletteJsDefault.default).call(this, controller, "layers", "Layers", {
        resizeHorz: true,
        resizeVert: true
    });
    const NOTIFICATION_HIDE_DELAY_MS_PER_CHAR = 70, NOTIFICATION_HIDE_DELAY_MIN = 3000, BUTTON_PRIMARY = 0, BUTTON_WHEEL = 1, BUTTON_SECONDARY = 2;
    let palette = this, artwork = controller.getArtwork(), /**
         * An array of layers in display order, with the layers inside collapsed groups not present.
         *
         * @type {CPLayer[]}
         */ linearizedLayers = null, body = this.getBodyElement(), positionRoot = this.getElement(), // This element will be responsible for positioning the BS dropdown
    dropdownParent = positionRoot, layerWidget = new CPLayerWidget(), alphaSlider = new (0, _cpsliderJsDefault.default)(0, 100, false, false, 208), blendCombo = document.createElement("select"), renameField = new CPRenameField(), cbSampleAllLayers = document.createElement("input"), cbLockAlpha = document.createElement("input"), notificationDismissTimer = false, layerActionButtons;
    /**
     *
     * @param {number} displayIndex
     * @returns {CPLayer}
     */ function getLayerFromDisplayIndex(displayIndex) {
        return linearizedLayers[displayIndex];
    }
    /**
     *
     * @param {CPLayer} layer
     * @returns {number}
     */ function getDisplayIndexFromLayer(layer) {
        return linearizedLayers.indexOf(layer);
    }
    function CPLayerWidget() {
        const LAYER_DRAG_START_THRESHOLD = 5, LAYER_IN_GROUP_INDENT = 16, CLASSNAME_LAYER_ACTIVE = "active", CLASSNAME_LAYER_VISIBLE = "chickenpaint-layer-visible", CLASSNAME_LAYER_HIDDEN = "chickenpaint-layer-hidden", CLASSNAME_LAYER_GROUP_EXPANDED = "chickenpaint-layer-group-expanded", CLASSNAME_LAYER_GROUP_COLLAPSED = "chickenpaint-layer-group-collapsed", CLASSNAME_LAYER_GROUP_TOGGLE = "chickenpaint-layer-group-toggle", CLASSNAME_LAYER_IMAGE_THUMBNAIL = "chickenpaint-layer-image-thumbnail", CLASSNAME_LAYER_MASK_THUMBNAIL = "chickenpaint-layer-mask-thumbnail", CLASSNAME_LAYER_THUMBNAIL = "chickenpaint-layer-thumbnail", DRAG_STATE_IDLE = 0, DRAG_STATE_PRE_DRAG = 1, DRAG_STATE_DRAGGING = 2, DRAG_STATE_PRE_PAN = 3, DRAG_STATE_PANNING = 4, LONG_PRESS_INTERVAL = 800;
        let drag = {
            /**
                 *
                 * @type {number}
                 */ state: DRAG_STATE_IDLE,
            /**
                 * The image layer currently being dragged, or null if no drag is in progress.
                 *
                 * @type {?CPLayer}
                 */ layer: null,
            /**
                 * The element of the layer being dragged
                 *
                 * @type {HTMLElement}
                 */ layerElem: null,
            /**
                 * @type {number}
                 */ dragX: 0,
            /**
                 * @type {number}
                 */ dragY: 0,
            /**
                 * @type {number}
                 */ initialScrollTop: 0,
            dropTarget: null,
            dropBetweenMarkerElem: null,
            frameElem: null
        }, widgetContainer = document.createElement("div"), layerContainer = document.createElement("div"), scrollContainer = layerContainer, //ドロップダウンメニュー関連項目のコメントアウト
        // dropdownLayerMenu = createLayerDropdownMenu(),
        // dropdownMousePos = {x: 0, y: 0},
        /**
             * @type {number} Rotation of image in 90 degree units
             */ imageRotation = 0, /**
             * The layer we right-clicked on to open the dropdown
             *
             * @type {CPLayer}
             */ dropdownLayer = null, /**
             * True if we right-clicked on the mask of the layer for the dropdown.
             * @type {boolean}
             */ dropdownOnMask = false, longPressTimer = null;
        /**
         * Get the element that represents the layer with the given display index.
         *
         * @param {number} displayIndex
         * @returns {HTMLElement}
         */ function getElemFromDisplayIndex(displayIndex) {
            let elems = layerContainer.querySelectorAll(".chickenpaint-layer");
            return elems[elems.length - 1 - displayIndex];
        }
        function getDisplayIndexFromElem(elem) {
            if (!elem) return -1;
            let layer = elem.closest(".chickenpaint-layer");
            if (layer) {
                let elems = Array.from(layerContainer.querySelectorAll(".chickenpaint-layer"));
                return elems.length - 1 - elems.indexOf(layer);
            } else return -1;
        }
        /**
         * @typedef {Object} CPDropTarget
         *
         * @property {number} displayIndex - The index of the layer to insert near
         * @property {CPLayer} layer - The layer to insert near
         * @property {string} direction - "under", "over" or "inside", the direction to insert relative to the target
         */ /**
         * Decides which drop target we should offer for the given mouse position.
         *
         * Returns null if no drop should be offered at the given position, otherwise returns an object with details
         * on the drop.
         *
         * @param {number} clientX
         * @param {number} clientY
         * @returns {?CPDropTarget}
         */ function getDropTargetFromClientPos(clientX, clientY) {
            let layerElems = layerContainer.querySelectorAll(".chickenpaint-layer"), target = {
                layer: linearizedLayers[linearizedLayers.length - 1],
                displayIndex: linearizedLayers.length - 1,
                direction: "over"
            };
            for(let displayIndex = 0; displayIndex < layerElems.length; displayIndex++){
                let targetElem = layerElems[layerElems.length - 1 - displayIndex], rect = targetElem.getBoundingClientRect();
                if (displayIndex === 0 && clientY > rect.bottom) {
                    let lastLayer = artwork.getLayersRoot().layers[0];
                    target = {
                        layer: lastLayer,
                        displayIndex: getDisplayIndexFromLayer(lastLayer),
                        direction: "under"
                    };
                    break;
                } else if (clientY >= rect.top) {
                    let targetLayer = getLayerFromDisplayIndex(displayIndex), targetHeight = rect.bottom - rect.top;
                    target = {
                        layer: targetLayer,
                        displayIndex: displayIndex
                    };
                    if (targetLayer instanceof (0, _cplayerGroupJsDefault.default)) {
                        if (clientY >= rect.top + targetHeight * 0.75) {
                            if (targetLayer.expanded && targetLayer.layers.length > 0) {
                                target.layer = targetLayer.layers[targetLayer.layers.length - 1];
                                target.displayIndex--;
                                target.direction = "over";
                            } else target.direction = "under";
                        } else if (clientY >= rect.top + targetHeight * 0.25) {
                            if (targetLayer.expanded && targetLayer.layers.length > 0) {
                                target.layer = targetLayer.layers[targetLayer.layers.length - 1];
                                target.displayIndex--;
                                target.direction = "over";
                            } else target.direction = "inside";
                        } else target.direction = "over";
                    } else target.direction = clientY >= rect.top + targetHeight * 0.5 ? "under" : "over";
                    break;
                }
            }
            /*
             * If we're dropping into the same container, make sure we don't offer to drop the layer back to the
             * same position it was already in.
             */ if (target.layer.parent === drag.layer.parent && (target.direction === "over" || target.direction === "under")) {
                let parentGroup = target.layer.parent, targetIndex = parentGroup.indexOf(target.layer);
                if (target.direction === "over" && parentGroup.layers[targetIndex + 1] === drag.layer || target.direction === "under" && parentGroup.layers[targetIndex - 1] === drag.layer || target.layer === drag.layer) return null;
            }
            /*
             * Make sure we don't try to drop a group as a child of itself, no group-ception!
             */ if (drag.layer instanceof (0, _cplayerGroupJsDefault.default) && (target.layer === drag.layer && target.direction === "inside" || target.layer.hasAncestor(drag.layer))) return null;
            return target;
        }
        function updateDropMarker() {
            if (drag.state === DRAG_STATE_DRAGGING) {
                let positionRootBounds = positionRoot.getBoundingClientRect(), hideBetweenMarker = true, hideIntoMarker = true;
                drag.dropTarget = getDropTargetFromClientPos(drag.dragX, drag.dragY);
                if (drag.dropTarget) {
                    let targetElem = getElemFromDisplayIndex(drag.dropTarget.displayIndex);
                    switch(drag.dropTarget.direction){
                        case "over":
                        case "under":
                            layerContainer.appendChild(drag.dropBetweenMarkerElem);
                            let markerDepth = drag.dropTarget.layer.getDepth() - 1, markerLeft, layerBottom;
                            // Position the marker in the correct position between the layers, and indent it to match the layer
                            let layerRect = targetElem.getBoundingClientRect();
                            // Are we dropping below the layers in an expanded group? Extend the rect to enclose them
                            if (drag.dropTarget.direction === "under" && drag.dropTarget.layer instanceof (0, _cplayerGroupJsDefault.default) && drag.dropTarget.layer.expanded) {
                                // Find the display index after this group
                                let childIndex;
                                for(childIndex = drag.dropTarget.displayIndex - 1; childIndex >= 0; childIndex--){
                                    if (!linearizedLayers[childIndex].hasAncestor(drag.dropTarget.layer)) break;
                                }
                                layerBottom = getElemFromDisplayIndex(childIndex + 1).getBoundingClientRect().bottom;
                            } else layerBottom = layerRect.bottom;
                            markerLeft = layerRect.left - positionRootBounds.left + (markerDepth > 0 ? 26 + LAYER_IN_GROUP_INDENT * markerDepth : 0);
                            drag.dropBetweenMarkerElem.style.left = markerLeft + "px";
                            drag.dropBetweenMarkerElem.style.width = layerRect.right - positionRootBounds.left - markerLeft + "px";
                            drag.dropBetweenMarkerElem.style.top = (drag.dropTarget.direction === "over" ? layerRect.top - 1 : layerBottom + 1) - positionRootBounds.top + "px";
                            layerContainer.querySelectorAll(".chickenpaint-layer-drop-target").forEach((el)=>el.classList.remove("chickenpaint-layer-drop-target"));
                            hideBetweenMarker = false;
                            break;
                        case "inside":
                            let layerElems = layerContainer.querySelectorAll(".chickenpaint-layer");
                            layerElems.forEach((elem, index)=>{
                                elem.classList.toggle("chickenpaint-layer-drop-target", layerElems.length - 1 - index === drag.dropTarget.displayIndex);
                            });
                            hideIntoMarker = false;
                            break;
                    }
                }
                if (hideIntoMarker) layerContainer.querySelectorAll(".chickenpaint-layer-drop-target").forEach((el)=>el.classList.remove("chickenpaint-layer-drop-target"));
                if (hideBetweenMarker) drag.dropBetweenMarkerElem?.remove();
                drag.frameElem.style.top = drag.dragY - positionRootBounds.top - parseInt(drag.frameElem.style.height, 10) / 2 + "px";
            } else {
                drag.dropBetweenMarkerElem?.remove();
                drag.frameElem?.remove();
            }
        }
        function createImageThumb(layer) {
            let thumbnail = layer.getImageThumbnail(), thumbCanvas = thumbnail.getAsCanvas(imageRotation);
            thumbCanvas.title = (0, _langJs._)("Image");
            thumbCanvas.className = CLASSNAME_LAYER_THUMBNAIL + " " + CLASSNAME_LAYER_IMAGE_THUMBNAIL;
            // Thumbnails are actually displayed at 25px high, set the display width appropriately for the aspect ratio
            thumbCanvas.style.maxWidth = thumbCanvas.width / thumbCanvas.height * 25 + "px";
            if (layer == artwork.getActiveLayer() && !artwork.isEditingMask()) thumbCanvas.className += " active";
            return thumbCanvas;
        }
        function drawRedX(canvas) {
            const X_INSET = 5, Y_INSET = 5, X_LINE_THICKNESS = 3, context = canvas.getContext("2d");
            context.strokeStyle = "red";
            context.lineWidth = X_LINE_THICKNESS;
            context.moveTo(X_INSET, Y_INSET);
            context.lineTo(canvas.width - X_INSET, canvas.height - Y_INSET);
            context.moveTo(canvas.width - X_INSET, Y_INSET);
            context.lineTo(X_INSET, canvas.height - Y_INSET);
            context.stroke();
        }
        function createMaskThumb(layer) {
            let thumbnail = layer.getMaskThumbnail(), thumbCanvas = thumbnail.getAsCanvas(imageRotation);
            thumbCanvas.title = (0, _langJs._)("Layer mask");
            thumbCanvas.className = CLASSNAME_LAYER_THUMBNAIL + " " + CLASSNAME_LAYER_MASK_THUMBNAIL;
            // Thumbnails are actually displayed at 25px high, set the display width appropriately for the aspect ratio
            thumbCanvas.style.maxWidth = thumbCanvas.width / thumbCanvas.height * 25 + "px";
            if (layer == artwork.getActiveLayer() && artwork.isEditingMask()) thumbCanvas.className += " active";
            if (!layer.maskVisible) {
                thumbCanvas.className += " disabled";
                drawRedX(thumbCanvas);
            }
            return thumbCanvas;
        }
        /**
         * Create a DOM element for the given layer
         *
         * @param {number} index
         * @param {CPLayer} layer
         */ function buildLayer(index, layer) {
            let layerDiv = document.createElement("div"), eyeDiv = document.createElement("div"), mainDiv = document.createElement("div"), iconsDiv = document.createElement("div"), layerNameDiv = document.createElement("div"), statusDiv = document.createElement("div"), blendDiv = document.createElement("div");
            layerDiv.className = "chickenpaint-layer list-group-item";
            if (layer == artwork.getActiveLayer()) layerDiv.className += " " + CLASSNAME_LAYER_ACTIVE;
            eyeDiv.className = "chickenpaint-layer-eye";
            if (!layer.ancestorsAreVisible()) eyeDiv.className += " chickenpaint-layer-eye-hidden-ancestors";
            eyeDiv.style.marginRight = 2 + LAYER_IN_GROUP_INDENT * (layer.getDepth() - 1) + "px";
            if (layer.visible) {
                layerDiv.className += " " + CLASSNAME_LAYER_VISIBLE;
                eyeDiv.appendChild(createFontAwesomeIcon("icon-eye"));
            } else {
                layerDiv.className += " " + CLASSNAME_LAYER_HIDDEN;
                eyeDiv.appendChild(createFontAwesomeIcon("icon-eye-slash"));
            }
            layerDiv.appendChild(eyeDiv);
            mainDiv.className = "chickenpaint-layer-description";
            if (layer instanceof (0, _cpimageLayerJsDefault.default)) {
                if (layer.clip) {
                    layerDiv.className += " chickenpaint-layer-clipped";
                    iconsDiv.appendChild(createFontAwesomeIcon("icon-level-down-alt fa-flip-horizontal"));
                }
                if (layer.lockAlpha) {
                    let locked = createChickenPaintIcon("lock-alpha");
                    locked.title = (0, _langJs._)("Transparency locked");
                    statusDiv.appendChild(locked);
                }
            } else if (layer instanceof (0, _cplayerGroupJsDefault.default)) {
                layerDiv.className += " chickenpaint-layer-group";
                if (layer.expanded) {
                    layerDiv.className += " " + CLASSNAME_LAYER_GROUP_EXPANDED;
                    iconsDiv.appendChild(createFontAwesomeIcon("icon-folder-open chickenpaint-layer-group-toggle"));
                } else {
                    layerDiv.className += " " + CLASSNAME_LAYER_GROUP_COLLAPSED;
                    iconsDiv.appendChild(createFontAwesomeIcon("icon-folder chickenpaint-layer-group-toggle"));
                }
            }
            if (iconsDiv.childNodes.length) {
                iconsDiv.className = "chickenpaint-layer-icons";
                layerDiv.appendChild(iconsDiv);
            }
            try {
                if (layer instanceof (0, _cpimageLayerJsDefault.default)) layerDiv.appendChild(createImageThumb(layer));
                if (layer.mask) layerDiv.appendChild(createMaskThumb(layer));
            } catch (e) {
                // We don't expect this to ever happen but it'd be nice if everything keeps running if it does
                console.log("Failed to create layer thumb");
            }
            let layerName = layer.name && layer.name.length > 0 ? layer.name : "(unnamed " + (layer instanceof (0, _cplayerGroupJsDefault.default) ? "group" : "layer") + ")";
            layerNameDiv.innerText = layerName;
            layerNameDiv.setAttribute("title", layerName);
            layerNameDiv.className = "chickenpaint-layer-name";
            blendDiv.innerText = (0, _langJs._)((0, _cpblendJsDefault.default).BLEND_MODE_DISPLAY_NAMES[layer.blendMode]) + ": " + layer.alpha + "%";
            blendDiv.className = "chickenpaint-layer-blend";
            mainDiv.appendChild(layerNameDiv);
            mainDiv.appendChild(blendDiv);
            layerDiv.appendChild(mainDiv);
            statusDiv.className = "chickenpaint-layer-status";
            layerDiv.appendChild(statusDiv);
            layerDiv.setAttribute("data-display-index", "" + index);
            // layerDiv.setAttribute("data-toggle", "dropdown");
            // layerDiv.setAttribute("data-target", "#chickenpaint-layer-pop");
            return layerDiv;
        }
        function showRenameBoxForLayer(displayIndex) {
            if (displayIndex > -1) {
                let layer = getLayerFromDisplayIndex(displayIndex), elem = getElemFromDisplayIndex(displayIndex);
                if (layer && elem) renameField.show(layer, elem);
            }
        }
        function onDoubleClick(e) {
            if (e.button === BUTTON_PRIMARY && e.target.closest(".chickenpaint-layer-description") && !e.target.closest("input")) {
                /* Double clicking the layer description should start editing it, but ignore double clicks inside
                 * the rename textbox itself
                 */ showRenameBoxForLayer(getDisplayIndexFromElem(e.target));
                e.preventDefault();
            }
        }
        function showContextMenu(e) {
            let displayIndex = getDisplayIndexFromElem(e.target);
            if (displayIndex != -1) {
                //コンテキストメニューのBootstrap5対応ができなかったが
                //マウス使用時にレイヤー名を変更できないと困るので
                //右クリックでレイヤー名の変更になるように動作を変更した。
                showRenameBoxForLayer(getDisplayIndexFromElem(e.target));
                e.preventDefault();
            }
        }
        function onPointerDown(e) {
            let layerElem = e.target.closest(".chickenpaint-layer");
            let displayIndex = getDisplayIndexFromElem(layerElem);
            if (displayIndex !== -1) {
                let layer = getLayerFromDisplayIndex(displayIndex);
                if (e.button === BUTTON_PRIMARY && e.target.closest(".chickenpaint-layer-eye")) controller.actionPerformed({
                    action: "CPSetLayerVisibility",
                    layer: layer,
                    visible: !layer.visible
                });
                else if (e.button === BUTTON_PRIMARY && layer instanceof (0, _cplayerGroupJsDefault.default) && e.target.closest("." + CLASSNAME_LAYER_GROUP_TOGGLE)) controller.actionPerformed({
                    action: "CPExpandLayerGroup",
                    group: layer,
                    expand: !layer.expanded
                });
                else {
                    let layerChanged = artwork.getActiveLayer() !== layer;
                    dropdownOnMask = e.target.closest("." + CLASSNAME_LAYER_MASK_THUMBNAIL) !== null || layer instanceof (0, _cplayerGroupJsDefault.default) && layer.mask !== null && layerChanged;
                    if (e.button === BUTTON_PRIMARY && e.shiftKey && !(e.ctrlKey || e.metaKey) && dropdownOnMask) controller.actionPerformed({
                        action: "CPSetMaskVisible",
                        layer: layer,
                        visible: !layer.maskVisible
                    });
                    else {
                        let selectMask, maskChanged;
                        if (e.button !== BUTTON_PRIMARY && !layerChanged) /*
                             * Right clicking within the currently selected layer does not result in the mask/image selection
                             * moving (but it does change the type of dropdown menu we receive)
                             */ selectMask = artwork.isEditingMask();
                        else selectMask = dropdownOnMask;
                        maskChanged = artwork.isEditingMask() !== selectMask;
                        if (layerChanged || maskChanged) controller.actionPerformed({
                            action: "CPSetActiveLayer",
                            layer: layer,
                            mask: selectMask
                        });
                        if (selectMask && e.altKey) controller.actionPerformed({
                            action: "CPToggleMaskView"
                        });
                        else if (selectMask && !e.shiftKey && (e.ctrlKey || e.metaKey)) controller.actionPerformed({
                            action: "CPApplyLayerMask"
                        });
                        else if (selectMask && e.shiftKey && (e.ctrlKey || e.metaKey)) controller.actionPerformed({
                            action: "CPRemoveLayerMask"
                        });
                        else if (e.button === BUTTON_PRIMARY) {
                            if (e.pointerType === "pen" || e.pointerType === "touch") {
                                drag.state = DRAG_STATE_PRE_PAN;
                                drag.initialScrollTop = scrollContainer.scrollTop;
                                if (longPressTimer) clearTimeout(longPressTimer);
                                longPressTimer = setTimeout(()=>{
                                    if (drag.state === DRAG_STATE_PRE_PAN) {
                                        startLayerDrag();
                                        drag.dragY = e.clientY;
                                        updateDropMarker();
                                    }
                                }, LONG_PRESS_INTERVAL);
                            } else drag.state = DRAG_STATE_PRE_DRAG;
                            drag.dropTarget = null;
                            drag.layer = layer;
                            // We might have replaced the layer with a new element due to the CPSetActiveLayer, so fetch that again
                            drag.layerElem = getElemFromDisplayIndex(displayIndex);
                            drag.dragX = e.clientX;
                            drag.dragY = e.clientY;
                            layerContainer.setPointerCapture(e.pointerId);
                            layerContainer.addEventListener("pointermove", onPointerDragged);
                            layerContainer.addEventListener("pointerup", onPointerUp);
                        } else if (e.button === BUTTON_SECONDARY && !layerChanged) {
                            e.preventDefault();
                            showContextMenu(e);
                        }
                    }
                }
            }
        }
        function onPointerUp(e) {
            switch(drag.state){
                case DRAG_STATE_DRAGGING:
                    drag.layerElem.classList.remove("chickenpaint-layer-dragging");
                    if (drag.dropTarget) {
                        if (drag.dropTarget.direction === "inside") controller.actionPerformed({
                            action: "CPRelocateLayer",
                            layer: drag.layer,
                            toGroup: drag.dropTarget.layer,
                            toIndex: drag.dropTarget.layer.layers.length
                        });
                        else controller.actionPerformed({
                            action: "CPRelocateLayer",
                            layer: drag.layer,
                            toGroup: drag.dropTarget.layer.parent,
                            toIndex: drag.dropTarget.layer.parent.indexOf(drag.dropTarget.layer) + (drag.dropTarget.direction === "over" ? 1 : 0)
                        });
                    }
                    drag.dropTarget = null;
                    drag.state = DRAG_STATE_IDLE;
                    updateDropMarker();
                    break;
                default:
                    drag.state = DRAG_STATE_IDLE;
                    break;
            }
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
            layerContainer.releasePointerCapture(e.pointerId);
            layerContainer.removeEventListener("pointermove", onPointerDragged);
            layerContainer.removeEventListener("pointerup", onPointerUp);
        }
        function startLayerDrag() {
            drag.state = DRAG_STATE_DRAGGING;
            drag.frameElem = document.createElement("div");
            drag.frameElem.className = "chickenpaint-layer-drag-frame";
            drag.frameElem.style.width = drag.layerElem.offsetWidth + "px";
            drag.frameElem.style.height = drag.layerElem.offsetHeight + "px";
            drag.dropBetweenMarkerElem = document.createElement("div");
            drag.dropBetweenMarkerElem.className = "chickenpaint-layer-drop-between-mark";
            drag.layerElem.classList.add("chickenpaint-layer-dragging");
            layerContainer.appendChild(drag.frameElem);
        }
        function onPointerDragged(e) {
            let newDragY = e.clientY;
            switch(drag.state){
                case DRAG_STATE_PRE_PAN:
                    if (Math.abs(newDragY - drag.dragY) > LAYER_DRAG_START_THRESHOLD) drag.state = DRAG_STATE_PANNING;
                    else break;
                case DRAG_STATE_PANNING:
                    scrollContainer.scrollTop = drag.initialScrollTop + drag.dragY - newDragY;
                    break;
                case DRAG_STATE_PRE_DRAG:
                    if (Math.abs(newDragY - drag.dragY) > LAYER_DRAG_START_THRESHOLD) startLayerDrag();
                    else break;
                case DRAG_STATE_DRAGGING:
                    drag.dragY = newDragY;
                    updateDropMarker();
                    break;
            }
        }
        /**
         * Rebuild all layer elements from the cached linearizedLayers list
         */ this.buildLayers = function() {
            // Cache the details of the layer structure
            linearizedLayers = artwork.getLayersRoot().getLinearizedLayerList(true);
            let layerElems = linearizedLayers.map((layer, index)=>buildLayer(index, layer)), layerFrag = document.createDocumentFragment();
            layerContainer.innerHTML = ""; // jQuery の empty() を置き換え
            for(let i = layerElems.length - 1; i >= 0; i--)layerFrag.appendChild(layerElems[i]);
            layerContainer.appendChild(layerFrag);
            updateDropMarker();
        };
        /**
         * The properties of the given layer have changed, rebuild it.
         *
         * @param {CPLayer} layer
         */ this.layerChanged = function(layer) {
            let index = getDisplayIndexFromLayer(layer), layerElem = getElemFromDisplayIndex(index);
            if (!layerElem || layer instanceof (0, _cplayerGroupJsDefault.default) && (layer.expanded != layerElem.classList.contains(CLASSNAME_LAYER_GROUP_EXPANDED) || layer.visible != layerElem.classList.contains(CLASSNAME_LAYER_VISIBLE))) // When these properties change, we might have to rebuild the group's children too, so just rebuild everything
            this.buildLayers();
            else layerElem.replaceWith(buildLayer(index, layer));
        };
        function rebuildThumbnailForLayer(layerElem, layer, maskThumb) {
            try {
                const thumbClass = maskThumb ? CLASSNAME_LAYER_MASK_THUMBNAIL : CLASSNAME_LAYER_IMAGE_THUMBNAIL;
                const thumbElement = layerElem.querySelector("." + thumbClass);
                if (thumbElement) thumbElement.replaceWith(maskThumb ? createMaskThumb(layer) : createImageThumb(layer));
            } catch (e) {
                console.log("Error rebuilding thumbnail: ", e);
            }
        }
        /**
         *
         * @param {number} rotation - 90 degree increments
         */ this.setRotation90 = function(rotation) {
            if (imageRotation !== rotation) {
                imageRotation = rotation;
                for(let i = 0; i < linearizedLayers.length; i++){
                    let layer = linearizedLayers[i];
                    let layerElem = getElemFromDisplayIndex(i);
                    if (layerElem) {
                        rebuildThumbnailForLayer(layerElem, layer, false);
                        if (layer.mask) rebuildThumbnailForLayer(layerElem, layer, true);
                    }
                }
            }
        };
        /**
         * The thumbnail of the given layer has been updated.
         *
         * @param {CPImageLayer} layer
         */ this.layerImageThumbChanged = function(layer) {
            let index = getDisplayIndexFromLayer(layer);
            let layerElem = getElemFromDisplayIndex(index);
            if (layerElem) rebuildThumbnailForLayer(layerElem, layer, false);
        };
        this.layerMaskThumbChanged = function(layer) {
            let index = getDisplayIndexFromLayer(layer);
            let layerElem = getElemFromDisplayIndex(index);
            if (layerElem) {
                if (layer.mask) rebuildThumbnailForLayer(layerElem, layer, true);
                else {
                    let maskThumb = layerElem.querySelector("." + CLASSNAME_LAYER_MASK_THUMBNAIL);
                    if (maskThumb) maskThumb.remove();
                }
            }
        };
        /**
         * Call when the selected layer changes.
         *
         * @param {CPLayer} newLayer
         * @param {boolean} maskSelected
         */ this.activeLayerChanged = function(newLayer, maskSelected) {
            let activeLayers = layerContainer.querySelectorAll("." + CLASSNAME_LAYER_ACTIVE);
            activeLayers.forEach((layer)=>{
                layer.classList.remove(CLASSNAME_LAYER_ACTIVE);
            });
            let layerElem = getElemFromDisplayIndex(getDisplayIndexFromLayer(newLayer));
            layerElem.classList.add(CLASSNAME_LAYER_ACTIVE);
            let imageThumb = layerElem.querySelector("." + CLASSNAME_LAYER_IMAGE_THUMBNAIL);
            let maskThumb = layerElem.querySelector("." + CLASSNAME_LAYER_MASK_THUMBNAIL);
            if (imageThumb) imageThumb.classList.toggle("active", !maskSelected);
            if (maskThumb) maskThumb.classList.toggle("active", maskSelected);
        };
        this.resize = function() {
            palette.dismissNotification();
            this.buildLayers();
        };
        this.getElement = function() {
            return widgetContainer;
        };
        /**
         * Scroll the layer widget until the layer with the given index is fully visible, and return
         * the element for that layer.
         *
         * @param {number} displayIndex
         */ this.revealLayer = function(displayIndex) {
            let layerElem = getElemFromDisplayIndex(displayIndex), layerRect = layerElem.getBoundingClientRect(), containerRect = layerContainer.getBoundingClientRect();
            scrollContainer.scrollTop = Math.max(Math.min(Math.max(scrollContainer.scrollTop, // Scroll down to reveal the bottom of the layer
            scrollContainer.scrollTop + layerRect.bottom - containerRect.bottom), scrollContainer.scrollTop + layerRect.top - containerRect.top), 0);
            return layerElem;
        };
        dropdownParent.id = "chickenpaint-layer-pop";
        widgetContainer.className = "chickenpaint-layers-widget";
        widgetContainer.addEventListener("contextmenu", (e)=>e.preventDefault(), true);
        //ドロップダウンメニュー関連項目のコメントアウト
        // dropdownLayerMenu.addEventListener("click", onDropdownActionClick);
        layerContainer.className = "list-group";
        layerContainer.addEventListener("dblclick", onDoubleClick);
        layerContainer.addEventListener("pointerdown", onPointerDown);
        layerContainer.setAttribute("touch-action", "none");
        for (let eventName of [
            "ontouchstart",
            "ontouchmove",
            "ontouchend",
            "ontouchcancel"
        ])layerContainer.addEventListener(eventName, absorbTouch);
        widgetContainer.appendChild(layerContainer);
    }
    function updateAvailableBlendModes() {
        let activeLayer = artwork.getActiveLayer();
        while(blendCombo.lastChild)blendCombo.removeChild(blendCombo.lastChild);
        for(let blendMode = (0, _cpblendJsDefault.default).LM_FIRST; blendMode <= (0, _cpblendJsDefault.default).LM_LAST; blendMode++)if (blendMode != (0, _cpblendJsDefault.default).LM_MULTIPLY2 && (blendMode == activeLayer.blendMode || blendMode === (0, _cpblendJsDefault.default).LM_PASSTHROUGH && activeLayer instanceof (0, _cplayerGroupJsDefault.default) || blendMode <= (0, _cpblendJsDefault.default).LM_LAST_CHIBIPAINT)) {
            let option = document.createElement("option");
            option.appendChild(document.createTextNode((0, _langJs._)((0, _cpblendJsDefault.default).BLEND_MODE_DISPLAY_NAMES[blendMode])));
            // Should we use the new LM_MULTIPLY2 blend mode in this spot instead of the legacy one?
            if (blendMode === (0, _cpblendJsDefault.default).LM_MULTIPLY && activeLayer.blendMode !== blendMode && !activeLayer.useLegacyMultiply) option.value = (0, _cpblendJsDefault.default).LM_MULTIPLY2;
            else option.value = blendMode;
            blendCombo.appendChild(option);
        }
    }
    function createLayerActionButtons() {
        const buttons = [
            {
                title: "Add layer",
                icon: createFontAwesomeIcon("icon-file"),
                action: "CPAddLayer"
            },
            {
                title: "Add group",
                icon: createFontAwesomeIcon("icon-folder"),
                action: "CPAddGroup"
            },
            {
                title: "Merge down",
                icon: createFontAwesomeIcon("icon-download_FILL"),
                action: "CPLayerMergeDown",
                require: [
                    "image-layer"
                ]
            },
            {
                title: "Merge group",
                icon: createFontAwesomeIcon("icon-collapse_all_FILL"),
                action: "CPGroupMerge",
                require: [
                    "layer-group"
                ]
            },
            {
                title: "Clip to the layer below",
                icon: createFontAwesomeIcon("icon-level-down-alt fa-flip-horizontal"),
                action: "CPCreateClippingMask",
                require: "no-clipping-mask-or-is-group"
            },
            {
                title: "Unclip from the layer below",
                icon: createFontAwesomeIcon("icon-level-down-alt fa-flip-horizontal"),
                action: "CPReleaseClippingMask",
                require: "clipping-mask"
            },
            {
                title: "Add layer mask",
                icon: createChickenPaintIcon("mask"),
                action: "CPAddLayerMask",
                require: [
                    "no-mask"
                ]
            },
            {
                title: "Apply mask",
                icon: createChickenPaintIcon("mask"),
                action: "CPApplyLayerMask",
                require: [
                    "mask"
                ]
            },
            {
                title: "Duplicate",
                icon: createFontAwesomeIcon("icon-clone"),
                action: "CPLayerDuplicate"
            },
            {
                title: "Delete layer mask",
                icon: createFontAwesomeIcon("icon-trash"),
                action: "CPRemoveLayerMask",
                require: "isEditingMask"
            },
            {
                title: "Delete layer",
                icon: createFontAwesomeIcon("icon-trash"),
                action: "CPRemoveLayer",
                require: "isNotEditingMask"
            }
        ], layerButtonsList = document.createElement("ul");
        layerButtonsList.className = "chickenpaint-layer-buttons list-unstyled";
        for (let button of buttons){
            let elem = document.createElement("li");
            elem.setAttribute("data-action", button.action);
            elem.className = "chickenpaint-small-toolbar-button " + (button.require ? "chickenpaint-action-require-" + button.require : "");
            elem.title = (0, _langJs._)(button.title);
            elem.appendChild(button.icon);
            elem.addEventListener("click", function() {
                controller.actionPerformed({
                    action: button.action
                });
            });
            layerButtonsList.appendChild(elem);
        }
        return layerButtonsList;
    }
    function updateActiveLayerActionButtons() {
        let activeLayer = artwork.getActiveLayer();
        let isEditingMask = artwork.isEditingMask();
        let facts = computeLayerPredicates(activeLayer, isEditingMask);
        for (let requirement of [
            "mask",
            "no-mask",
            "isEditingMask",
            "isNotEditingMask",
            "clipping-mask",
            "no-clipping-mask-or-is-group",
            "image-layer",
            "layer-group"
        ]){
            let elements = layerActionButtons.getElementsByClassName("chickenpaint-action-require-" + requirement);
            for (let element of elements)element.style.display = facts[requirement] ? "inline-block" : "none";
        }
        let actions = layerActionButtons.querySelectorAll("[data-action]");
        actions.forEach(function(element) {
            let action = element.getAttribute("data-action");
            element.classList.toggle("disabled", !controller.isActionAllowed(action));
        });
    }
    function updateActiveLayerControls() {
        let activeLayer = artwork.getActiveLayer();
        if (activeLayer.getAlpha() != alphaSlider.value) alphaSlider.setValue(activeLayer.getAlpha());
        updateAvailableBlendModes();
        if (activeLayer.getBlendMode() != parseInt(blendCombo.value, 10)) blendCombo.value = activeLayer.getBlendMode();
        if (activeLayer.getLockAlpha() != cbLockAlpha.checked) cbLockAlpha.checked = activeLayer.getLockAlpha();
        updateActiveLayerActionButtons();
    }
    /**
     * Called when a layer has been added/removed.
     */ function onChangeStructure() {
        artwork = this;
        // Fetch and rebuild all layers
        layerWidget.resize();
        updateActiveLayerControls();
    }
    /**
     * Called when the properties of one layer has been updated and we should rebuild/repaint it.
     *
     * @param {CPLayer} layer
     */ function onChangeLayer(layer) {
        artwork = this;
        palette.dismissNotification();
        layerWidget.layerChanged(layer);
        updateActiveLayerControls();
    }
    /**
     * Called when the thumbnail of one layer has been updated.
     *
     * @param {CPLayer} layer
     */ function onChangeLayerImageThumb(layer) {
        artwork = this;
        layerWidget.layerImageThumbChanged(layer);
    }
    /**
     * Called when the thumbnail of one layer has been updated.
     *
     * @param {CPLayer} layer
     */ function onChangeLayerMaskThumb(layer) {
        artwork = this;
        layerWidget.layerMaskThumbChanged(layer);
    }
    /**
     * Called when the selected layer changes.
     *
     * @param {CPLayer} oldLayer
     * @param {CPLayer} newLayer
     * @param {boolean} maskSelected
     */ function onChangeActiveLayer(oldLayer, newLayer, maskSelected) {
        layerWidget.activeLayerChanged(newLayer, maskSelected);
        updateActiveLayerControls();
    }
    function CPRenameField() {
        let layer = null, origName = "", textBox = document.createElement("input"), that = this;
        // 隠すメソッド
        this.hide = function() {
            layer = null;
            let parentNameElem = textBox.parentNode;
            // 親ノードが存在する時は、テキストボックスを削除して、レイヤー名を表示
            if (parentNameElem) {
                parentNameElem.removeChild(textBox);
                parentNameElem.textContent = origName;
            }
        };
        // 名前の変更とhide
        this.renameAndHide = function() {
            if (layer && layer.name !== textBox.value) // 名前が変更されている時
            controller.actionPerformed({
                action: "CPSetLayerName",
                layer: layer,
                name: textBox.value
            });
            this.hide();
        };
        // レイヤー名変更のテキストボックスを表示
        this.show = function(_layer, _layerElem) {
            layer = _layer;
            origName = layer.name;
            // 元のレイヤー名をテキストボックスにセット
            textBox.value = origName;
            let layerNameElem = _layerElem.querySelector(".chickenpaint-layer-name");
            if (layerNameElem) // 親ノードから削除されている場合にのみ処理を実行
            {
                if (layerNameElem.parentNode) {
                    // 現在の子ノードを取得
                    let currentChild = layerNameElem.firstChild;
                    // テキストノードが存在する場合にのみ削除
                    if (currentChild && currentChild.nodeType === Node.TEXT_NODE) {
                        layerNameElem.removeChild(currentChild);
                        // テキストボックスを親ノードに追加
                        layerNameElem.appendChild(textBox);
                    }
                }
            }
            // 入力ボックスを選択状態にする
            textBox.select();
        };
        // テキストボックスの設定
        textBox.type = "text";
        textBox.className = "chickenpaint-layer-rename form-control input-sm";
        // キーが押されたときにイベントを停止
        textBox.addEventListener("keydown", function(e) {
            // Prevent other keyhandlers (CPCanvas) from getting their grubby hands on the input
            e.stopPropagation();
        });
        // エンターキーを押した時に名前変更と隠す処理を実行
        textBox.addEventListener("keydown", function(e) {
            if (e.key === "Enter") that.renameAndHide();
            e.stopPropagation();
        });
        // エスケープキーを押した時にhide
        textBox.addEventListener("keyup", function(e) {
            if (e.key === "Escape") // Escape
            that.hide();
            e.stopPropagation();
        });
        // 入力ボックスがフォーカスを失った時に名前変更処理を実行
        textBox.addEventListener("blur", function(e) {
            if (layer) that.renameAndHide();
        });
    }
    let parentSetSize = this.setSize, parentSetWidth = this.setWidth, parentSetHeight = this.setHeight;
    // サイズを変更するメソッド
    this.setSize = function(w, h) {
        parentSetSize.call(this, w, h);
        this.dismissNotification();
        alphaSlider.resize();
    };
    // 幅を変更するメソッド
    this.setWidth = function(width) {
        parentSetWidth.call(this, width);
        alphaSlider.resize();
        layerWidget.resize();
    };
    // 高さを変更するメソッド
    this.setHeight = function(height) {
        parentSetHeight.call(this, height);
        layerWidget.resize();
    };
    /**
     * Set the rotation of the image thumbnails with respect to the underlying image data.
     *
     * @param {number} newRotation - 90 degree increments
     */ this.setRotation90 = function(newRotation) {
        layerWidget.setRotation90(newRotation);
    };
    /**
     * Dismiss any active notifications or popovers.
     */ this.dismissNotification = function() {
        const elements = document.querySelectorAll(".chickenpaint-layer[aria-describedby], .chickenpaint-slider[aria-describedby]");
        elements.forEach((elem)=>{
            const popoverInstance = _bootstrapBundleMinJs.Popover.getInstance(elem);
            if (popoverInstance) popoverInstance.dispose();
        });
        if (notificationDismissTimer) {
            clearTimeout(notificationDismissTimer);
            notificationDismissTimer = false;
        }
    };
    /**
     * Show a notification for a specific layer with a message.
     *
     * @param {CPLayer} layer - The layer for which the notification is shown
     * @param {string} message - The message to display in the notification
     * @param {string} where - The location for the notification (e.g., "opacity")
     */ this.showNotification = (layer, message, where)=>{
        let notificationLayerIndex = getDisplayIndexFromLayer(layer), target;
        if (artwork.getActiveLayer() == layer && where == "opacity") target = alphaSlider.getElement();
        else target = layerWidget.revealLayer(notificationLayerIndex);
        this.dismissNotification();
        const popoverInstance = new _bootstrapBundleMinJs.Popover(target, {
            html: false,
            content: message,
            placement: "left",
            trigger: "manual",
            fallbackPlacement: [],
            boundary: "window",
            container: palette.getElement()
        });
        popoverInstance.show();
        notificationDismissTimer = setTimeout(()=>{
            notificationDismissTimer = false;
            this.dismissNotification();
        }, Math.max(Math.round(message.length * NOTIFICATION_HIDE_DELAY_MS_PER_CHAR), NOTIFICATION_HIDE_DELAY_MIN));
    };
    // 合成方法のセレクトメニュー
    blendCombo.className = "form-control form-control-sm";
    blendCombo.tabIndex = -1;
    blendCombo.title = (0, _langJs._)("Layer blending mode");
    blendCombo.addEventListener("change", function(e) {
        controller.actionPerformed({
            action: "CPSetLayerBlendMode",
            blendMode: parseInt(blendCombo.value, 10)
        });
        blendCombo.blur();
    });
    body.appendChild(blendCombo);
    // 不透明度のスライダー
    alphaSlider.title = function(value) {
        return (0, _langJs._)("Opacity") + ": " + value + "%";
    };
    alphaSlider.on("valueChange", function(value) {
        controller.actionPerformed({
            action: "CPSetLayerAlpha",
            alpha: value
        });
    });
    body.appendChild(alphaSlider.getElement());
    // SampleAllLayersのチェックボックスの設定を取得
    cbSampleAllLayers.id = "chickenpaint-chk-sample-all-layers";
    cbSampleAllLayers.type = "checkbox";
    cbSampleAllLayers.addEventListener("click", function(e) {
        artwork.setSampleAllLayers(cbSampleAllLayers.checked);
        document.activeElement.blur();
    });
    body.appendChild(wrapBootstrapCheckbox(cbSampleAllLayers, (0, _langJs._)("Sample all layers")));
    // 透明度をロックのチェックボックスの設定を取得
    cbLockAlpha.id = "chickenpaint-chk-lock-alpha";
    cbLockAlpha.type = "checkbox";
    cbLockAlpha.addEventListener("click", function(e) {
        controller.actionPerformed({
            action: "CPSetLayerLockAlpha",
            lock: cbLockAlpha.checked
        });
        document.activeElement.blur();
    });
    body.appendChild(wrapBootstrapCheckbox(cbLockAlpha, (0, _langJs._)("Lock transparency")));
    body.appendChild(layerWidget.getElement());
    // レイヤーアクションボタンを追加
    layerActionButtons = createLayerActionButtons();
    body.appendChild(layerActionButtons);
    // イベントリスナー登録
    artwork.on("changeActiveLayer", onChangeActiveLayer);
    artwork.on("changeLayer", onChangeLayer);
    artwork.on("changeStructure", onChangeStructure);
    artwork.on("changeLayerMaskThumb", onChangeLayerMaskThumb);
    artwork.on("changeLayerImageThumb", onChangeLayerImageThumb);
    controller.on("layerNotification", this.showNotification.bind(this));
    // Set initial values
    onChangeStructure.call(artwork);
}
// CPLayersPaletteのプロトタイプをCPPaletteのプロトタイプから継承
CPLayersPalette.prototype = Object.create((0, _cppaletteJsDefault.default).prototype);
// コンストラクタをCPLayersPaletteに設定
CPLayersPalette.prototype.constructor = CPLayersPalette;

},{"bootstrap/dist/js/bootstrap.bundle.min.js":"joWv1","./CPPalette.js":"2mLTE","../engine/CPBlend.js":"k5HfA","./CPSlider.js":"3GYON","../engine/CPLayerGroup.js":"k5mD3","../engine/CPLayer.js":"1fr05","../engine/CPImageLayer.js":"93gOf","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dIkNA":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPTexturePalette);
var _bootstrapBundleMinJs = require("bootstrap/dist/js/bootstrap.bundle.min.js");
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
var _cpgreyBmpJs = require("../engine/CPGreyBmp.js");
var _cpgreyBmpJsDefault = parcelHelpers.interopDefault(_cpgreyBmpJs);
var _cplookUpTableJs = require("../engine/CPLookUpTable.js");
var _cplookUpTableJsDefault = parcelHelpers.interopDefault(_cplookUpTableJs);
var _cppaletteJs = require("./CPPalette.js");
var _cppaletteJsDefault = parcelHelpers.interopDefault(_cppaletteJs);
var _cpsliderJs = require("./CPSlider.js");
var _cpsliderJsDefault = parcelHelpers.interopDefault(_cpsliderJs);
var _langJs = require("../languages/lang.js");
/**
 *
 * @param {HTMLInputElement} checkbox - Must have a unique ID set
 * @param {string} title
 *
 * @returns {HTMLElement}
 */ function wrapBootstrapCheckbox(checkbox, title) {
    let div = document.createElement("div"), label = document.createElement("label");
    div.className = "form-check";
    checkbox.className = "form-check-input";
    label.className = "form-check-label";
    label.setAttribute("for", checkbox.id);
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(title));
    div.appendChild(checkbox);
    div.appendChild(label);
    return div;
}
function loadTextures(textureFilename, width, height, textureCount, then) {
    let img = new Image(), textures = [];
    img.onload = function() {
        let canvas = document.createElement("canvas"), canvasContext = canvas.getContext("2d", {
            willReadFrequently: true
        });
        canvas.width = img.width;
        canvas.height = img.height;
        for(let i = 0; i < textureCount; i++){
            canvasContext.drawImage(img, 0, i * height, width, height, 0, 0, width, height);
            try {
                let imageData = canvasContext.getImageData(0, 0, width, height), texture = new (0, _cpgreyBmpJsDefault.default)(width, height, 8);
                // Take just the red channel from the image to form the new grayscale texture
                for(let j = 0; j < width * height; j++)texture.data[j] = imageData.data[j * 4];
                textures.push(texture);
            } catch (e) {
                // Quietly ignore errors that occur while loading the image (e.g. cross-origin security failures)
                console.log(e);
            }
        }
        then(textures);
    };
    img.src = textureFilename;
}
function CPTexturePalette(controller) {
    (0, _cppaletteJsDefault.default).call(this, controller, "textures", "Textures");
    let TEXTURE_PREVIEW_SIZE = 64, TEXTURE_SWATCH_BUTTON_SIZE = 32, /**
         * @type {CPGreyBmp}
         */ selectedTexture, /**
         * @type {CPGreyBmp}
         */ processedTexture, mirror = false, inverse = false, brightness = 0.0, contrast = 0.0, optionsPanel, texturesPanel = document.createElement("div"), body = this.getBodyElement();
    /**
     * Add an array of textures to the global texture list, and add swatches for them to the UI.
     */ function addTextures(newTextures) {
        for(let i = 0; i < newTextures.length; i++){
            let texture = newTextures[i], button = new CPTextureSwatch(texture, TEXTURE_SWATCH_BUTTON_SIZE, TEXTURE_SWATCH_BUTTON_SIZE);
            button.on("click", function() {
                selectedTexture = this.texture;
                updateSelectedTexture();
            });
            texturesPanel.appendChild(button.getElement());
        }
    }
    /**
     * Generate and return an array of procedurally-generated textures
     * 
     * @returns CPGreyBmp[]
     */ function makeProceduralTextures() {
        let result = [
            null
        ];
        let texture = new (0, _cpgreyBmpJsDefault.default)(2, 2, 8);
        texture.data[0] = 0xFF;
        texture.data[3] = 0xFF;
        result.push(texture);
        result.push(makeDotTexture(2));
        result.push(makeDotTexture(3));
        result.push(makeDotTexture(4));
        result.push(makeDotTexture(6));
        result.push(makeDotTexture(8));
        result.push(makeVertLinesTexture(1, 2));
        result.push(makeVertLinesTexture(2, 4));
        result.push(makeHorizLinesTexture(1, 2));
        result.push(makeHorizLinesTexture(2, 4));
        result.push(makeCheckerBoardTexture(2));
        result.push(makeCheckerBoardTexture(4));
        result.push(makeCheckerBoardTexture(8));
        result.push(makeCheckerBoardTexture(16));
        result.push(makeNoiseTexture(256));
        return result;
    }
    /**
     * @param size int
     * 
     * @returns CPGreyBmp
     */ function makeDotTexture(size) {
        let texture = new (0, _cpgreyBmpJsDefault.default)(size, size, 8);
        for(let i = 1; i < size * size; i++)texture.data[i] = 0xFF;
        return texture;
    }
    /**
     * Make a checkerboard texture of the given dimensions.
     * 
     * @param size int
     * 
     * @returns CPGreyBmp
     */ function makeCheckerBoardTexture(size) {
        let textureSize = 2 * size, texture = new (0, _cpgreyBmpJsDefault.default)(textureSize, textureSize, 8);
        for(let i = 0; i < textureSize; i++)for(let j = 0; j < textureSize; j++)texture.data[i + j * textureSize] = (~~(i / size) + ~~(j / size)) % 2 == 0 ? 0 : 0xFF;
        return texture;
    }
    /**
      * Make a texture consisting of a series of evenly-spaced vertical lines
      * 
      * @param lineSize int
      * @param size int
      * 
      * @returns CPGreyBmp
      */ function makeVertLinesTexture(lineSize, size) {
        let texture = new (0, _cpgreyBmpJsDefault.default)(size, size, 8);
        for(let i = 0; i < size * size; i++)if (~~(i % size) >= lineSize) texture.data[i] = 0xFF;
        return texture;
    }
    /**
      * Make a texture consisting of a series of evenly-spaced horizontal lines
      *
      * @param lineSize int
      * @param size int
      * 
      * @returns CPGreyBmp
      */ function makeHorizLinesTexture(lineSize, size) {
        let texture = new (0, _cpgreyBmpJsDefault.default)(size, size, 8);
        for(let i = 0; i < size * size; i++)if (i / size >= lineSize) texture.data[i] = 0xFF;
        return texture;
    }
    /**
     * Make a texture consisting of random noise with adjusted brightness and contrast
     * 
     * @param {number} size - The width and height of the square texture (e.g., 32 for a 32x32 texture)
     * @param {number} brightnessFactor - A multiplier for brightness (0.0 to 1.0)
     * @param {number} contrastFactor - A multiplier for contrast (0.0 to 1.0)
     * 
     * @returns {CPGreyBmp} - A grayscale bitmap filled with random noise and adjusted brightness/contrast
     */ function makeNoiseTexture(size) {
        const brightnessFactor = 0.65;
        const contrastFactor = 0.65;
        let texture = new (0, _cpgreyBmpJsDefault.default)(size, size, 8);
        for(let i = 0; i < size * size; i++){
            // ランダムなノイズ（0から255まで）
            let noiseValue = Math.floor(Math.random() * 256);
            // 輝度を調整
            let adjustedBrightness = noiseValue * brightnessFactor;
            // コントラストを調整
            let adjustedContrast = (adjustedBrightness - 128) * contrastFactor + 128;
            // テクスチャデータに反映
            texture.data[i] = Math.max(0, Math.min(255, Math.floor(adjustedContrast)));
        }
        return texture;
    }
    function updateSelectedTexture() {
        if (selectedTexture != null) {
            processedTexture = selectedTexture.clone();
            if (mirror) processedTexture.mirrorHorizontally();
            let lut = new (0, _cplookUpTableJsDefault.default)();
            lut.loadBrightnessContrast(brightness, contrast);
            if (inverse) lut.invert();
            processedTexture.applyLUT(lut);
        } else processedTexture = null;
        controller.getArtwork().setBrushTexture(processedTexture);
        if (optionsPanel != null) optionsPanel.updateTexture();
    }
    function CPTextureOptionsPanel() {
        let panel = document.createElement("div"), cbInverse = document.createElement("input"), cbMirror = document.createElement("input"), slBrightness = new (0, _cpsliderJsDefault.default)(0, 200, true), slContrast = new (0, _cpsliderJsDefault.default)(0, 200, true), sampleSwatch = new CPTextureSwatch(null, TEXTURE_PREVIEW_SIZE, TEXTURE_PREVIEW_SIZE), btnCustomize = document.createElement("button"), textureControlsPanel;
        // Bootstrap Popover インスタンス
        const bootstrapPopover = new _bootstrapBundleMinJs.Popover(btnCustomize, {
            html: true,
            content: ()=>textureControlsPanel,
            trigger: "manual",
            placement: "right",
            container: body
        });
        function updatePopoverControls() {
            cbInverse.checked = inverse;
            cbMirror.checked = mirror;
            slBrightness.setValue(brightness * 100 + 100);
            slContrast.setValue(contrast * 100 + 100);
        }
        function buildTextureControlsPanel() {
            let panel = document.createElement("div");
            panel.className = "chickenpaint-texture-controls";
            cbInverse.id = "chickenpaint-chk-texture-invert";
            cbInverse.type = "checkbox";
            cbInverse.addEventListener("click", function(e) {
                inverse = this.checked;
                updateSelectedTexture();
            });
            panel.appendChild(wrapBootstrapCheckbox(cbInverse, (0, _langJs._)("Inverse")));
            cbMirror.id = "chickenpaint-chk-texture-mirror";
            cbMirror.type = "checkbox";
            cbMirror.addEventListener("click", function(e) {
                mirror = this.checked;
                updateSelectedTexture();
            });
            panel.appendChild(wrapBootstrapCheckbox(cbMirror, (0, _langJs._)("Mirror")));
            slBrightness.title = function(value) {
                return (0, _langJs._)("Brightness") + ": " + (value - 100) + "%";
            };
            slBrightness.on("valueChange", function(value) {
                brightness = (value - 100) / 100.0;
                updateSelectedTexture();
            });
            panel.appendChild(slBrightness.getElement());
            slContrast.title = function(value) {
                return (0, _langJs._)("Contrast") + ": " + (value - 100) + "%";
            };
            slContrast.on("valueChange", function(value) {
                contrast = (value - 100) / 100;
                updateSelectedTexture();
            });
            panel.appendChild(slContrast.getElement());
            let okayButton = document.createElement("button"), resetButton = document.createElement("button");
            okayButton.textContent = "Ok";
            okayButton.className = "btn btn-primary btn-sm";
            okayButton.type = "button";
            okayButton.addEventListener("click", function(e) {
                bootstrapPopover.hide();
            });
            panel.appendChild(okayButton);
            panel.appendChild(document.createTextNode(" "));
            resetButton.textContent = "Reset";
            resetButton.className = "btn btn-secondary btn-sm";
            resetButton.type = "button";
            resetButton.addEventListener("click", function(e) {
                brightness = 0;
                contrast = 0;
                mirror = false;
                inverse = false;
                updatePopoverControls();
                updateSelectedTexture();
            });
            panel.appendChild(resetButton);
            updatePopoverControls();
            return panel;
        }
        // TODO use events instead
        this.updateTexture = function() {
            btnCustomize.disabled = processedTexture == null;
            sampleSwatch.setTexture(processedTexture);
        };
        this.getElement = function() {
            return panel;
        };
        panel.className = "chickenpaint-texture-options";
        panel.appendChild(sampleSwatch.getElement());
        btnCustomize.type = "button";
        btnCustomize.className = "btn btn-light btn-sm";
        btnCustomize.setAttribute("data-bs-toggle", "popover");
        btnCustomize.setAttribute("data-bs-placement", "right");
        btnCustomize.textContent = (0, _langJs._)("Customize");
        textureControlsPanel = buildTextureControlsPanel();
        btnCustomize.addEventListener("click", function() {
            bootstrapPopover.toggle();
        });
        panel.appendChild(btnCustomize);
        this.updateTexture();
    }
    /**
     *
     * @param {CPGreyBmp} texture
     * @param {number} width
     * @param {number} height
     * @constructor
     */ function CPTextureSwatch(texture, width, height) {
        let canvas = document.createElement("canvas"), canvasContext = canvas.getContext("2d"), that = this;
        /**
         * @param {CPGreyBmp} texture
         */ this.setTexture = function(texture) {
            this.texture = texture;
            this.paint();
        };
        this.getElement = function() {
            return canvas;
        };
        this.paint = function() {
            if (this.texture != null) canvasContext.fillStyle = canvasContext.createPattern(this.texture.getAsCanvas(), "repeat");
            else canvasContext.fillStyle = 'white';
            canvasContext.fillRect(0, 0, canvas.width, canvas.height);
        };
        canvas.addEventListener("click", function() {
            that.emit("click");
        });
        canvas.width = width;
        canvas.height = height;
        this.setTexture(texture);
    }
    CPTextureSwatch.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
    CPTextureSwatch.prototype.constructor = CPTextureSwatch;
    optionsPanel = new CPTextureOptionsPanel();
    body.appendChild(optionsPanel.getElement());
    texturesPanel.className = 'chickenpaint-texture-swatches';
    body.appendChild(texturesPanel);
    addTextures(makeProceduralTextures());
    loadTextures(controller.getResourcesRoot() + "gfx/textures32.png?20241024.1", 32, 32, 2, function(loadedTextures) {
        addTextures(loadedTextures);
    });
}
CPTexturePalette.prototype = Object.create((0, _cppaletteJsDefault.default).prototype);
CPTexturePalette.prototype.constructor = CPTexturePalette;

},{"bootstrap/dist/js/bootstrap.bundle.min.js":"joWv1","wolfy87-eventemitter":"gPUo0","../engine/CPGreyBmp.js":"fGKWG","../engine/CPLookUpTable.js":"fofFt","./CPPalette.js":"2mLTE","./CPSlider.js":"3GYON","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fofFt":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPLookUpTable);
function CPLookUpTable() {
    this.table = new Uint8Array(256);
    this.loadIdentity = function() {
        for(var i = 0; i < 256; i++)this.table[i] = i;
    };
    this.loadBrightnessContrast = function(brightness, contrast) {
        var slope = contrast > 0.0 ? 1.0 / (1.0001 - contrast) : 1.0 + contrast, offset = 0.5 - slope * 0.5 + brightness;
        for(var i = 0; i < 256; i++){
            var x = i / 255.0, y = x * slope + offset;
            this.table[i] = Math.min(255, Math.max(~~(y * 255.0), 0));
        }
    };
    this.invert = function() {
        for(var i = 0; i < 256; i++)this.table[i] = 255 - this.table[i];
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hnCVa":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPSwatchesPalette);
var _bootstrapBundleMinJs = require("bootstrap/dist/js/bootstrap.bundle.min.js");
var _fileSaver = require("file-saver");
var _fileSaverDefault = parcelHelpers.interopDefault(_fileSaver);
var _cppaletteJs = require("./CPPalette.js");
var _cppaletteJsDefault = parcelHelpers.interopDefault(_cppaletteJs);
var _cpcolorJs = require("../util/CPColor.js");
var _cpcolorJsDefault = parcelHelpers.interopDefault(_cpcolorJs);
var _adobeColorTableJs = require("../util/AdobeColorTable.js");
var _adobeColorTableJsDefault = parcelHelpers.interopDefault(_adobeColorTableJs);
var _langJs = require("../languages/lang.js");
function padLeft(string, padding, len) {
    while(string.length < len)string = padding + string;
    return string;
}
function fileAPIsSupported() {
    return window.File && window.FileReader && window.FileList && window.Blob;
}
function CPSwatchesPalette(controller) {
    (0, _cppaletteJsDefault.default).call(this, controller, "swatches", "Color swatches");
    let INIT_COLORS = [
        0xffffff,
        0x000000,
        0xff0000,
        0x00ff00,
        0x0000ff,
        0xffff00
    ], modified = false, swatchPanel = document.createElement("ul"), buttonPanel = document.createElement("div"), fileInput, that = this;
    function CPColorSwatch(color) {
        let wrapper = document.createElement("div"), swatchElem = document.createElement("a"), swatchMenu = document.createElement("ul"), mnuRemove = document.createElement("a"), mnuSetToCurrent = document.createElement("a"), that = this;
        this.getElement = function() {
            return wrapper;
        };
        this.setColor = function(color) {
            swatchElem.setAttribute("data-color", color);
            swatchElem.style.backgroundColor = "#" + padLeft("" + Number(color).toString(16), "0", 6);
        };
        this.setColor(color);
        swatchElem.href = "#";
        swatchElem.className = "chickenpaint-color-swatch dropdown-toggle";
        //"data-bs-toggle"に設定しない
        // swatchElem.setAttribute("data-bs-toggle", "dropdown");
        mnuRemove.className = "dropdown-item";
        mnuRemove.href = "#";
        mnuRemove.textContent = (0, _langJs._)("Remove");
        mnuRemove.addEventListener("click", function(e) {
            e.preventDefault();
            wrapper.remove();
            modified = true;
        });
        mnuSetToCurrent.className = "dropdown-item";
        mnuSetToCurrent.href = "#";
        mnuSetToCurrent.textContent = (0, _langJs._)("Replace with current color");
        mnuSetToCurrent.addEventListener("click", function(e) {
            e.preventDefault();
            that.setColor(controller.getCurColor().getRgb());
            modified = true;
        });
        swatchMenu.className = "dropdown-menu";
        let liRemove = document.createElement("li");
        let liSetToCurrent = document.createElement("li");
        liRemove.appendChild(mnuRemove); //liで囲う
        liSetToCurrent.appendChild(mnuSetToCurrent); //liで囲う
        swatchMenu.appendChild(liRemove);
        swatchMenu.appendChild(liSetToCurrent);
        wrapper.className = "chickenpaint-color-swatch-wrapper";
        wrapper.appendChild(swatchElem);
        wrapper.appendChild(swatchMenu);
    }
    function clearSwatches() {
        while(swatchPanel.lastChild)swatchPanel.removeChild(swatchPanel.lastChild);
    }
    function addSwatch(color) {
        let swatch = new CPColorSwatch(color);
        swatchPanel.appendChild(swatch.getElement());
    }
    /**
     * Returns an array of colors in RGB 32-bit integer format
     */ this.getSwatches = function() {
        let swatches = swatchPanel.querySelectorAll(".chickenpaint-color-swatch");
        let colors = new Array(swatches.length);
        for(let i = 0; i < swatches.length; i++)colors[i] = parseInt(swatches[i].getAttribute("data-color"), 10);
        return colors;
    };
    this.setSwatches = function(swatches) {
        clearSwatches();
        for(let i = 0; i < swatches.length; i++)addSwatch(swatches[i]);
        modified = true;
    };
    this.isModified = function() {
        return modified;
    };
    function loadSwatches() {
        fileInput.onchange = function() {
            let fileList = this.files;
            if (fileList.length < 1) return;
            let file = fileList[0], reader = new FileReader();
            reader.onload = function() {
                let swatches = new (0, _adobeColorTableJsDefault.default)().read(this.result);
                if (swatches != null && swatches.length > 0) that.setSwatches(swatches);
                else alert((0, _langJs._)("The swatches could not be read, did you select an .aco file?"));
            };
            reader.readAsArrayBuffer(file);
        };
        fileInput.click();
    }
    function saveSwatches() {
        let aco = new (0, _adobeColorTableJsDefault.default)().write(that.getSwatches()), blob = new Blob([
            aco
        ], {
            type: "application/octet-stream"
        });
        (0, _fileSaverDefault.default).saveAs(blob, "oekakiswatches.aco");
    }
    function initSwatchPanel() {
        swatchPanel.className = "chickenpaint-color-swatches list-unstyled";
        for(let i = 0; i < INIT_COLORS.length; i++)swatchPanel.appendChild(new CPColorSwatch(INIT_COLORS[i]).getElement());
        swatchPanel.addEventListener("click", function(e) {
            let swatch = e.target;
            if (!/^<a data-color=/i.test(swatch.outerHTML) || !/chickenpaint-color-swatch/.test(swatch.className)) return; //<a data-color=で始まらない場合もreturn
            if (e.button == 0 /* Left */  && swatch.getAttribute("data-color") !== undefined) {
                controller.setCurColor(new (0, _cpcolorJsDefault.default)(parseInt(swatch.getAttribute("data-color"), 10)));
                e.stopPropagation();
                e.preventDefault();
            // that.userIsDoneWithUs();
            //ボタンクリック時にパレットを折りたたむ機能を削除
            }
        });
        swatchPanel.addEventListener("contextmenu", function(e) {
            let swatch = e.target;
            if (!/^<a data-color=/i.test(swatch.outerHTML) || !/chickenpaint-color-swatch/.test(swatch.className)) return; //<a data-color=で始まらない場合もreturn
            e.preventDefault();
            var dropdown = new _bootstrapBundleMinJs.Dropdown(swatch); // Bootstrap 5: ドロップダウンを初期化
            dropdown.toggle();
            // ドロップダウンメニュー内のクリックを検出して、メニューを閉じる
            document.addEventListener("click", function onDocumentClick(event) {
                dropdown.hide();
                document.removeEventListener("click", onDocumentClick);
            });
        });
    }
    function createIcon(iconName) {
        let icon = document.createElement("span");
        icon.className = "fa icon-" + iconName;
        return icon;
    }
    function initButtonsPanel() {
        let btnSettings = document.createElement("button"), btnAdd = document.createElement("button"), settingsMenu = document.createElement("ul"), mnuSave = document.createElement("a"), mnuLoad = document.createElement("a");
        btnAdd.type = "button";
        btnAdd.title = (0, _langJs._)("Add the current brush color as a new swatch");
        btnAdd.className = "btn chickenpaint-small-toolbar-button chickenpaint-color-swatch-add";
        btnAdd.appendChild(createIcon("plus"));
        btnSettings.type = "button";
        btnSettings.className = "btn dropdown-toggle chickenpaint-small-toolbar-button chickenpaint-color-swatch-settings";
        //"data-bs-toggle"に設定 bs5
        btnSettings.setAttribute("data-bs-toggle", "dropdown");
        btnSettings.appendChild(createIcon("cog"));
        mnuSave.className = "dropdown-item";
        mnuSave.href = "#";
        mnuSave.textContent = (0, _langJs._)("Save swatches to your computer...");
        mnuSave.addEventListener("click", function(e) {
            e.preventDefault();
            saveSwatches();
        });
        mnuLoad.className = "dropdown-item";
        mnuLoad.href = "#";
        mnuLoad.textContent = (0, _langJs._)("Load swatches from your computer...");
        mnuLoad.addEventListener("click", function(e) {
            e.preventDefault();
            loadSwatches();
        });
        settingsMenu.className = "dropdown-menu";
        let limnuSave = document.createElement("li");
        let limnuLoad = document.createElement("li");
        limnuSave.appendChild(mnuSave); //liで囲う
        limnuLoad.appendChild(mnuLoad); //liで囲う
        settingsMenu.appendChild(limnuSave);
        settingsMenu.appendChild(limnuLoad);
        let btnSettingsContainer = document.createElement("div");
        btnSettingsContainer.className = "btn-group";
        btnSettingsContainer.appendChild(btnSettings);
        btnSettingsContainer.appendChild(settingsMenu);
        btnAdd.addEventListener("click", function(e) {
            addSwatch(controller.getCurColor().getRgb());
            modified = true;
        });
        buttonPanel.className = "chickenpaint-color-swatches-buttons";
        // Don't offer to load/save swatches if we don't have the file API needed for reading them
        if (fileAPIsSupported()) {
            fileInput = document.createElement("input");
            fileInput.type = "file";
            fileInput.multiple = false;
            fileInput.style.display = "none";
            buttonPanel.appendChild(btnSettingsContainer);
            buttonPanel.appendChild(fileInput);
        }
        buttonPanel.appendChild(btnAdd);
    }
    initSwatchPanel();
    this.getBodyElement().appendChild(swatchPanel);
    initButtonsPanel();
    this.getBodyElement().appendChild(buttonPanel);
}
CPSwatchesPalette.prototype = Object.create((0, _cppaletteJsDefault.default).prototype);
CPSwatchesPalette.prototype.constructor = CPSwatchesPalette;

},{"bootstrap/dist/js/bootstrap.bundle.min.js":"joWv1","file-saver":"apCnQ","./CPPalette.js":"2mLTE","../util/CPColor.js":"ioCeM","../util/AdobeColorTable.js":"lWtyz","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"yJXzu":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPMainMenu);
var _keymasterJs = require("../../lib/keymaster.js");
var _keymasterJsDefault = parcelHelpers.interopDefault(_keymasterJs);
var _langJs = require("../languages/lang.js");
const MENU_ENTRIES = [
    {
        name: "File",
        mnemonic: "F",
        children: [
            {
                name: "Save to my computer",
                action: "CPSave",
                mnemonic: "S",
                shortcut: "ctrl+s"
            },
            {
                name: "Save Oekaki",
                action: "CPSend",
                mnemonic: "S",
                shortcut: "ctrl+s"
            }
        ]
    },
    {
        name: "Edit",
        mnemonic: "E",
        children: [
            {
                name: "Undo",
                action: "CPUndo",
                mnemonic: "U",
                shortcut: "ctrl+z"
            },
            {
                name: "Redo",
                action: "CPRedo",
                mnemonic: "R",
                shortcut: "ctrl+y"
            },
            {
                name: "Clear history",
                action: "CPClearHistory",
                mnemonic: "H",
                title: (0, _langJs._)("Removes all undo/redo information to regain memory")
            },
            {
                name: "-"
            },
            {
                name: "Cut",
                action: "CPCut",
                mnemonic: "T",
                shortcut: "ctrl+x"
            },
            {
                name: "Copy",
                action: "CPCopy",
                mnemonic: "C",
                shortcut: "ctrl+c"
            },
            {
                name: "Copy merged",
                action: "CPCopyMerged",
                mnemonic: "Y",
                shortcut: "shift+ctrl+c"
            },
            {
                name: "Paste",
                action: "CPPaste",
                mnemonic: "P",
                shortcut: "ctrl+v"
            },
            {
                name: "-"
            },
            {
                name: "Select all",
                action: "CPSelectAll",
                mnemonic: "A",
                shortcut: "ctrl+a"
            },
            {
                name: "Deselect",
                action: "CPDeselectAll",
                mnemonic: "D",
                shortcut: "ctrl+d"
            },
            {
                name: "-"
            },
            {
                name: "Transform",
                action: "CPTransform",
                mnemonic: "T",
                shortcut: "ctrl+h"
            }
        ]
    },
    {
        name: "Layers",
        mnemonic: "L",
        children: [
            {
                name: "Duplicate",
                action: "CPLayerDuplicate",
                mnemonic: "D",
                shortcut: "shift+ctrl+d"
            },
            {
                name: "-"
            },
            {
                name: "Merge down",
                action: "CPLayerMergeDown",
                mnemonic: "E",
                shortcut: "ctrl+e"
            },
            {
                name: "Merge group",
                action: "CPGroupMerge",
                mnemonic: "G",
                shortcut: "shift+ctrl+g"
            },
            {
                name: "Merge all layers",
                action: "CPLayerMergeAll",
                shortcut: "shift+ctrl+e",
                mnemonic: "A"
            },
            {
                name: "Add Merged Layer",
                action: "CPAddMergedLayer",
                shortcut: "shift+alt+e"
            },
            {
                name: "-"
            },
            {
                hideIfNotAvailable: true,
                name: "Add layer mask",
                action: "CPAddLayerMask"
            },
            {
                hideIfNotAvailable: true,
                name: "Delete layer mask",
                action: "CPRemoveLayerMask",
                shortcut: "shift+m"
            },
            {
                hideIfNotAvailable: true,
                name: "Apply layer mask",
                action: "CPApplyLayerMask",
                shortcut: "ctrl+m"
            },
            {
                name: "-"
            },
            {
                hideIfNotAvailable: true,
                name: "Clip to the layer below",
                action: "CPCreateClippingMask"
            },
            {
                hideIfNotAvailable: true,
                name: "Unclip from the layer below",
                action: "CPReleaseClippingMask"
            }
        ]
    },
    {
        name: "Effects",
        mnemonic: "E",
        children: [
            {
                name: "Clear",
                action: "CPClear",
                mnemonic: "D",
                shortcut: "del,backspace"
            },
            {
                name: "Fill",
                action: "CPFill",
                mnemonic: "F",
                shortcut: "ctrl+f"
            },
            {
                name: "Flip horizontal",
                action: "CPHFlip",
                mnemonic: "Q",
                shortcut: "q"
            },
            {
                name: "Flip vertical",
                action: "CPVFlip",
                mnemonic: "V"
            },
            {
                name: "Invert",
                action: "CPFXInvert",
                mnemonic: "I",
                shortcut: "ctrl+i",
                title: (0, _langJs._)("Invert the image colors")
            },
            {
                name: "-"
            },
            {
                name: "Convert brightness to opacity",
                action: "CPBrightnessToOpacity",
                mnemonic: "B",
                title: (0, _langJs._)("Convert brightness to opacity")
            },
            {
                name: "-"
            },
            {
                name: "Box blur...",
                action: "CPFXBoxBlur",
                mnemonic: "B"
            },
            {
                name: "-"
            },
            {
                name: "Monochromatic noise",
                action: "CPMNoise",
                mnemonic: "M",
                title: (0, _langJs._)("Fills the selection with noise")
            },
            {
                name: "Color noise",
                action: "CPCNoise",
                mnemonic: "C",
                title: (0, _langJs._)("Fills the selection with colored noise")
            }
        ]
    },
    {
        name: "View",
        mnemonic: "V",
        children: [
            {
                name: "Full-screen mode",
                action: "CPFullScreen",
                mnemonic: "F",
                checkbox: true,
                checked: false
            },
            {
                name: "-"
            },
            {
                name: "Zoom in",
                action: "CPZoomIn",
                mnemonic: "I",
                shortcut: "="
            },
            {
                name: "Zoom out",
                action: "CPZoomOut",
                mnemonic: "O",
                shortcut: "-"
            },
            {
                name: "Zoom 100%",
                action: "CPZoom100",
                mnemonic: "1",
                shortcut: "ctrl+0"
            },
            {
                name: "-"
            },
            {
                name: "Reset Rotation",
                action: "CPResetCanvasRotation",
                mnemonic: "R",
                shortcut: "alt+0"
            },
            {
                name: "-"
            },
            {
                name: "Flip View Horizontal",
                action: "CPViewHFlip",
                mnemonic: "H",
                shortcut: "h"
            },
            {
                name: "-"
            },
            {
                name: "Smooth-out zoomed canvas",
                action: "CPLinearInterpolation",
                mnemonic: "L",
                title: (0, _langJs._)("Linear interpolation is used to give a smoothed looked to the picture when zoomed in"),
                checkbox: true,
                checked: true
            },
            {
                name: "-"
            },
            {
                name: "Show grid",
                action: "CPToggleGrid",
                mnemonic: "G",
                shortcut: "ctrl+g",
                checkbox: true,
                checked: false
            },
            {
                name: "Grid options...",
                action: "CPGridOptions",
                mnemonic: "D"
            }
        ]
    },
    {
        name: "Palettes",
        mnemonic: "P",
        children: [
            {
                name: "Rearrange",
                action: "CPArrangePalettes",
                title: (0, _langJs._)("Rearrange the palette windows")
            },
            {
                name: "Toggle palettes",
                action: "CPTogglePalettes",
                mnemonic: "P",
                shortcut: "tab",
                title: (0, _langJs._)("Hides or shows all palettes")
            },
            {
                name: "-"
            },
            {
                name: "Show tools",
                action: "CPPalTool",
                mnemonic: "T",
                checkbox: true,
                checked: true
            },
            {
                name: "Show color",
                action: "CPPalColor",
                mnemonic: "C",
                checkbox: true,
                checked: true
            },
            {
                name: "Show stroke",
                action: "CPPalStroke",
                mnemonic: "S",
                checkbox: true,
                checked: true
            },
            {
                name: "Show misc",
                action: "CPPalMisc",
                mnemonic: "M",
                checkbox: true,
                checked: true
            },
            {
                name: "Show swatches",
                action: "CPPalSwatches",
                mnemonic: "W",
                checkbox: true,
                checked: true
            },
            {
                name: "Show textures",
                action: "CPPalTextures",
                mnemonic: "X",
                checkbox: true,
                checked: true
            },
            {
                name: "Show tool options",
                action: "CPPalBrush",
                mnemonic: "B",
                checkbox: true,
                checked: true
            },
            {
                name: "Show layers",
                action: "CPPalLayers",
                mnemonic: "L",
                checkbox: true,
                checked: true
            }
        ]
    },
    {
        name: "Help",
        mnemonic: "H",
        children: [
            {
                name: "Tablet support",
                mnemonic: "T",
                action: "CPTabletSupport"
            },
            {
                name: "Shortcuts",
                mnemonic: "S",
                action: "CPShortcuts"
            },
            {
                name: "-"
            },
            {
                name: "About",
                mnemonic: "A",
                action: "CPAbout"
            }
        ]
    }
];
function CPMainMenu(controller, mainGUI) {
    const bar = document.createElement("nav");
    bar.className = "navbar navbar-expand-md bg-light";
    bar.innerHTML = `
    <div class="navbar-upper">
      <a class="navbar-brand" href="#">ChickenPaint Be</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#chickenpaint-main-menu-content" aria-controls="chickenpaint-main-menu-content" aria-expanded="false" aria-label="Toggle main menu">
        <span class="navbar-toggler-icon"></span>
      </button>
    </div>
    <div class="collapse navbar-collapse" id="chickenpaint-main-menu-content">
      <div class="navbar-nav"></div>
    </div>
    <div class="widget-nav" id="chickenpaint-palette-toggler-content"></div>
  `;
    const macPlatform = navigator.userAgent.toLowerCase().includes("mac os");
    bar.addEventListener("touchmove", (e)=>e.preventDefault(), {
        passive: false
    });
    function menuItemClicked(target) {
        const action = target.dataset.action;
        const checkbox = target.dataset.checkbox === "true";
        let selected;
        if (controller.isActionAllowed(action)) {
            if (checkbox) {
                target.classList.toggle("selected");
                selected = target.classList.contains("selected");
            } else selected = false;
            controller.actionPerformed({
                action,
                checkbox,
                selected
            });
        }
    }
    function presentShortcutText(shortcut) {
        shortcut = shortcut.toUpperCase().replace(/(,.+)$/, "").replace("=", "+");
        return macPlatform ? shortcut.replace(/([^+])\+/g, "$1") : shortcut.replace(/([^+])\+/g, "$1 ");
    }
    function updateMenuStates(menuElem) {
        menuElem.querySelectorAll("[data-action]").forEach((elem)=>{
            const action = elem.dataset.action;
            const allowed = controller.isActionAllowed(action);
            elem.classList.toggle("disabled", !allowed);
            if (elem.dataset.hideIfNotAvailable === "true") elem.classList.toggle("hidden", !allowed);
        });
        menuElem.querySelectorAll(".dropdown-divider").forEach((div)=>div.classList.remove("hidden"));
        const visible = Array.from(menuElem.querySelectorAll(".dropdown-item:not(.hidden), .dropdown-divider:not(.hidden)"));
        let lastDivider = null;
        visible.forEach((el, i)=>{
            if (el.classList.contains("dropdown-divider")) {
                if (i === 0 || lastDivider) el.classList.add("hidden");
                else lastDivider = el;
            } else lastDivider = null;
        });
        if (lastDivider) lastDivider.classList.add("hidden");
    }
    function fillMenu(menuElem, entries) {
        entries.forEach((topEntry)=>{
            const div = document.createElement("div");
            div.className = "nav-item dropdown";
            div.innerHTML = `
        <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">${(0, _langJs._)(topEntry.name)}</a>
        <ul class="dropdown-menu"></ul>
      `;
            const dropdownMenu = div.querySelector(".dropdown-menu");
            // ドロップダウンメニューのフォーカスを外す
            // 変形操作で↓キーを押下時にメニューが開くのを防止
            function blurIfDropdownFocused() {
                setTimeout(()=>{
                    const activeEl = document.activeElement;
                    if (activeEl instanceof HTMLElement && (activeEl.matches('[data-bs-toggle="dropdown"]') || activeEl.matches(".dropdown-item") || activeEl.closest(".dropdown-menu"))) activeEl.blur();
                }, 10);
            }
            div.querySelector(".dropdown-toggle")?.addEventListener("show.bs.dropdown", ()=>{
                // ドロップダウンメニューのフォーカスを外す
                // 変形操作で↓キーを押下時にメニューが開くのを防止
                blurIfDropdownFocused();
                updateMenuStates(div);
            });
            div.querySelector(".dropdown-toggle")?.addEventListener("hide.bs.dropdown", ()=>{
                // ドロップダウンメニューのフォーカスを外す
                // 変形操作で↓キーを押下時にメニューが開くのを防止
                blurIfDropdownFocused();
            });
            topEntry.children.forEach((entry)=>{
                if (entry.name === "-") {
                    // 区切り線の場合は直接処理
                    const entryElem = document.createElement("hr");
                    entryElem.className = "dropdown-divider";
                    dropdownMenu?.appendChild(entryElem);
                    return; // この後の処理は不要なので、次のエントリに進む
                }
                if (!entry.action || !controller.isActionSupported(entry.action)) return;
                if (entry.action === "CPSend" && !controller.isActionSupported("CPContinue")) {
                    entry.name = (0, _langJs._)("Post Oekaki");
                    entry.shortcut = "ctrl+p";
                }
                let entryElem;
                entryElem = document.createElement("a");
                entryElem.className = "dropdown-item";
                entryElem.href = "#";
                entryElem.dataset.action = entry.action;
                entryElem.innerHTML = `<span>${(0, _langJs._)(entry.name)}</span>`;
                if (entry.checkbox) {
                    entryElem.dataset.checkbox = "true";
                    if (entry.checked) entryElem.classList.add("selected");
                }
                if (entry.hideIfNotAvailable) entryElem.dataset.hideIfNotAvailable = "true";
                if (entry.title) entryElem.title = (0, _langJs._)(entry.title);
                if (entry.shortcut) {
                    if (macPlatform) entry.shortcut = entry.shortcut.replace(/SHIFT/im, "\u21E7").replace(/ALT/im, "\u2325").replace(/CTRL/im, "\u2318");
                    const small = document.createElement("small");
                    small.className = "chickenpaint-shortcut";
                    small.textContent = presentShortcutText(entry.shortcut);
                    entryElem.appendChild(small);
                    (0, _keymasterJsDefault.default)(entry.shortcut, (e)=>{
                        menuItemClicked(entryElem);
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    });
                }
                const li = document.createElement("li");
                li.appendChild(entryElem);
                dropdownMenu.appendChild(li);
            });
            menuElem.appendChild(div);
        });
    }
    function fillWidgetTray(menuElem, entries) {
        entries.filter((e)=>e.mnemonic && controller.isActionSupported(e.action)).forEach((entry)=>{
            const btn = document.createElement("button");
            btn.className = "widget-toggler selected";
            btn.type = "button";
            btn.dataset.action = entry.action;
            btn.dataset.checkbox = "true";
            btn.dataset.selected = (!entry.checked).toString();
            btn.innerHTML = `<span>${entry.mnemonic}</span>`;
            btn.addEventListener("click", (e)=>{
                menuItemClicked(btn);
                e.preventDefault();
            });
            menuElem.appendChild(btn);
        });
    }
    bar.addEventListener("click", (e)=>{
        const target = e.target.closest("a:not(.dropdown-toggle)");
        if (target) {
            menuItemClicked(target);
            e.preventDefault();
        }
    });
    /**
     * 指定されたパレットの表示状態に応じて、対応するトグルボタンやメニュー項目の
     * "selected" クラスの付け外しを行う。
     *
     * @param {string} paletteName - パレット名（例: "Tool", "Color"など）
     * @param {boolean} show - パレットが表示されている場合は true、非表示の場合は false
     *
     * ボタンは #chickenpaint-palette-toggler-content 内の[data-action=CPPalXxx]要素を対象とし、
     * メニュー項目は bar 要素内の[data-action=CPPalXxx]要素を対象とする。
     * これらをまとめて処理し、"selected" クラスを適切に切り替える。
     */ function onPaletteVisChange(paletteName, show) {
        const key = "CPPal" + paletteName.charAt(0).toUpperCase() + paletteName.slice(1);
        const palette_toggler_content = document.getElementById("chickenpaint-palette-toggler-content"); //'button'
        const buttons = palette_toggler_content?.querySelectorAll(`[data-action="${key}"]`) || [];
        const menus = bar?.querySelectorAll(`[data-action="${key}"]`) || [];
        // 両方を一つにまとめて処理
        [
            ...buttons,
            ...menus
        ].forEach((element)=>{
            element.classList.toggle("selected", show);
        });
    }
    fillMenu(bar.querySelector(".navbar-nav"), MENU_ENTRIES);
    fillWidgetTray(bar.querySelector(".widget-nav"), MENU_ENTRIES[5].children);
    mainGUI.getPaletteManager().on("paletteVisChange", onPaletteVisChange);
    const fullScreenToggle = bar.querySelector(".dropdown-item[data-action=CPFullScreen]");
    controller.on("fullScreen", (isFS)=>fullScreenToggle?.classList.toggle("selected", isFS));
    fullScreenToggle?.classList.toggle("selected", controller.isFullScreen());
    this.getElement = ()=>bar;
}

},{"../../lib/keymaster.js":"hFCDu","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"io6EO":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPAboutDialog);
var _bootstrapBundleMinJs = require("bootstrap/dist/js/bootstrap.bundle.min.js");
function CPAboutDialog(parent) {
    // ダイアログのHTML構造
    var dialog = document.createElement('div');
    dialog.classList.add('modal', 'fade', 'chickenpaint-about-dialog');
    dialog.setAttribute('tabindex', '-1');
    dialog.setAttribute('role', 'dialog');
    dialog.innerHTML = `
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">About ChickenPaint Be</h5>
                    <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <a class="chickenpaint-on-github" target="_blank" href="https://github.com/satopian/ChickenPaint_Be" rel="noopener">
                        <span class="icon-github"></span> ChickenPaint Be on GitHub
                    </a>
                    <p>
                        ChickenPaint Be is a customized version of <a href="https://github.com/thenickdude/chickenpaint" target="_blank" rel="noopener">ChickenPaint</a> by satopian.
                    </p>
                    <p>
                        Built on: ${"2025-08-24T03:08:36"}<br>
                        <a href="https://www.gnu.org/licenses/" target="_blank" rel="noopener">GNU General Public License</a><br>
                    </p>
                    <a class="chickenpaint-on-github" target="_blank" href="https://github.com/thenickdude/chickenpaint" rel="noopener">
                        <span class="icon-github"></span> ChickenPaint on GitHub
                    </a>

                    <p>
                        ChickenPaint is a translation of <a href="https://github.com/thenickdude/chibipaint" target="_blank" rel="noopener">ChibiPaint</a>
                        from Java to JavaScript by Nicholas Sherlock / Chicken Smoothie
                    </p>
                    <p>
                        ChibiPaint is Copyright (c) 2006-2008 Marc Schefer. All Rights Reserved
                    </p>
                    <p>
                        ChickenPaint is free software: you can redistribute it and/or modify
                        it under the terms of the GNU General Public License as published by
                        the Free Software Foundation, either version 3 of the License, or
                        (at your option) any later version.
                    </p>
                    <p>
                        ChickenPaint is distributed in the hope that it will be useful,
                        but WITHOUT ANY WARRANTY; without even the implied warranty of
                        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        <a target="_blank" href="https://www.gnu.org/licenses/" rel="noopener">GNU General Public License</a> for more details.
                    </p>
<pre class="pre-scrollable chickenpaint-third-party-licenses">Toolbar icons designed by <a target="_blank" href="https://github.com/Anteira" rel="noopener">Miglena Lapavicheva (Anteira)</a>
    These icons are dual-licensed under <a target="_blank" href="https://spdx.org/licenses/GPL-3.0-or-later.html" rel="noopener">GPL-3.0-or-later</a> and <a target="_blank" href="https://creativecommons.org/licenses/by/3.0/" rel="noopener">CC-BY-3.0</a>

Includes these MIT-licensed libraries:

    Includes the <a target="_blank" href="https://github.com/eligrey/FileSaver.js" rel="noopener">FileSaver.js library</a>
    Copyright (c) 2016 <a target="_blank" href="https://eligrey.com/" rel="noopener">Eli Grey</a>

    Includes the <a target="_blank" href="https://github.com/nodeca/pako" rel="noopener">Pako zlib compression library</a>
    Copyright (c) 2014-2017 by Vitaly Puzrin and Andrei Tuputcyn
    
    Includes the <a target="_blank" href="https://github.com/madrobby/keymaster" rel="noopener">keymaster.js</a> keyboard library
    Copyright (c) 2011-2013 Thomas Fuchs

    Includes the <a target="_blank" href="https://benalman.com/projects/jquery-throttle-debounce-plugin/" rel="noopener">jQuery throttle-debounce</a> library
    Copyright (c) 2010 "Cowboy" Ben Alman
    
    Includes the <a href="https://getbootstrap.com/" target="_blank" rel="noopener">Bootstrap</a> 
    Copyright (c) 2011-2025 <a href="https://github.com/twbs/bootstrap/blob/main/LICENSE" target="_blank" rel="noopener">The Bootstrap Authors</a>

    MIT License

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

Includes Font Awesome by Fonticons, Inc. - <a href="https://fontawesome.com/" target="_blank" rel="noopener">https://fontawesome.com/</a>
Includes Material Design icons by Google - <a href="https://fonts.google.com/" target="_blank" rel="noopener">https://fonts.google.com/</a>
                    </pre>
                </div>
            </div>
        </div>
    `;
    parent.appendChild(dialog);
    // Bootstrap 5 の Modal インスタンスを作成
    var modalInstance = new _bootstrapBundleMinJs.Modal(dialog);
    // モーダルのクローズ時にダイアログを削除
    dialog.addEventListener('hidden.bs.modal', ()=>{
        dialog.remove();
    });
    // モーダル表示用のメソッドを返す
    return {
        show: function() {
            modalInstance.show();
        }
    };
}

},{"bootstrap/dist/js/bootstrap.bundle.min.js":"joWv1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"huRMT":[function(require,module,exports,__globalThis) {
/*
	ChickenPaint

	ChickenPaint is a translation of ChibiPaint from Java to JavaScript
	by Nicholas Sherlock / Chicken Smoothie.

	ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

	ChickenPaint is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	ChickenPaint is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPConfirmTransformDialog);
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
var _bootstrapBundleMinJs = require("bootstrap/dist/js/bootstrap.bundle.min.js");
var _langJs = require("../languages/lang.js");
function CPConfirmTransformDialog(parent, controller) {
    // ダイアログ要素を作成
    const dialog = document.createElement("div");
    dialog.classList.add("modal", "fade");
    dialog.setAttribute("tabindex", "-1");
    dialog.setAttribute("role", "dialog");
    dialog.innerHTML = `
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">${(0, _langJs._)("Complete transform")}</h5>
                    <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>
                        ${(0, _langJs._)("You need to finish transforming this layer before you can do that. What would you like to do with the transform?")}
                    </p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-light chickenpaint-cancel-transform" data-bs-dismiss="modal">${(0, _langJs._)("Cancel")}</button>
                    <button type="button" class="btn btn-light chickenpaint-reject-transform" data-bs-dismiss="modal">${(0, _langJs._)("Undo transform")}</button>
                    <button type="button" class="btn btn-primary chickenpaint-accept-transform" data-bs-dismiss="modal">${(0, _langJs._)("Apply transform")}</button>
                </div>
            </div>
        </div>
    `;
    // ボタン要素を取得
    const that = this;
    const applyButton = dialog.querySelector(".chickenpaint-accept-transform");
    const rejectButton = dialog.querySelector(".chickenpaint-reject-transform");
    const cancelButton = dialog.querySelector(".chickenpaint-cancel-transform");
    // イベントリスナーを追加
    applyButton?.addEventListener("click", function(e) {
        controller.actionPerformed({
            action: "CPTransformAccept"
        });
        that.emitEvent("accept");
        modal.hide();
    });
    rejectButton?.addEventListener("click", function(e) {
        controller.actionPerformed({
            action: "CPTransformReject"
        });
        that.emitEvent("reject");
        modal.hide();
    });
    cancelButton?.addEventListener("click", function(e) {
        modal.hide();
    });
    // Bootstrap 5: Modalコンストラクタを使用してmodalを初期化
    const modal = new _bootstrapBundleMinJs.Modal(dialog);
    // モーダル表示用のメソッド
    this.show = function() {
        modal.show();
    };
    //モーダルを閉じるメソッド
    this.hide = function() {
        modal.hide();
    };
    // モーダルが閉じられた後の処理
    dialog.addEventListener("hidden.bs.modal", (e)=>{
        dialog.remove();
    });
    // Enterキーが押されたときの処理
    function keydown_EnterKey(e) {
        if (e.key === "Enter") {
            // Enterキーが押されたら非表示にする
            modal.hide();
            controller.actionPerformed({
                action: "CPTransformAccept"
            }); // 変形確定
            that.emitEvent("accept");
            parent.removeEventListener("keydown", keydown_EnterKey);
        }
    }
    parent.addEventListener("keydown", keydown_EnterKey);
    // 親要素にダイアログを追加
    parent.appendChild(dialog);
}
// CPConfirmTransformDialogはEventEmitterを継承
CPConfirmTransformDialog.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
CPConfirmTransformDialog.prototype.constructor = CPConfirmTransformDialog;

},{"wolfy87-eventemitter":"gPUo0","bootstrap/dist/js/bootstrap.bundle.min.js":"joWv1","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"72Eiq":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPShortcutsDialog);
var _bootstrapBundleMinJs = require("bootstrap/dist/js/bootstrap.bundle.min.js");
var _langJs = require("../languages/lang.js");
const macPlatform = navigator.userAgent.toLowerCase().includes('mac os');
const Ctrl = macPlatform ? "\u2318" : "Ctrl";
const Alt = macPlatform ? "\u2325" : "Alt";
const ctrlForZoom = macPlatform ? "\u2303" : "Ctrl";
function CPShortcutsDialog(parent) {
    const dialog = document.createElement('div');
    dialog.classList.add('modal', 'fade', 'chickenpaint-shortcuts-dialog');
    dialog.tabIndex = -1;
    dialog.role = 'dialog';
    dialog.innerHTML = `
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">${(0, _langJs._)("Shortcuts")}</h5>
                    <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>${(0, _langJs._)("Many of the menu options and painting tools have keyboard shortcuts which are written next to them or appear when you hover.")}</p>
                    <p>${(0, _langJs._)("Here are some other shortcuts which are not as obvious!")}</p>
                    <div class="chickenpaint-shortcuts-sections">
                        <div class="chickenpaint-shortcuts-section">
                            <h5>${(0, _langJs._)("Color swatches palette")}</h5>
                            <ul class="chickenpaint-shortcuts-list list-unstyled">
                                <li>
                                    <dl>
                                        <dt><span class="chickenpaint-shortcut"><span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Left")}</span></dt>
                                        <dd>${(0, _langJs._)("Use as the drawing color")}</dd>
                                        <dt><span class="chickenpaint-shortcut"><span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Right")}</span></dt>
                                        <dd>${(0, _langJs._)("Remove or replace a color swatch")}</dd>
                                    </dl>
                                </li>
                            </ul>
                        </div>
                        <div class="chickenpaint-shortcuts-section">
                            <h5>${(0, _langJs._)("Line drawing mode")}</h5>
                            <ul class="chickenpaint-shortcuts-list list-unstyled">
                                <li>
                                    <dl>
                                        <dt><span class="chickenpaint-shortcut"><span class="chickenpaint-shortcut-key">Shift</span> + <span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Left")}</span></dt>
                                        <dd>${(0, _langJs._)("Snap line to nearest 45 degrees")}</dd>
                                    </dl>
                                </li>
                            </ul>
                        </div>
                        <div class="chickenpaint-shortcuts-section">
                            <h5>${(0, _langJs._)("Painting tools")}</h5>
                            <ul class="chickenpaint-shortcuts-list list-unstyled">
                                <li>
                                    <dl>
                                        <dt><span class="chickenpaint-shortcut"><span class="chickenpaint-shortcut-key">1</span> - <span class="chickenpaint-shortcut-key">9</span>, <span class="chickenpaint-shortcut-key">0</span></span></dt>
                                        <dd>${(0, _langJs._)("Change brush opacity")}</dd>
                                        <dt><span class="chickenpaint-shortcut"><span class="chickenpaint-shortcut-key">[</span>, <span class="chickenpaint-shortcut-key">]</span></span></dt>
                                        <dd>${(0, _langJs._)("Change brush size")}</dd>
                                    </dl>
                                </li>
                            </ul>
                        </div>
                        <div class="chickenpaint-shortcuts-section">
                            <h5>${(0, _langJs._)("Brush palette")}</h5>
                            <ul class="chickenpaint-shortcuts-list list-unstyled">
                                <li>
                                    <dl>
                                        <dt><span class="chickenpaint-shortcut"><span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Right")}</span><span class="chickenpaint-shortcut-alternate">${(0, _langJs._)("or")}</span><span class="chickenpaint-shortcut"><span class="chickenpaint-shortcut-key">Shift</span> + <span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Left")}</span></dt>
                                        <dd>${(0, _langJs._)("Adjust brush sliders more precisely")}</dd>
                                    </dl>
                                </li>
                            </ul>
                        </div>
                        <div class="chickenpaint-shortcuts-section">
                            <h5>${(0, _langJs._)("Zoom")}</h5>
                            <ul class="chickenpaint-shortcuts-list list-unstyled">
                                <li>
                                    <dl>
                                        <dt><span class="chickenpaint-shortcut"><span class="chickenpaint-shortcut-key">${ctrlForZoom}</span>  + <span class="chickenpaint-shortcut-key">Space</span> + <span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Left")}</span><dt>
                                        <dt><span class="chickenpaint-shortcut-alternate">${(0, _langJs._)("or")}</span>
                                        <span class="chickenpaint-shortcut-key">Z</span> + <span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Left")}</span></dt>
                                        <dd>${(0, _langJs._)("Zoom the canvas")}</dd>
                                    </dl>
                                </li>
                            </ul>
                        </div>
                        <div class="chickenpaint-shortcuts-section">
                            <h5>${(0, _langJs._)("Drawing canvas")}</h5>
                            <ul class="chickenpaint-shortcuts-list list-unstyled">
                                <li>
                                    <dl>
                                        <dt><span class="chickenpaint-shortcut"><span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Middle")}</span> <span class="chickenpaint-shortcut-alternate">${(0, _langJs._)("or")}</span> <span class="chickenpaint-shortcut"><span class="chickenpaint-shortcut-key">Space</span> + <span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Left")}</span></dt>
                                        <dd>${(0, _langJs._)("Move the canvas around")}</dd>
                                        <dt><span class="chickenpaint-shortcut"><span class="chickenpaint-shortcut-key">R</span> + <span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Left")}</span></dt>
                                        <dd>${(0, _langJs._)("Rotate the canvas")}</dd>
                                        <dt><span class="chickenpaint-shortcut"><span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Right")}</span><span class="chickenpaint-shortcut-alternate">${(0, _langJs._)("or")}</span><span class="chickenpaint-shortcut"><span class="chickenpaint-shortcut-key">${Alt}</span> + <span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Left")}</span></dt>
                                        <dd>${(0, _langJs._)("Sample the color under the cursor")}</dd>
                                        <dt><span class="chickenpaint-shortcut"><span class="chickenpaint-shortcut-key">H</span></dt>
                                        <dd>${(0, _langJs._)("Flip View Horizontal")}</dd>
                                    </dl>
                                </li>
                            </ul>
                        </div>
                        <div class="chickenpaint-shortcuts-section">
                            <h5>${(0, _langJs._)("Layers palette")}</h5>
                            <ul class="chickenpaint-shortcuts-list list-unstyled">
                                <li>
                                    <dl>
                                        <dt><span class="chickenpaint-shortcut"><span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Double click")}</span><span class="chickenpaint-shortcut-alternate">${(0, _langJs._)("or")}</span><span class="chickenpaint-shortcut"><span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Right")}</span></dt>
                                        <dd>${(0, _langJs._)("Rename layer")}</dd>
                                        <dt><span class="chickenpaint-shortcut"><span class="chickenpaint-shortcut-key">Shift</span> + <span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Left")}</span></dt>
                                        <dd>${(0, _langJs._)("Toggle mask enable/disable")}</dd>
                                        <dt><span class="chickenpaint-shortcut"><span class="chickenpaint-shortcut-key">${Alt}</span> + <span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Left")}</span></dt>
                                        <dd>${(0, _langJs._)("Toggle mask View")}</dd>
                                        <dt><span class="chickenpaint-shortcut"><span class="chickenpaint-shortcut-key">${Ctrl}</span> + <span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Left")}</span></dt>
                                        <dd>${(0, _langJs._)("Apply layer mask")}</dd>
                                        <dt><span class="chickenpaint-shortcut"><span class="chickenpaint-shortcut-key">Shift</span> + <span class="chickenpaint-shortcut-key">${Ctrl}</span> + <span class="fa icon-mouse-pointer"></span> ${(0, _langJs._)("Left")}</span></dt>
                                        <dd>${(0, _langJs._)("Delete layer mask")}</dd>
                                    </dl>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    // Destroy the modal upon close
    dialog.querySelector('.btn-close').addEventListener('click', ()=>{
        dialog.remove();
    });
    // Initialize the modal using Bootstrap 5 methods
    const modalInstance = new _bootstrapBundleMinJs.Modal(dialog);
    parent.appendChild(dialog);
    this.show = function() {
        modalInstance.show();
    };
}

},{"bootstrap/dist/js/bootstrap.bundle.min.js":"joWv1","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ikDCS":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPBoxBlurDialog);
var _bootstrapBundleMinJs = require("bootstrap/dist/js/bootstrap.bundle.min.js");
var _langJs = require("../languages/lang.js");
function CPBoxBlurDialog(parent, controller) {
    // ダイアログ要素を作成
    const dialog = document.createElement("div");
    dialog.classList.add("modal", "fade");
    dialog.setAttribute("tabindex", "-1");
    dialog.setAttribute("role", "dialog");
    dialog.innerHTML = `
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">${(0, _langJs._)("Box blur")}</h5>
                    <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form>
                        <div class="form-group">
                            <label>${(0, _langJs._)("Blur amount (pixels)")}</label>
                            <input type="number" class="form-control chickenpaint-blur-amount" value="3" min="1">
                        </div>
                        <div class="form-group">
                            <label>${(0, _langJs._)("Iterations (1-8, larger gives smoother blur)")}</label>
                            <input type="number" class="form-control chickenpaint-blur-iterations" value="1" min="1" max="8">
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-light" data-bs-dismiss="modal">${(0, _langJs._)("Cancel")}</button>
                    <button type="button" class="btn btn-primary chickenpaint-apply-box-blur" data-bs-dismiss="modal">${(0, _langJs._)("Ok")}</button>
                </div>
            </div>
        </div>
    `;
    const blurAmountElem = dialog.querySelector(".chickenpaint-blur-amount");
    const blurIterationsElem = dialog.querySelector(".chickenpaint-blur-iterations");
    const applyButton = dialog.querySelector(".chickenpaint-apply-box-blur");
    // Bootstrap 5: Modalコンストラクタを使用してmodalを初期化
    const modal = new _bootstrapBundleMinJs.Modal(dialog);
    // モーダル表示用のメソッド
    this.show = function() {
        // ハンバガーメニューとモーダルの二重表示防止
        const collapseElement = document.getElementById("chickenpaint-main-menu-content");
        if (collapseElement && collapseElement.classList.contains("show")) {
            const bsCollapse = new _bootstrapBundleMinJs.Collapse(collapseElement, {
                toggle: false
            });
            bsCollapse.hide();
        }
        // モーダルを表示
        modal.show();
    };
    // モーダル内でOKボタンがクリックされた時の処理
    applyButton.addEventListener("click", (e)=>{
        let blur = Math.max(parseInt(blurAmountElem.value, 10), 1), iterations = Math.min(Math.max(parseInt(blurIterationsElem.value, 10), 1), 8);
        controller.getArtwork().boxBlur(blur, blur, iterations);
        modal.hide(); // モーダルを閉じる
    });
    // モーダルが閉じられた後の処理
    dialog.addEventListener("hidden.bs.modal", ()=>{
        document.activeElement.blur(); // フォーカスを外す
        dialog.remove(); // ダイアログを削除
    });
    // モーダルが表示された時の処理
    dialog.addEventListener("shown.bs.modal", ()=>{
        blurAmountElem.focus(); // フォーカスを入力欄に当てる
    });
    // エンターキーが押されたときの処理
    dialog.addEventListener("keydown", (e)=>{
        if (e.key === "Enter" && dialog.classList.contains("show")) {
            applyButton.click(); // OKボタンをクリック
            e.preventDefault(); // デフォルトのフォーム送信を阻止
        }
    });
    // 親要素にダイアログを追加
    parent.appendChild(dialog);
}

},{"bootstrap/dist/js/bootstrap.bundle.min.js":"joWv1","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"imtpp":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPTabletDialog);
var _bootstrapBundleMinJs = require("bootstrap/dist/js/bootstrap.bundle.min.js");
function CPTabletDialog(parent) {
    let dialog = document.createElement("div");
    dialog.classList.add("modal", "fade");
    dialog.setAttribute("tabindex", "-1");
    dialog.setAttribute("role", "dialog");
    dialog.innerHTML = `
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Drawing tablet support</h5>
                    <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="chickenpaint-tablet-support chickenpaint-pointerevents-support">
                        <h5>
                            Built-in support for most tablets.
                            <small>macOS, Windows 10 or newer</small>
                        </h5>
                        <div class="chickenpaint-supported-browsers">
                            <div class="chickenpaint-supported-browser">
                                <span class="icon-chrome"></span>
                                Chrome
                            </div>
                            <div class="chickenpaint-supported-browser">
                                <span class="icon-edge"></span>
                                Edge (Windows 10)
                            </div>
                            <div class="chickenpaint-supported-browser">
                                <span class="icon-firefox"></span>
                                Firefox
                            </div>
                        </div>
                        <p class="chickenpaint-not-supported">
                            Your browser doesn't have built-in support for drawing tablets, please try
                            one of the other browsers listed above.
                        </p>
                        <p class="chickenpaint-supported alert alert-success">
                            Your browser has built-in support for drawing tablets!
                        </p>
                    </div>
                </div>
            </div>
        </div>
    `;
    const peSupportElem = dialog.querySelector(".chickenpaint-pointerevents-support");
    const peSupported = !!window.PointerEvent;
    peSupportElem?.classList.toggle("supported", peSupported);
    peSupportElem?.classList.toggle("not-supported", !peSupported);
    // Destroy the modal upon close
    dialog.addEventListener("hidden.bs.modal", (e)=>{
        dialog.remove();
    });
    // Initialize the modal using Bootstrap 5 methods
    const modalInstance = new _bootstrapBundleMinJs.Modal(dialog);
    parent.appendChild(dialog);
    // Show method
    this.show = function() {
        modalInstance.show();
    };
}

},{"bootstrap/dist/js/bootstrap.bundle.min.js":"joWv1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h1ox6":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPGridDialog);
var _bootstrapBundleMinJs = require("bootstrap/dist/js/bootstrap.bundle.min.js");
var _langJs = require("../languages/lang.js");
function CPGridDialog(parent, canvas) {
    // ダイアログ要素を作成
    const dialog = document.createElement("div");
    dialog.classList.add("modal", "fade");
    dialog.setAttribute("tabindex", "-1");
    dialog.setAttribute("role", "dialog");
    dialog.innerHTML = `
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">${(0, _langJs._)("Grid options")}</h5>
                    <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form>
                        <div class="form-group">
                            <label>${(0, _langJs._)("Grid size")}</label>
                            <input type="number" class="form-control chickenpaint-grid-size" value="" min="3">
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-light" data-bs-dismiss="modal">${(0, _langJs._)("Cancel")}</button>
                    <button type="button" class="btn btn-primary chickenpaint-apply-grid-settings" data-bs-dismiss="modal">${(0, _langJs._)("Ok")}</button>
                </div>
            </div>
        </div>
    `;
    const gridSizeElem = dialog.querySelector(".chickenpaint-grid-size");
    const applyButton = dialog.querySelector(".chickenpaint-apply-grid-settings");
    // Bootstrap 5: Modalコンストラクタを使用してモーダルを初期化
    const modal = new _bootstrapBundleMinJs.Modal(dialog);
    this.show = function() {
        // ハンバガーメニューとモーダルの二重表示防止
        const collapseElement = document.getElementById("chickenpaint-main-menu-content");
        if (collapseElement && collapseElement.classList.contains("show")) {
            const bsCollapse = new _bootstrapBundleMinJs.Collapse(collapseElement, {
                toggle: false
            });
            bsCollapse.hide();
        }
        // モーダルを表示
        modal.show();
    };
    // グリッドサイズの初期値を設定
    gridSizeElem.value = canvas.getGridSize();
    // モーダルが閉じられた後にダイアログを削除
    dialog.addEventListener("hidden.bs.modal", ()=>{
        dialog.remove();
    });
    // 「OK」ボタンのクリックイベント
    applyButton.addEventListener("click", ()=>{
        const gridSize = parseInt(gridSizeElem.value, 10);
        canvas.setGridSize(gridSize);
        modal.hide(); // モーダルを手動で閉じる
    });
    // モーダルが表示されたときに、グリッドサイズの入力フィールドにフォーカス
    dialog.addEventListener("shown.bs.modal", ()=>{
        gridSizeElem.focus();
    });
    // Enterキーが押されたときの処理
    dialog.addEventListener("keydown", (e)=>{
        if (e.key === "Enter") {
            e.preventDefault(); // フォーム送信を防ぐ
            applyButton.click(); // OKボタンをクリックしたことにする
        }
    });
    // 親要素にダイアログを追加
    parent.appendChild(dialog);
}

},{"bootstrap/dist/js/bootstrap.bundle.min.js":"joWv1","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ejkL5":[function(require,module,exports,__globalThis) {
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>CPSendDialog);
var _bootstrapBundleMinJs = require("bootstrap/dist/js/bootstrap.bundle.min.js");
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
var _langJs = require("../languages/lang.js");
function CPSendDialog(controller, parent, resourceSaver) {
    let dialog = document.createElement("div");
    dialog.className = "modal fade chickenpaint-send-dialog";
    dialog.tabIndex = -1;
    dialog.setAttribute("role", "dialog");
    dialog.innerHTML = `
        <div class="modal-dialog">
            <div class="modal-content" data-stage="saving">
                <div class="modal-header">
                    <h5 class="modal-title">${(0, _langJs._)("Saving drawing...")}</h5>
                    <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p class="chickenpaint-saving-progress-message">${(0, _langJs._)("Preparing your drawing to be saved, please wait...")}</p>
                    <pre class="chickenpaint-saving-error-message pre-scrollable" style="display: none;"></pre>
                    <div class="progress">
                        <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-light chickenpaint-send-cancel" data-bs-dismiss="modal">${(0, _langJs._)("Cancel")}</button>
                </div>
            </div>
            <div class="modal-content" data-stage="success-not-previously-posted" style="display:none">
                <div class="modal-header">
                    <h5 class="modal-title">${(0, _langJs._)("Drawing saved!")}</h5>
                    <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close">
                    </button>
                </div>
                <div class="modal-body">
                    <p>${(0, _langJs._)("Your drawing has been saved, would you like to post it to the forum now?")}</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary chickenpaint-post-drawing" data-bs-dismiss="modal">${(0, _langJs._)("Yes, post it now")}</button>
                    <button type="button" class="btn btn-light chickenpaint-continue-drawing" data-bs-dismiss="modal">${(0, _langJs._)("No, keep drawing")}</button>
                    <button type="button" class="btn btn-light chickenpaint-exit" data-bs-dismiss="modal">${(0, _langJs._)("No, quit and I'll finish it later")}</button>
                </div>
            </div>
            <div class="modal-content" data-stage="success-already-posted" style="display:none">
                <div class="modal-header">
                    <h5 class="modal-title">${(0, _langJs._)("Drawing saved!")}</h5>
                    <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close">
                    </button>
                </div>
                <div class="modal-body">
                    <p>${(0, _langJs._)("Your drawing has been saved, would you like to view it on the forum now?")}</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary chickenpaint-post-drawing" data-bs-dismiss="modal">${(0, _langJs._)("Yes, view the post")}</button>
                    <button type="button" class="btn btn-light chickenpaint-continue-drawing" data-bs-dismiss="modal">${(0, _langJs._)("No, keep drawing")}</button>
                </div>
            </div>
            <div class="modal-content" data-stage="success-redirect" style="display:none">
                <div class="modal-header">
                    <h5 class="modal-title">${(0, _langJs._)("Drawing saved!")}</h5>
                    <button type="button" class="btn btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>${(0, _langJs._)("Your drawing has been saved, redirecting you to view your new post now...")}</p>
                </div>
            </div>
        </div>
    `;
    let progressMessageElem = dialog.querySelector(".chickenpaint-saving-progress-message");
    let progressError = dialog.querySelector(".chickenpaint-saving-error-message");
    let progressElem = dialog.querySelector(".progress-bar");
    let modal = new _bootstrapBundleMinJs.Modal(dialog);
    let that = this;
    resourceSaver.on("savingProgress", function(progress, message) {
        progressMessageElem.textContent = message;
        progressElem.setAttribute("aria-valuenow", progress * 100);
        progressElem.style.width = progress * 100 + "%";
    });
    resourceSaver.on("savingComplete", function() {
        // "saving" ステージを非表示にする
        dialog.querySelector(".modal-content[data-stage='saving']").style.display = "none";
        // CPContinue と CPExit のサポートを確認して、適切なステージを表示する
        if (controller.isActionSupported("CPContinue")) {
            if (controller.isActionSupported("CPExit")) // "success-not-previously-posted" ステージを表示
            dialog.querySelector(".modal-content[data-stage='success-not-previously-posted']").style.display = "block";
            else // "success-already-posted" ステージを表示
            dialog.querySelector(".modal-content[data-stage='success-already-posted']").style.display = "block";
        } else // "success-redirect" ステージを表示
        dialog.querySelector(".modal-content[data-stage='success-redirect']").style.display = "block";
    });
    resourceSaver.on("savingFailure", function(serverMessage) {
        progressElem.classList.add("progress-bar-danger");
        let errorMessage = (0, _langJs._)("Sorry, your drawing could not be saved, please try again later.");
        if (serverMessage) {
            serverMessage = serverMessage.replace(/^CHIBIERROR\s*/, "");
            if (serverMessage.length > 0) {
                errorMessage += `<br><br>${(0, _langJs._)("The error returned from the server was")}:`;
                progressError.textContent = serverMessage;
                progressError.style.display = "block";
            }
        }
        progressMessageElem.innerHTML = errorMessage;
    });
    dialog.querySelector(".chickenpaint-send-cancel").addEventListener("click", function() {
        resourceSaver.cancel();
    });
    let postButton = dialog.querySelector(".chickenpaint-post-drawing");
    if (postButton) postButton.addEventListener("click", function() {
        controller.actionPerformed({
            action: "CPPost"
        });
    });
    let exitButton = dialog.querySelector(".chickenpaint-exit");
    if (exitButton) {
        exitButton.style.display = controller.isActionSupported("CPExit") ? "" : "none";
        exitButton.addEventListener("click", function() {
            alert("When you want to come back and finish your drawing, just click the 'new drawing' button again and you can choose to continue this drawing.");
            controller.actionPerformed({
                action: "CPExit"
            });
        });
    }
    dialog.addEventListener('hidden.bs.modal', ()=>{
        dialog.remove();
    });
    parent.appendChild(dialog);
    this.show = function() {
        modal.show();
        that.emitEvent("shown");
    };
}
CPSendDialog.prototype = Object.create((0, _wolfy87EventemitterDefault.default).prototype);
CPSendDialog.prototype.constructor = CPSendDialog;

},{"bootstrap/dist/js/bootstrap.bundle.min.js":"joWv1","wolfy87-eventemitter":"gPUo0","../languages/lang.js":"9myCU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ba3Da":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wolfy87Eventemitter = require("wolfy87-eventemitter");
var _wolfy87EventemitterDefault = parcelHelpers.interopDefault(_wolfy87Eventemitter);
const DEFAULTS = {
    toolbarStyle: "new"
}, LOCAL_STORAGE_KEY_NAME = "chickenpaint-prefs";
class CPUserPreferences extends (0, _wolfy87EventemitterDefault.default) {
    /**
     * Either "new" or "old"
     */ toolbarStyle;
    constructor(){
        super();
        this.setDefaults();
    }
    setDefaults() {
        for(let propertyName in DEFAULTS)if (DEFAULTS.hasOwnProperty(propertyName)) this.set(propertyName, DEFAULTS[propertyName]);
    }
    load() {
        let parsed = {};
        try {
            parsed = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY_NAME));
        } catch (e) {
            console.error(e);
        }
        if (!parsed || typeof parsed !== "object") parsed = {};
        for(let propertyName in DEFAULTS){
            if (DEFAULTS.hasOwnProperty(propertyName)) // Emit an event for every property even if we only load the default for this prop:
            try {
                this.set(propertyName, parsed.hasOwnProperty(propertyName) ? parsed[propertyName] : DEFAULTS[propertyName]);
            } catch (e) {
                console.error(e);
            }
        }
    }
    save() {
        try {
            let differsFromDefaults = false;
            for(let propertyName in DEFAULTS){
                if (DEFAULTS.hasOwnProperty(propertyName)) {
                    if (this[propertyName] != DEFAULTS[propertyName]) {
                        differsFromDefaults = true;
                        break;
                    }
                }
            }
            if (differsFromDefaults) localStorage.setItem(LOCAL_STORAGE_KEY_NAME, JSON.stringify({
                toolbarStyle: this.toolbarStyle
            }));
            else localStorage.removeItem(LOCAL_STORAGE_KEY_NAME);
        } catch (e) {
            // Can't do anything about it if user has LocalStorage disabled
            console.error(e);
        }
    }
    set(name, value) {
        this[name] = value;
        this.emitEvent(name, [
            value
        ]);
    }
    get(name) {
        return this[name];
    }
}
exports.default = CPUserPreferences;

},{"wolfy87-eventemitter":"gPUo0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}]},["eiwKx","3lJkm"], "3lJkm", "parcelRequiree58a", {})

//# sourceMappingURL=c.dd9a59b3.js.map
